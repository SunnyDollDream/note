#### **JAVA的类直接用=是引用传递,不是值传递**

#### **StringBuilder和StringBuffer**

**StringBuilder线程不安全,效率高**

**StringBuffer线程安全(方法修饰有synchronized),效率低**

#### java成员属性的默认值

java的对象的成员变量会在定义时赋默认值,

![[Pasted image 20250715151239.png]]

#### 对象变量名为对象的管理者,地位类似指针

#### 修饰符相关

如果一个成员变量没有声明访问修饰符,其为friendly(其实并没有这个修饰符),位于同一个包下的类都可以访问,子类不可以直接访问(除非子类也在同一个包下).

一个.java文件中只能有一个类声明为public(也能声明为private),其余的类都只能在当前包下使用(效果类似于friendly)

final方法无法被重写,final类无法被继承

接口中的成员变量访问修饰符为public static final,方法为public abstract

protect的函数可以在子类中重载为protect或public

#### 函数相关

函数里的内部类只能访问函数中的final常量

匿名类里的方法访问外部变量时不能修改其值(类似于被final修饰)

main函数只能写在public的主类中

#### 底层

一个.java文件中如果有多个类,则在编译时会为每个类生成一个.class文件

char为两个字节,boolean为一个字节

Unicode编码的字符的格式为'\u0000'

#### 乐观锁悲观锁

1.悲观锁：指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态 2.乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

#### Spring

Spring创建Bean的时候默认调用的无参构造器,作为成员的Bean是通过set方法注入的(当使用注解开发时是使用的反射,所以set方法此时非必须,但是需要无参构造器 )

Bean的依赖注入指的是成员属性的注入(包括一般类型和其他Bean)

@repository(Spring的注解)注解的作用类似于@Mapper(Mybatis的注解),平时常用@Mapper

#### 浅克隆和深克隆

浅克隆：最普遍的克隆，即对象实现cloneable接口和重写clone方法，然后调用一次内部不做改写的clone方法克隆出一个对象，如果源对象内部存在引用类型的成员变量，那么就说该克隆是浅克隆，即对于引用类型属性，只克隆引用，两个对象的引用指向同一块内存地址，即同一个对象。

深克隆：基本数据类型变量和引用类型变量指向的对象都会被复制，即针对引用类型的成员变量真正的复制一份，重新开辟空间保存，这样两个引用类型属性互不影响。

(hutool对深克隆的支持:ObjectUtil.cloneByStream(obj),这个类需要实现Serializable接口)

#### 集合的foreach遇到null集合会报错,但是空集合不报错

#### JavaBean的特点

1. 有一个空参构造函数
    
2. 是public类
    
3. 每一个属性都有get,set函数
    
4. 属性都为private
    

#### static的属性和方法都是无法被子类继承的

同理在子类中重载不了父类中的静态方法

#### Java泛型和C++模版的区别

Java泛型作为语法糖,在进入jvm时会进行类型擦除,这也是java实现泛型的方法,而C++使用的方法是代码生成.

“代码生成”：编译器在编译期间识别实际传入的参数类型，生成用于该类型的代码(即不同泛型的类会被真正识别为不同的类,如他们不会共享静态变量)。 “类型擦除”：编译器在编译期间将实际类型擦除，将每个类型都视为Object类型(不同泛型为什么会被识别为同一个类的原因)。

#### 容器类型的具体实现

LinkedList为循环双向链表,ArrayList为顺序表,TreeSet为平衡二叉树

#### JWT

JSON Web Token(JWT | json 网络令牌)是一种开放标准(RFC 7519)，用于在网络应用环境间安全地传递声明(claims)。JWT 是一种紧凑且自包含的方式, 用于作为 JSON 对象在各方之间安全地传输信息。由于其信息是经过数字签名的, 所以可以确保发送的数据在传输过程中未被篡改。

JWT 案例:

```Bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJpbmtrYXBsdW1jaGFubmVsIiwiZXhwIjoiMTE0NTE0In0.-xET51cCeooNbsZlT0IB0rZruoj37kSOW4FZu_bnPgg
```

组成部分:

- Header
    
- Payload
    
- Signature
    

`xxxxx.yyyyy.zzzzz` 分别对应上面三个部分。

Header 案例

```JSON
{"alg": "HS256","typ": "JWT"}
```

进行 base64 加密(可解密),构成了第一部分`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9`

Payload 案例

Payload 部分包含所传递的声明(Claims)。

有三种:

注册声明：这些声明是预定义的，非必须使用的但被推荐使用。官方标准定义的注册声明

如`exp`, 即为过期时间

公共声明: JWT 签发方可以自定义的声明

如`username`

私有声明: JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景, 区别于`注册声明`和`公共声明`。

然后将其进行 Base64 加密，得到 JWT 的第二部分。

Signature 简述

用于验证消息在此过程中没有更改。

#### CORS

跨域就是浏览器当前访问的网页与要请求资源的网页的源不一致

服务器可以在返回内容中设置Access-Control_allow_Origin:<源>(允许通配符)表示那些源可以访问自己的资源,浏览器发送给服务器的请求头中会有Origin:<浏览的网页的源>表名请求来自那个源

也有一些情况浏览器不会处理为CORS请求

1. Script标签中载入的其他域的JS脚本
    
2. Image标签下载入了其他域的图片
    

对于简单请求,浏览器会直接请求服务端检查返回的响应头中的Access controle字段,如果允许当前域则正常的载入并返回显示内容,否则拒绝载入

简单请求的分类

![[Pasted image 20250715151300.png]]

对于非简单请求,浏览器会发出一个Option方法来询问服务器是否允许来自当前域的请求访问该资源,服务器会返回允许访问的域的http方法,以及允许的标头,浏览器会在判断后决定是否发出真正的请求(预检)

对于需要占用较多服务器资源的请求可以设置为非简单请求,可以减少服务器压力

**为什么要使用CORS:**

![[Pasted image 20250715151306.png]]

#### REST

RE指representation(表征性),即数据是以一定格式传输的,如JSON和xml,ST指status Transfer(状态传输),即会把客户端当前的状态通过API请求传递给服务器,而不在服务器存储用户状态

![[Pasted image 20250715151313.png]]

**六个约束:**

1. 存在客户端和服务端且各自独立(无需知道对方的具体实现)
    
2. 统一接口,不同的资源用不同的URI表示,并且这些资源也是通过一定的格式进行管理的(如JSON和xml)
    
3. 无状态,服务端不保存状态
    
4. 缓存
    
5. 分层系统,存在中间件或分布式
    
6. 按需代码(可选),服务端可以响应给客户端一些脚本以拓展客户端功能
    

#### CAP原则

CAP原则又称CAP定理，指的是在一个[分布式系统](https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020)中，**一致性**（Consistency）、**可用性**（Availability）、**分区容错性**（Partition tolerance）。

> 1. 一致性（Consistency）：
>     
> 
> 所有节点在同一时间看到的数据是一致的。
> 
> 任何读操作都能读到最新的写操作结果。
> 
> 一致性要求：一旦某个数据在分布式系统中的某个节点上被更新（如修改成新值），那么后续对该数据的读取操作，无论发生在哪个节点上，都应该返回更新后的值，即：所有节点在同一时间内，都能看到相同、且最新写入的值。
> 
> 思考：在MySQL主从模式下，一个新值写入后还未提交，此时在从节点上读取到了老值，满足CAP的一致性要求吗？ 答案是满足，只要保证事务提交前，所有节点读到的数据都为老值，就满足一致性要求！
> 
> 2. 可用性（Availability）：
>     
> 
> 系统在任何时候都能响应客户端的请求，返回非错误的结果。
> 
> 即使某些节点发生故障，系统仍然可用。
> 
> 可用性强调的是系统对外部请求的响应能力，具体来说，它要求系统能够在一定的时间内，对任何非失败的外部请求做出响应。这意味着，无论系统内部发生什么情况，只要外部用户发出请求，系统都应该尽快做出响应，即使回应的是拒绝服务或错误消息。因此，可用性关注的是系统对外部请求的响应速度和可靠性。
> 
> 3. 分区容错性（Partition Tolerance）：
>     
> 
> 系统在网络分区（即部分节点之间的通信中断）的情况下仍然能够继续运行。
> 
> 分区容错性是分布式系统的基本要求，因为网络分区是不可避免的。
> 
> 节点的加入与断开都可以被认作为系统内的网络分区，因此CAP中的P也可以理解为分布式系统内对于节点动态加入与离开的处理能力

虽然其中的A、P在某些方面看起来相似，但它们关注的焦点并不相同，可用性侧重于系统对用户请求的响应能力，而分区容错性则更侧重于系统在出现网络分区时的表现。

CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。

其中P是分布式系统所必须要保证的

![[Pasted image 20250715151322.png]]

如上图所示，该系统由A、B、C三个节点组成，其中由于C节点故障导致分区问题出现。如果要完全满足CAP里的一致性要求，意味着当外部写入数据时，A节点必须等到C节点同步完成，才能给客户端返回写入成功，可此时C节点已经挂了，注定着数据写不进去……

假设此时出现读取该数据的请求怎么办？此时只有两种办法：

放弃可用性：等待所有节点的数据都达到一致状态，保证任意节点返回的数据都相同，可这时系统必然无法及时响应；

放弃一致性：给客户端返回已经写入进A、B的新数据，但后续C节点恢复，请求去到C时，会出现读取到的数据不一致；

所以C、A之间只能选一个，保证可用性（AP），虽然可以快速响应外部请求，但无法做到任意时间点、所有节点数据的一致；保证一致性（CP），就需要等到所有节点数据达到一致，从而造成系统无法及时响应外部请求，可用性降低。

#### PRO 原则（为了实现 AP下的HC）

恢复点目标，指在数据库灾难发生之后会丢失多长时间的数据，分布式关系型数据库PRO=0，即不会丢失数据PRO 原则（Principles of Replicated Data）是分布式数据库设计中的一组原则，旨在指导如何在分布式系统中实现数据复制。PRO 原则包括以下三个方面：

> P（Partition）：
> 
> 数据分区（Sharding）：将数据分布到不同的节点上，以提高系统的扩展性和性能。
> 
> 分区容错性：确保系统在部分节点故障或网络分区的情况下仍然能够继续运行。
> 
> R（Replication）：
> 
> 数据复制：将数据复制到多个节点上，以提高系统的可用性和容错性。
> 
> 复制策略：包括同步复制和异步复制，同步复制保证强一致性，但可能影响性能；异步复制提高性能，但可能导致数据不一致。
> 
> O（Operation）：
> 
> 操作一致性：确保在数据复制过程中，操作的一致性。
> 
> 操作顺序：确保操作的顺序在所有节点上是一致的，避免数据冲突。

#### PTO 原则（为了实现CP下的HA）

恢复时间目标，指在数据库发生灾难后系统恢复到正常使用所需要的时间，分布式关系型数据RTO<几分钟，能快速回到正常使用状态

PTO 原则（Principles of Time Ordering）是分布式系统中用于处理时间顺序的一组原则，旨在确保分布式系统中的事件顺序一致。PTO 原则包括以下三个方面：

> P（Physical Time）：
> 
> 物理时间：使用物理时钟（如 NTP 同步时钟）来确保事件的时间顺序。
> 
> 物理时间的局限性：物理时钟可能存在误差，无法完全保证时间顺序的一致性。
> 
> T（Logical Time）：
> 
> 逻辑时间：使用逻辑时钟（如 Lamport 时钟、Vector 时钟）来确保事件的时间顺序。
> 
> 逻辑时间的优点：逻辑时钟不受物理时钟误差的影响，能够更好地保证时间顺序的一致性。
> 
> O（Ordering）：
> 
> 事件顺序：确保分布式系统中的事件顺序一致。
> 
> 顺序一致性：确保在所有节点上，事件的顺序是一致的，避免数据冲突。

#### BASE理论

Basically Available、Soft state、Eventually consistent简称为`BASE`理论，该理论相关概念的出现时间很早，但正式提出是源于`ACM`上[《Base: An Acid Alternative》](https://link.juejin.cn?target=https%3A%2F%2Fqueue.acm.org%2Fdetail.cfm%3Fid%3D1394128)这篇论文，由`eBay`系统架构师`Dan Pritchett、John D. Brewer、Peter Bailis`等人于`2008`年发布，该理论提出了三个概念：

- `BA`：`Basically Available`（基本可用）；
    
- `S`：`Soft state`（软状态）；
    
- `E`：`Eventually consistent`（最终一致性）；
    

#### 语法糖 GC JDBC

![[Pasted image 20250715151332.png]]

#### sprig的单例Bean线程安全问题

Bean默认为单例，但是因为注册为Bean的对象一般没有可以修改的员属性，属于无状态的类，而这种类不存线程安全问题，所以只有当Bean中存在可修改的属性时才需要注意线程安全问题，并且此时需要程序员自己解决线程安全问题

#### JAVA IO

![[Pasted image 20250715151347.png]]

**辅助类:**

![[Pasted image 20250715151357.png]]

**FileInputStream :**

创建 :`InputStream f = new FileInputStream("C:/java/hello");`(可以直接制定指定文件名来读取指定文件,也可以使用File来指定)

```Java
File f = new File("C:/java/hello");
InputStream in = new FileInputStream(f);
```

![[Pasted image 20250715151404.png]]

**FileOutputStream:**

该类用来创建一个文件并向文件中写数据。

如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。

有两个构造方法可以用来创建 FileOutputStream 对象。

使用字符串类型的文件名来创建一个输出流对象：(同样也可以用File代替)

`OutputStream f = new FileOutputStream("C:/java/hello")`

![[Pasted image 20250715151416.png]]

**File:**

file对象在创建时可以连接已有的路径

```Java
//File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。
File parent = new File("E://test");
File file = new File(parent,"Test.txt");
File file = new File("E:\\test","Test.txt");
```

1. 创建目录:
    

File类中有两个方法可以用来创建文件夹：

- **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。
    
- **mkdirs()**方法创建一个文件夹和它的所有父文件夹。
    

2. 读取目录
    

一个目录其实就是一个 File 对象，它包含其他文件和文件夹。

如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。

可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。

3. 删除目标
    

删除文件可以使用 **java.io.File.delete()** 方法。需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。

4. 常用方法
    

```Java
String path = getAbsolutePath() //获取文件的绝对路径
String name = getName() //获取文件的名字
boolean = createNewFile() //创建新的文件，可能会发生编译时异常：IOException
boolean = mkdir() //创建新的文件夹 如果父目录不存在，则不能创建
boolean = mkdirs() //创建新的文件夹 即使父目录不存在，也可以创建，即创建级联文件目录
File file = getParentFile() //获取当前file的父亲file对象，如果没有父file对象则返回null
String pname = getParent()// 获取当前file的父亲file名字
File[] files = listFiles() //获取当前file的所有子对象，如果返回的数组对象值为null，则说明它是一个文件，如果不为null，则说明它是文件夹；如果返回的数组对象的length等于0，说明它是空文件夹，返回的数组的length即为它的子对象个数。
//listFiles()可以传入一个FileFilter实现accept方法来筛选文件
String[] names = list() //获取当前file的所有子对象名字
boolean = delete() //删除文件或空的文件夹，不能删除带元素的文件夹
long = length() //获取文件中字节的个数
long = lastModified()//获取文件最后的修改时间—>毫秒值
```

**RandomAccessFile:**

RandomAccessFile支持对文件的读取和写入随机访问（其他的输入流或者输出流只能进行一种操作，要么输入，要么输出）。RandomAccessFile把随机访问的文件对象看作存储在文件系统中的一个大型 byte 数组，然后通过指向该 byte 数组的光标或索引（即：文件指针 FilePointer）在该数组任意位置读取或写入任意数据。

**输入操作从文件指针开始读取字节（以字节为单位进行读取），并随着对字节的读取而****前移****此文件指针。如果**RandomAccessFile**访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而****前移****此文件指针。**

> 在磁盘中和内存中，所有的存储都是以右边为开始点（低），左边为结束点（高），字节的读取或者写入也都是从右到左的顺序。所以是前移

**构造:**

1、RandomAccessFile(File file, String mode)

2、RandomAccessFile(String name, String mode)

> **mode ：**第二个参数是指以什么模式创建读写流，此参数有固定的输入值，必须为"r"/"rw"/"rws"/"rwd"其中一个。
> 
> **r**：以只读方式打开指定文件。如果试图对该RandomAccessFile指定的文件执行写入方法则会抛出IOException **rw**：以读取、写入方式打开指定文件。如果该文件不存在，则尝试创建文件 **rws**：以读取、写入方式打开指定文件。相对于rw模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备，默认情形下(rw模式下),是使用buffer的,只有cache满的或者使用RandomAccessFile.close()关闭流的时候儿才真正的写到文件 **rwd**：与rws类似，只是仅对文件的内容同步更新到磁盘，而不修改文件的元数据

**1，FileWriter类(字符输出流类)**

**构造方法：**

1. FileWriter fw = new FileWriter(String fileName);//创建字符输出流类对象和已存在的文件相关联。文件不存在的话，并创建。
    

如：FileWriter fw = new FileWriter("C:\\demo.txt");

2. FileWriter fw = new FileWriter(String fileName,boolean append);//创建字符输出流类对象和已存在的文件相关联,并设置该该流对文件的操作是否为续写。
    

如：FileWriter fw = new FileWriter("C:\\demo.txt",ture); //表示在fw对文件再次写入时，会在该文件的结尾续写，并不会覆盖掉。

**主要方法：**

void write(String str) //写入字符串。当执行完此方法后，字符数据还并没有写入到目的文件中去。此时字符数据会保存在缓冲区中。此时在使用刷新方法就可以使数据保存到目的文件中去。

viod flush() //刷新该流中的缓冲。将缓冲区中的字符数据保存到目的文件中去。

viod close() //关闭此流。在关闭前会先刷新此流的缓冲区。在关闭后，再写入或者刷新的话，会抛IOException异常。

**2，FileReader类**

1，构造方法

FileReader fr = new FileReader(String fileName);//使用带有指定文件的String参数的构造方法。创建该输入流对象。并关联源文件。

2，主要方法

int read(); // 读取单个字符。返回作为整数读取的字符，如果已达到流末尾，则返回 -1。

int read(char []cbuf);//将字符读入数组。返回读取的字符数。如果已经到达尾部，则返回-1。

void close();//关闭此流对象。释放与之关联的所有资源。

#### SpringBoot 的自动装配原理是基于Spring Framework的条件化配置和@EnableAutoConfiguration注解实现的

自动装配就是应用的依赖将自己的功能注入Springboot,作用类似于Configuration中的配置类