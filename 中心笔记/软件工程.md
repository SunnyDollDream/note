## 一、软件工程概述
### 1. 软件生存期（Software Life Cycle）
软件生存期由软件定义、软件开发和软件维护三个时期组成，每个时期又可进一步划分成若干个阶段。
![[Pasted image 20260106222817.png]]

---

### 2. 软件危机（Software Crisis）
软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。它的行为包括：
- 错误难以消除
- 进度难以控制
- 成本难以控制
- 用户不满意
- 沟通困难
- 对接不上
- 人员变更
原因包括:
- 参与人员众多
- 沟通问题
- 难以单独完成
- 没有统一的标准化管理过程

---

### 3. 软件工程三要素

1. **方法（Method）**  
    描述“**如何做**”，如需求分析方法、设计方法、测试方法
2. **工具（Tool）**  
    支持方法实施的工具，如建模工具、测试工具
3. **过程（Process）**  
    规定“**什么时候做什么**”，即开发流程和阶段划分

三者关系：**过程是骨架，方法是灵魂，工具是支撑**

---

### 4. 快速原型模型（Rapid Prototyping Model）
![[Pasted image 20260106223954.png]]
**是什么**：  
通过快速构建一个可运行的原型系统，让用户参与反馈，从而明确需求。

**干什么**：

- 澄清用户需求
- 减少需求不确定性
- 降低需求理解错误

**使用阶段**：

- **需求分析阶段**

**适用场景**：

- 需求不明确
- 用户难以准确描述需求

---

### 5. RUP 模型（Rational Unified Process）
![[Pasted image 20260106224315.png]]
**干什么的**：  
一种以**用例驱动、以架构为中心、迭代增量开发**的软件过程模型。

**四个阶段**：

1. **初始阶段（Inception）**：明确目标、范围、可行性
2. **细化阶段（Elaboration）**：确定核心需求和系统架构
3. **构建阶段（Construction）**：完成系统功能开发
4. **移交阶段（Transition）**：交付用户、部署运行

---

### 6. 其他常见模型（了解）

面向对象过程模型
- **喷泉模型**
传统过程模型
- **瀑布模型**：阶段顺序推进，文档驱动
- **增量模型**：逐步交付系统功能
- **螺旋模型**：强调风险分析
- **快速模型**

- **敏捷模型**：强调快速迭代和用户参与
- **统一过程模型(RUP)**

---

## 二、可行性研究

### 1. 可行性研究的目的
不是考虑“如何解”，而是**确定问题是否值得去解决**。当然不能靠主观猜想而只能靠客观分析。必须分析几种主要的可能解法的利弊，从而**判断原定的系统规模和目标是否现实，系统完成后所能带来的效益是否大到值得投资开发这个系统的程度**。

---

### 2. 三种常见可行性研究

1. **技术可行性**
    - 对技术做综合评估
    - 技术方案的选择
2. **经济可行性**
    - 成本分析
    - 效益分析
3. **运行（操作）可行性**
    - 用户是否能接受
    - 是否符合组织现有运行环境

---

## 三、需求分析 —— 数据流图（DFD）

### 数据流图的作用

- 描述系统**逻辑功能**
    
- 表现数据在系统中的**流动和处理过程**
    

### 四种基本元素
![[Pasted image 20260106230002.png]]
1. **外部实体**：数据来源或去向
    
2. **处理**：对数据的加工
    
3. **数据流**：数据的流向
    
4. **数据存储**：数据的静态存储
    
**特点**：

- 不涉及实现细节
    
- 自顶向下逐层分解
    
### 数据流图的附加符号
![[Pasted image 20260106230226.png]]
![[Pasted image 20260106230306.png]]
![[Pasted image 20260106230319.png]]
### 案例
![[Pasted image 20260106230407.png]]
![[Pasted image 20260106230426.png]]
![[Pasted image 20260106230437.png]]
![[Pasted image 20260106230505.png]]

---

## 四、总体设计

### 1. 模块的定义

模块（Module）是程序对象有名字的集合。又称“构件”，一般指用一个名字可调用的一段程序。例如，过程、函数、子程序、宏等，是构成软件系统结构的基本元素。

---

### 2. 模块的三种基本属性

- **功能** 即指该模块实现什么功能，做什么事情。必须注意，这里所说的模块功能，应是该模块本身的功能加上它所调用的所有子模块的功能。
- **逻辑** 即描述模块内部怎么做。
- **状态** 即该模块使用时的环境和条件。

---

### 3. 内聚（Cohesion）

内聚性表示一个模块内部各种数据和各种处理之间联系的紧密程度，它是从功能的角度来度量模块内的联系。显然,模块内联系愈紧,即内聚性愈强,模块独立性愈好。

**目标**：高内聚
![[Pasted image 20260106233507.png]]
从低到高：

- 偶然内聚
	模块T中的三条语句毫无关系，A、B、C、D都不在文件CARD FILE 中。模块P、Q、R分别与三条语句有关。
	![[Pasted image 20260106234501.png]]
    又称为巧合型，为了节约空间，将毫无关系（或者联系不多）的各成分放在一个模块中。这样的模块显然不易理解，不易修改。
- 逻辑内聚
	![[Pasted image 20260106234734.png]]
    将几个逻辑上相似的功能放在一个模块中，调用时由调用模块传递的参数确定执行的功能。由于要进行控制参数的传递，必然要影响模块的内聚性。
- 时间内聚
    （时间内聚、经典内聚) 将需要同时执行的成分放在一个模块中，因为模块中的各功能与时间有关，因此又称为时间内聚或经典内聚。
    例如:
	- 初始化系统模块、
	- 系统结束模块、
	- 紧急故障处理模块等均是时间性聚合模块.
- 过程内聚
    把程序流中的某一部分划出组成模块，就得到过程内聚模块。
	例如，把程序流中的循环部分、判定部分、计算部分分成模块，这些模块都是过程内聚模块。
	![[Pasted image 20260106234929.png]]
- 通信内聚
	![[Pasted image 20260106235013.png]]
    模块内有多个功能，它们引用共同的输入数据，或者产生相同的输出数据。
- 信息内聚
	![[Pasted image 20260106235046.png]]
    模块完成多个功能，各功能都在同一数据结构上操作，每一功能有唯一入口。
- 功能内聚（最好）
	![[Pasted image 20260106235125.png]]
    一个模块包括而且仅包括完成某一具体功能所必须的所有成分。或者说，模块的所有成分都是为完成该功能而协同工作、紧密联系、不可分割的。

---

### 4. 耦合（Coupling）

耦合性是指软件结构中模块相互连接的紧密程度，是模块间相互连接性的度量。

**目标**：低耦合
![[Pasted image 20260106232518.png]]
从高到低：

- 内容耦合
	![[Pasted image 20260106233348.png]]
    一个模块直接访问另一模块的内部数据。
	- 一个模块不通过正常入口转到另一模块的内部。
	- 两个模块有部分代码重迭。
	- 一个模块有多个入口。
- 公共耦合
	![[Pasted image 20260106233235.png]]
	一组模块访问同一个公共数据环境，如全局数据结构、共享的通信区、内存的公共覆盖区等，则它们之间的耦合就称为公共耦合。
- 外部耦合
	一组模块访问同一全局简单变量，称之为外部耦合
- 控制耦合
	![[Pasted image 20260106232947.png]]
    一个模块传递给另一模块的信息是用于控制该模块内部逻辑的控制信号，如开关、标志等决策变量。
- 标记耦合
	![[Pasted image 20260106232810.png]]
	优化后
	![[Pasted image 20260106233010.png]]
    一个模块传送给另一个模块的参数是一个复合的数据结构(即是一个对象而不是基本数据类型)
- 数据耦合
	![[Pasted image 20260106232646.png]]
	一个模块传送给另一个模块的参数是一个单个的数据项。一模块调用另一模块时，被调用模块的输入、输出都是简单的数据(若干参数)。属松散耦合。
- 非直接耦合
	![[Pasted image 20260106232700.png]]
	两个模块没有直接关系(模块1和模块2)，模块独立性最强。

---

### 5. 与模块独立性的关系
模块的独立性的度量标准是用耦合性和内聚性两个定性指标来衡量。
独立性比较强的模块应该是具有高内聚性和低耦合度
• 内聚与耦合密切相关，强耦合的模块意味者弱内聚，强内聚模块意味着与其它模块间松散耦合.

• 耦合与内聚都是模块独立性的定性标准，都反映模块独立性的良好程度。

• 模块独立性衡量：耦合是直接的主导因素，内聚则辅助耦合完成。

• 在模块化时：主要利用内聚的概念构件独立性高的模块，而耦合则辅助内聚完成。
- **高内聚 + 低耦合 ⇒ 高模块独立性**
- 模块独立性强，系统更易维护和扩展

---

## 五、程序结构图与复杂度

### 1. 程序流程图
![[Pasted image 20260106235739.png]]
![[Pasted image 20260107000028.png]]
![[Pasted image 20260106235813.png]]
优点：直观，灵活，并且比较容易掌握

缺点：其随意性和灵活性使它存在如下严重缺陷

(1) 由于程序流程图的特点，它本身并不是逐步求精的好工具。因为它使程序员容易过早地考虑程序的具体控制流程，而忽略了程序的全局结构；

(2) 程序流程图中用箭头代表控制流，这样使得程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制；

(3) 程序流程图在表示数据结构方面存在不足。

---

### 2. NS 图
![[Pasted image 20260107000051.png]]
![[Pasted image 20260107000133.png]]
特点

(1) 功能域有明确的规定，并且可以很直观地从N-S图上看出来；

(2) 它的控制转移不能任意规定，必须遵守结构化程序设计的要求；

(3) 很容易确定局部数据和全局数据的作用域；

(4) 很容易表现嵌套关系，也可以表示模块的层次结构。

---

### 3. PAD 图
![[Pasted image 20260107000155.png]]
![[Pasted image 20260107000235.png]]
Advantages: (优点)

• 用PAD符号设计出来的程序必然是结构化程序。

• 程序结构十分清晰; 表现程序逻辑，易读、易懂、易记。

• 容易将PAD图转换成高级语言源程序，这种转换可用软件工具自动完成。

• 即可用于表示程序逻辑，也可用于描绘数据结构。

• 支持自顶向下、逐步求精方法的使用。

• 是面向高级程序设计语言的，如FORTRAN，COBOL和PASCAL等。

---

### 4. 流图（控制流图）
![[Pasted image 20260107000435.png]]


- 结点表示语句
- 边表示控制流

---

### 5. 环形复杂度（Cyclomatic Complexity）

![[Pasted image 20260107000558.png]]
![[Pasted image 20260107000649.png]]
衡量程序逻辑复杂程度  

(计算环形复杂度: 根据程序控制流的复杂程度得出的程序复杂程度. )

Method 1：V(G)=E-N+2 其中，E是流图中边的条数，N是结点数。

Method 2：V(G)=P+1 其中，P是流图中判定结点的数目。

含义：

- 等于程序中**独立路径数**
- 决定测试用例最小数量

---

## 六、测试与可靠性

### 1. 软件测试的目的

关于测试目的，G.J.Myers给出了以下的观点：

（1）测试是为了发现程序中的错误而执行程序的过程；

（2）好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案；

（3）成功的测试是发现了至今为止尚未发现的错误的测试

---

### 2. 黑盒测试（功能测试）

- 等价类划分
思路：将程序输入域划分成若干个部分，即子集，从子集中选取具有代表性的数据作为测试用例。
原则：等价类的划分在很大程度上依靠的是测试人员的经验，下面给出几条基本原则：
（1）输入条件的取值范围 
（2）输入数据的个数限定
（3）相同处理的一组输入 
（4）无效的等价类
（5）空值检查

1) 有效等价类: 是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。
2) 无效等价类: 与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。

设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。

如何划分等价类？

1) 在规定了取值范围或值的个数的情况下, 则可以确立一个有效等价类和两个无效等价类。
	例：输入值是学生成绩，范围是0～100；
2) 在规定了输入值的集合或规定了"必须如何"的条件的情况下,则一个有效等价类和一个无效等价类；
3) 在输入是一个布尔量的情况下, 可确定一个有效等价类和一个无效等价类
4) 规定输入数据的一组值(n个),且每个输入值分别处理,则n个有效等价类和一个无效等价类。
	例：输入条件说明学历可为:专科、本科、硕士、博士四种之一。
5) 规定输入数据必须遵守的规则, 则一个有效等价类和若干个无效等价类（从不同角度违反规则）；
6) 已划分的等价类中各元素在程序处理时，若方式不同, 则应再将该等价类进一步的划分。
最后一步，设计测试用例
（1）为每个等价类编号。
（2）设计新的测试用例，使它能包含尽可能多的尚未被覆盖的“有效”等价类。重复这一过程，直到所有的有效等价类都被覆盖。
（3）设计新的测试用例，使它包含一个尚未被覆盖的“无效”等价类。重复这一过程，直到所有的无效等价类都被覆盖
![[Pasted image 20260107001657.png]]
- 边界值分析
每个等价类中，选取恰好等于、小于和大于边界的值作为测试数据，而不是等价类 的任意值。

选择测试用例的原则：
一、如果输入条件规定了值的范围，则应该取刚达到这个范围的边界值，以及刚刚超过这个范围边界的值作为测试输入数据；
二、如果输入条件规定了值的个数，则用最大个数、最小个数、比最大个数多1个、比最小个数少1个的数做为测试数据；
三、根据规格说明的每一个输出条件，使用规则一；
四、根据规格说明的每一个输出条件，使用规则二；
五、如果程序规格说明给出的输入域或输出域是有序集(如有序表、顺序文件等), 则应选取集合的第一个和最后一个元素作为测试用例；
六、如果程序用了一个内部结构，应该选取这个内部数据结构的边界值作为测试用例；
七、分析规格说明，找出其他可能的边界条件。
![[Pasted image 20260107002019.png]]
![[Pasted image 20260107002048.png]]
![[Pasted image 20260107002110.png]]
![[Pasted image 20260107002124.png]]
- 错误推测法
错误推测法：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。

测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：
• 输入的线性表为空表；
• 表中只含有一个元素；
• 输入表中所有元素已排好序；
• 输入表已按逆序排好；
• 输入表中部分或全部元素相同。

---

### 3. 白盒测试（结构测试）

#### 逻辑覆盖

思路：测试用例对程序内部逻辑覆盖的程度。
![[Pasted image 20260107002437.png]]
根据覆盖的目标，逻辑覆盖又分为：
- 语句覆盖
![[Pasted image 20260107002740.png]]
- 判定覆盖
![[Pasted image 20260107002758.png]]
- 条件覆盖
![[Pasted image 20260107002814.png]]
- 判定／条件覆盖
![[Pasted image 20260107002829.png]]
- 条件组合覆盖
![[Pasted image 20260107002846.png]]

#### 基本路径测试法
>利用流图导出逻辑覆盖的方法

1. 从程序流程图导出控制流图（简称：流图）.
	流图只有二种图形符号：
	- 圆称为流图的结点，代表一条或多条语句。
	- 箭头称为边或连接，代表控制流。
	- 在选择或多分支结构中，分支的汇聚处应有一个汇聚结点。
	- 边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。
2. 设计测试用例实现点覆盖
	使得程序执行路径至少经过流图的每个结点一次（点覆盖标准和语句覆盖标准是相同的）
3. 设计测试用例实现边覆盖
	至少经过流图中每条边一次（边覆盖和判定覆盖是一致的）
4. 设计测试用例实现路径覆盖
	选取足够多测试数据，使每条可能路径都至少执行一次(如果程序图中有环，则要求每个环至少经过一次)

---

### 4. 可靠性

**定义**：  
软件可靠性: 软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。

**影响因素**：

- 软件复杂度
- 开发质量
- 测试充分性
- 运行环境

**目的**：

- 提高系统稳定性
- 减少运行故障

---

## 七、UML 与面向对象

### 1. 类与对象

- **类**：类是一组具有相同属性、操作、关系和语义的对象描述。
    ![[Pasted image 20260107003949.png]]
- **对象**：类的实例
    ![[Pasted image 20260107005936.png]]

---

### 2. 类之间的四种关系
![[Pasted image 20260107004110.png]]
![[Pasted image 20260107004134.png]]
![[Pasted image 20260107004144.png]]

---

### 3. UML 的三个主要模型

分为静态建模和动态建模。
- 静态建模: 用例图、类图、对象图、组件图、部署图
- 动态建模: 时序图、协作图、活动图、状态图

---

### 4. 各种图的用途

- 用例图：
	- 用例图是系统的蓝图: 是外部用户（被称为参与者）所能观察到的系统功能的模型图。
	- 用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。
	![[Pasted image 20260107004621.png]]
	![[Pasted image 20260107004551.png]]
- 类图
    - 描述了类与类之间的静态关系。它不仅定义系统中的类，表示类之间的联系（关联、依赖、聚合等），还包括类的内部结构（类的属性和操作）。
	- 类图描述的是一种静态关系，在系统的整个生命周期都是有效的。
	![[Pasted image 20260107004729.png]]
	![[Pasted image 20260107004804.png]]
	![[Pasted image 20260107004856.png]]
	![[Pasted image 20260107004915.png]]
- 对象图
	![[Pasted image 20260107004959.png]]
- 状态图：描述系统对外部事件如何响应，如何动作。
    ![[Pasted image 20260107005100.png]]
    ![[Pasted image 20260107005217.png]]
    ![[Pasted image 20260107005236.png]]
- 活动图：业务流程
    ![[Pasted image 20260107005532.png]]
- 时序图：对象交互
    ![[Pasted image 20260107005618.png]]
- 协作图
	![[Pasted image 20260107005658.png]]
**泳道**：  
用于区分不同角色或责任主体

---

### 5. 面向对象设计思想

- 抽象
    
- 封装
    
- 继承
    
- 多态
    

---

## 八、软件维护

### 1. 软件维护的定义

所谓软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。

---

### 2. 四种维护类型

改正性维护：把诊断和改正错误的过程。

适应性维护：为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动。

完善性维护：在使用软件的过程中用户往往提出增加新功能或修改已有功能的建议，还可能提出一般性的改进意见。

预防性维护：为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件。

**工作量大小规律**：
![[Pasted image 20260107010507.png]]
> 完善性 > 改正性 > 适应性 > 预防性

---

## 九、项目管理

### 1. 货币的时间价值

- 现在的钱比将来的钱更值钱
    
- 成本估算需考虑时间因素
    

---

### 2. 软件配置管理
软件配置管理是在软件的整个生命期内管理变化的一组活动。具体地说，这组活动用来：

①标识变化；

②控制变化；

③确保适当地实现了变化；

④向需要知道这类信息的人报告变化。

Task 1. 标识管理：标识软件配置中的对象

Task 2. 版本控制：管理软件版本信息

Task 3. 变化控制：接到变化请求之后，首先评估该变化在技术方面的可行性和风险，将评估结果形成“变化报告”，该报告供“变化控制审批者”审阅。

Task 4. 配置审计：
①正式的技术复审：关注被修改后的配置对象的技术正确性，检查是否有遗漏或副作用。
②软件配置审计：通过评估配置对象的那些通常不在复审过程中考虑的特征，如行业标准，是对正式技术复审的补充。

Task 5. 状态报告：书写配置状态报告是软件配置管理的一项任务，它回答下述问题：

①发生了什么事？ ②谁做的这件事？③这件事是什么时候发生的？④它将影响哪些其他事物？

**基线**定义为： 已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它。

软件过程的输出信息可以分为3类：

①计算机程序（源代码和可执行程序）；

②描述计算机程序的文档（供技术人员或用户使用）；

③数据（程序内包含的或在程序外的）。

上述这些项组成了在软件过程中产生的全部信息，我们把它们统称为软件配置，而这些项就是**软件配置项**。

---

### 3. 软件再工程
![[Pasted image 20260107011318.png]]
- **正向工程**：从需求到代码
    
- **逆向工程**：从代码恢复设计
    

---

### 4. 软件质量定义

概括地说，软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。

**技术因素**：

- 正确性
    
- 可靠性
    
- 可维护性
    
- 可移植性
    

---

### 5. 人员安排三种思路

1. **民主制程序员组**
    当所要开发的软件的技术难度较高时，采用民主制程序员组是适宜的。
    优点：组员们对发现程序错误持积极的态度，得到更高质量的代码，有利于解决难题。
	缺点：组员间将缺乏必要的协调,最终可能导致工程失败。
2. **主程序员制**
    ![[Pasted image 20260107012114.png]]
3. **现代程序员组**
    ![[Pasted image 20260107012135.png]]

---

### 6. 成本估算

- **代码行技术（LOC）**
    ![[Pasted image 20260107010935.png]]
- **功能点技术（FP）**
    ![[Pasted image 20260107011010.png]]
    ![[Pasted image 20260107011038.png]]
    ![[Pasted image 20260107011104.png]]
    ![[Pasted image 20260107011127.png]]
    ![[Pasted image 20260107011144.png]]
    ![[Pasted image 20260107011215.png]]

---

### 7. 能力成熟度模型（CMM）
CMM把软件过程从无序到有序的进化过程分成5个阶段，并把这些阶段排序，形成5

个逐层提高的等级。

- 初始级（又称为1级）

- 可重复级（又称为2级）

- 已定义级（又称为3级）

- 已管理级（又称为4级）

- 优化级（又称为5级）