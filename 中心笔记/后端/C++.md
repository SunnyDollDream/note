## 变量

### 基本变量类型

![[Pasted image 20250715112355.png]]
### 变量初始化

```C++
int a = 1;
int b(2);
int c{3};
int d = {4};
```

### 类型转换

#### 转换构造函数

类似拷贝构造函数,但是参数为另一个类的引用,会在用等号连接两个不同的类时隐式调用

#### 动态转换

```C++
dynamic_cast <转换类型> (表达式)
```

动态转换只能用于对象的指针或引用,用于多态类的向下转换(父类转子类)

它会对类型转化分别在编译阶段和运行阶段进行检查,在编译阶段会检查被转换的父类是否为多态类(是否有虚函数),否则不通过,在运行阶段会检查要转换的父类指针的动态类型,保证转化的子类可以被正常使用(否则会返回空指针)

#### 静态转换

```C++
static_cast<转换类型> (表达式) 
```

静态转换只在编译时检查,一般用于向上或向下造型,不要求转换对象一定是多态类,只要兼容即可(即有继承关系即可)

#### 重解释转换

```C++
reinterpret_cast<转换类型> (表达式)
```

重解释转换可以将一个类型的指针转化为另一个类的指针,不会检查是否有效,还可以用于指针到整形或整形到指针的转化

#### 常量转换

```C++
const_cast<转换类型>(表达式)
```

常量转换用于常量与非常量之间的互相转换,转换类型必须是指针或者引用

> 转换后的常量指针所指向的内容仍然不能修改,只是可以作为变量指针被传递了

![[Pasted image 20250715112532.png]]
## 位运算
![[Pasted image 20250715112543.png]]
## 类和对象

### 函数指针

函数的名称其实和数组名一样代表了函数的地址

我们可以用 `返回类型 (*函数指针名称) (参数列表);` 来声明函数指针
![[Pasted image 20250715112603.png]]
函数指针可以直接当做函数使用,也可以解引用后使用(注意要给解引用加括号,因为*优先级低于(),不加括号会先执行函数后对返回值解引用)

函数指针对应的是一类声明相同的函数

获取函数地址时,可以对函数名取地址,也可以不取,效果是一样的
![[Pasted image 20250715112615.png]]
也可以用typedef的方式定义一个函数指针名,这样就可以直接用这个函数名定义变量,而不是带着整个函数的声明了,或者使用auto来接受

> 对于需要传入一个函数指针的地方,可以重载的()运算符,就可以把这个类变为函数对象,可以当做函数来调用

![[Pasted image 20250715112634.png]]
### 智能指针

```C++
shared_ptr<Shape> pShape = shared_ptr<Shape>(new Shape(0,0));
```

这个对象内部有一个引用计数器,使用完毕后不需要显示free会自动释放内存

### 拷贝构造函数

```C++
Shape(const Shape& other);
```

拷贝构造函数的参数为一个const的同类型引用,这个函数会在以下几种情况下被调用,将参数对象的属性值赋值给新的对象(默认的拷贝构造函数进行的是浅拷贝,自己实现的时候可以进行深拷贝)
![[Pasted image 20250715112654.png]]
### 析构函数

```C++
~Example(){
    delete pInt;
}
```

析构函数会在对象被释放时调用,可以用来释放对象的成员竖向

### 头文件

如果想让自己定义的类可以在其他地方使用,可以定义一个头文件,把类定义在里边,在其他源文件中引用这个头文件就可以实现复用了

因为一个头文件可能被多个文件包含,定义头文件时需要添加编译指令

```C++
#ifndef SHAPE_H
#define SHAPE_H
...
#endif
//或
#pragma once
...
#endif
```

### 类的继承

```C++
class Apple: public Fruit{
    ...
}
```

继承时的访问控制符用于限制来自基类的成员的访问权限,即继承到子类中父类属 性最低的访问权限就是这个访问修饰符(如修饰符为protect,基类中的public属性在子类中则会变为protected)
![[Pasted image 20250715112713.png]]
![[Pasted image 20250715112719.png]]
![[Pasted image 20250715112724.png]]
析构函数如果不被声明为虚函数,那么如果用基类指针指向子类,释放内存时就不会调用子类的析构函数,所以为了西沟正常执行,一般把析构都声明为虚函数
![[Pasted image 20250715112735.png]]
#### override和final限定符
![[Pasted image 20250715112742.png]]
用override限定符修饰后就可以指定该函数为父类函数的重写,防止某些情况下以为重写了但是没有重写的情况(比如形参写错了,但是此时编译仍然通过,不容易发现,加了override修饰符后编译器就可以检查出此类错误,并且代码结构也更清晰)
![[Pasted image 20250715112754.png]]
声明final后子类就不可以重写这个方法了

> 这两个关键词不是保留字,可以用在方法或变量名中,但是不推荐

#### 静态成员
![[Pasted image 20250715112815.png]]
静态成员可以用 `类名::静态成员名` 的方法去访问,并且在类中声明后需要显式的初始化,

##### 单例
![[Pasted image 20250715112825.png]]
通过静态成员,可以实现单例效果,如图中所示,因为对象的指针为静态私有变量,所以只会被初始化一次且无法在代码中访问,成员函数负责单例的初始化,并且将该对象的析构和构造函数设置为私有,删除了拷贝构造函数,防止了主动创建对象(但是这是这样写的话不能保证线程安全,需要加锁)

#### const
![[Pasted image 20250715112837.png]]
被const修饰的函数不能修改成员变量,并且也不能调用非const函数

const对象也不能调用非const方法
![[Pasted image 20250715112847.png]]
#### 友元

友元可以让一个类外部的函数或者其他类的成员访问这个类的私有和保护成员(友元的声明需要提前声明类的存在),这里的访问不是类似于自己的成员属性的访问,而是如果拿到了友元的对象,则可以通过这个对象直接访问友元的私有和保护成员
![[Pasted image 20250715112858.png]]
也可以声明一个函数为一个类的友元函数,那么在这个类中也可以直接通过友元对象访问其私有属性

### 类的特殊成员函数
![[Pasted image 20250715112907.png]]
#### 构造函数

对于一个类,如果我们不想让其在外部被创建,我们可以把他的构造函数设置为私有,也可以使用这种方式来删除默认构造函数
![[Pasted image 20250715112917.png]]
> 被删除的函数一般声明在public中,以获取更明确的报错信息

除了用于删除成员函数外,delete还可以用于删除函数某些类型的重载
![[Pasted image 20250715112927.png]]
对于这个函数,由于会将double隐式转换为int,这个结果其实是无效的,我们可以重载double的函数再删除,这样在调用时就会报错了
![[Pasted image 20250715112940.png]]default可以用于声明默认构造函数

#### 拷贝构造函数
![[Pasted image 20250715112951.png]]
默认的拷贝构造函数如上,是浅拷贝

**拷贝赋值运算符:**
![[Pasted image 20250715113003.png]]
#### 移动构造函数
![[Pasted image 20250715113013.png]]
当一个类没有以下五种成员函数时,默认的移动构造函数为第一种形式

**移动赋值运算符:**
![[Pasted image 20250715113024.png]]
![[Pasted image 20250715113030.png]]
这些特殊成员函数都可以使用default和delete关键字

### 平凡可复制类

枚举,指针以及C++自带的基本类型这些都叫做标量类型,它们以及他们的数组在内存中都是连续存储的,可以使用memcpy内存拷贝来快速复制,所以他们也被称为可平凡复制类型

对于一个类,如果满足以下条件,可以被称为平凡可复制类

- 没有虚函数(即不存在虚指针等隐藏成员)
    
- 没有用户自定义的特殊成员函数
    
- 有自动生成析构函数(这两点说明没有需要特殊处理的数据成员)
    
- 所有非静态成员变量也是可平凡复制类型
    
- 拷贝构造函数,移动构造函数,拷贝赋值运算符,移动赋值运算符中至少有一个是未被删除的(这四个函数的默认形式都是按成员逐个复制)
    

> 对于继承类,它的父类也符合上述的条件

平凡可复制类的成员在内存中也是连续存储的,所以可以进行memcpy或转存二进制文件

### 标准布局类型
![[Pasted image 20250715113047.png]]
所有标量类型都是标准布局类型

对于一个非继承类,如果它满足以下条件:

- 没有虚函数
    
- 所有非静态数据成员都有相同的访问控制属性,并且都是标准布局类型
    

这样的类叫做标准布局类

如果是继承类,则要保证这个类和他的所有父类中

- 只有一个类有非静态数据成员
    
- 数据成员的类型和访问控制满足标准布局类的要求
    

### 类型特征

```C++
#include <type_traits>
```

这个库一般用于编译时的类型分析和转化,以及条件编译
![[Pasted image 20250715113101.png]]
它提供了大量类似这样的类模版,调用其中的value值就可以判断参数的具体类型是否为特定类型'
![[Pasted image 20250715113110.png]]
> is_class当参数为class和struct都为true

c++14以后可以声明变量模版
![[Pasted image 20250715113120.png]]
如果想要去除类型上的const和volite,可以使用`remove_cv<T>::type`
![[Pasted image 20250715113134.png]]
## 编译时的条件语句
![[Pasted image 20250715113220.png]]
这里的if constexpr会在编译时进行条件判断,如果不通过则不会编译其中的内容,其中的语句必须是常量表达式

在条件编译时,还常用到static_assert方法,这个方法会在编译条件为假时直接退出编译

## 结构体,联合,枚举

> C++中的结构和联合都可以当做特殊的类

### 结构体

```C++
struct 结构名称{
    变量类型 成员变量;
}; 
```

**初始化:**
![[Pasted image 20250715113234.png]]![[Pasted image 20250715113240.png]]
> 使用空大括号会将结构体内的属性全部声明为0

结构体中如果只有嵌套的结构体和基本变量,那么可以直接进行二进制的转化存进缓存中并还原出来,但是如果有了类就不可以了,此时需要自己序列化

C++中结构体的成员默认都是public的,class的默认都是private的

在C++中结构体也可以写方法,和类一样

### 位域
![[Pasted image 20250715113257.png]]
结构体可以将一个字节或者整形按照比特位分成几部分,每一部分表示一个元素,冒号后边的数字表示占用了几个比特位,具体分布如图所示(每个元素不在占用其数据类型原本的大小,而是只占用给定的比特位数)

![[Pasted image 20250715113312.png]]位域成员必须是整数类型(int,unsigned,bool),而且不能对位域成员取地址
![[Pasted image 20250715113417.png]]
**存储单元（Storage Unit）的概念**

- **存储单元**是编译器为位域分配的最小内存块，大小通常与底层类型相关（如`int`对应4字节）。
    
- 相邻的位域成员**若类型相同且剩余空间足够**，通常会被压缩到同一存储单元中。
    
- **类型不同**的位域成员可能触发新存储单元的分配，具体行为由编译器决定
    

> unsigned与int是否要重新开辟内存要看编译器的行为,通常可认为占用大小相同的类型都不需要重新分配

如果位域成员中间出现了一个数据类型不同的变量,那么会直接分配一个新的存储单元.

只有同样类型连续的元素才会按顺序填充这个类型所占的内存空间

使用了位域的结构体和正常结构体使用方法相同,但是要注意改变了的取值范围

### 联合
![[Pasted image 20250715113429.png]]
联合所占内存大小为联合中最大的类型的大小决定的

联合中的属性同一时间只会有一个生效,如果中途修改其内容则会改变原来存储的内容

### 枚举
![[Pasted image 20250715113437.png]]
枚举中的成员不指定值则默认从0开始排,也可以自己初始化,对于中间出现的没有定义的成员,则会按上一个的值加一
![[Pasted image 20250715113447.png]]
定义枚举后就可以直接在代码里用枚举的成员了,效果类似全局变量,所以如果在两个枚举中写同名变量会冲突,可以在enum后在加一个class,这样在使用枚举成员时就可以通过 枚举名::成员名来区分了

## 运算符的重载

<<位运算符在cout中就进行了重写
![[Pasted image 20250715113457.png]]
这是一种类外重载的方式,我们在调用cout<<str时其实是调用了operator<<(cout,str)这个方法,我们也可以在类内进行重载
![[Pasted image 20250715113511.png]]
此时实际调用会变成这样
![[Pasted image 20250715113523.png]]
> 此时如果类内重载的运算符两端的变量类型不同,可能会出现只能复数+浮点数,而不能浮点数+复数的情况,出现这种情况应该在类外重载运算符,或者把它声明为一个友元函数(友元函数可以声明在类内,但是并不是类的方法)

重载++/--时,后缀方式要有一个int参数,起指示作用,并不需要传入
![[Pasted image 20250715113533.png]]![[Pasted image 20250715113537.png]]
![[Pasted image 20250715113542.png]]
![[Pasted image 20250715113548.png]]
![[Pasted image 20250715113552.png]]
![[Pasted image 20250715113557.png]]
![[Pasted image 20250715113602.png]]
## 宏定义

`#undef`可以取消原来的宏定义
![[Pasted image 20250715113655.png]]
C++中宏定义常量可以用全局const变量代替,带参宏也可以用内联函数替代
![[Pasted image 20250715113705.png]]
![[Pasted image 20250715113711.png]]多行的宏定义可以用\换行

#### 预定义的宏
![[Pasted image 20250715113723.png]]
![[Pasted image 20250715113727.png]]
## 模版

### 函数模版
![[Pasted image 20250715113736.png]]
![[Pasted image 20250715113743.png]]如果根据参数可以确定泛型类型,那么在调用时可以不写尖括号,编译器会根据传入的参数自动确定T的类型
![[Pasted image 20250715113753.png]]平时的泛型方式的实例化方式是隐式实例化,也可以这样显式实例化

函数模版可以重载
![[Pasted image 20250715113802.png]]
模版函数可以专用化,下图就是将double类型特化,如果参数为double并且没有指定模版类型时就会执行特化函数,而不执行原来的函数(如果指定了,那么即使指定的为double也不会执行特化函数)
![[Pasted image 20250715113814.png]]
> 实例化也是特化的一种,所以不能同时存在

![[Pasted image 20250715113844.png]]
### 类模版
![[Pasted image 20250715113853.png]]
**在类外定义成员方法:**
![[Pasted image 20250715113901.png]]
与正常模版函数类似,但是需要在方法前加上对应的类名::

#### 类模版的特化
![[Pasted image 20250715113911.png]]
特化方式是在类名前加上template<>(尖括号留空),在在类名后指定模版类型

> 特化模版类时,如果要使用原来模版类的方法,需要在特化类中重新定义一遍,即特化类不会带有模版类的方法

![[Pasted image 20250715113923.png]]
![[Pasted image 20250715113929.png]]
类模版还可以部分特化,即只声明类模版中的部分参数类型

> 如果同时有分别对两个参数类型的特化,而且实例化时传入的参数类型正好与特化的部分一致,那么编译器会因为不知道该调用哪个特化类而报错,如果必须这样使用就只能定义一个完全特化的类了

![[Pasted image 20250715113941.png]]
特化时还可以将模版形参类型定义为指针类型,这样在传入的参数类型为指针时就会调用这个特化模版

#### 非类型参数
![[Pasted image 20250715113955.png]]
非类型参数只能是整形常量,枚举以及指针,作用与在构造函数中传入参数的效果差不多,但是传入的必须是常量,不能是变量(const 类型也可以)

#### 模版默认值
![[Pasted image 20250715114005.png]]
模版类的参数类型和非类型参数可以指定默认值,这样在声明变量时留空就会使用默认值

#### 模版类作为类模版

类模版的参数还可以是其他模版类
![[Pasted image 20250715114016.png]]
![[Pasted image 20250715114022.png]]
实际效果就是可以把别的模版类当做类型参数传入模版类中

## 命名空间
![[Pasted image 20250715114037.png]]
using namespace实际就是引入了该命名空间中的所有名称,不加就需要 命名空间名::方法名 来调用

Using 也可以只引入一个名,如 using Mynamespace::foo 只引入foo

> using并不一定只能在文件开始处使用,他可以在代码任意部分调用,如在函数中调用的话他引入的内容就只会在个函数内部生效

不使用命名空间的 内容名 会定义在全局命名空间中,如果想要显式的调用可以使用 ::方法名

命名空间也支持嵌套,调用时可以使用 命名空间1::命名空间2::变量名 来指定(如果全局中和自定义命名空间都有同名内容但是在使用时没有指定,那么有可能会编译不通过)

## 异常

C++的异常处理机制也是 try catch 和 throw,error类都有一个.what()方法可以返回错误的描述信息

- runtime_error 是内置的一个异常,构造参数为一个字符串
![[Pasted image 20250715114057.png]]
- Throw 不止可以抛出error,变量,对象和指针都可以作为异常抛出,但是此时需要catch的话需要catch的就是对应的类型而不是异常了
    
- Exception是异常的基类,如果想要自定义异常可以从这个类继承
![[Pasted image 20250715114108.png]]
C++的catch也可以捕捉到一个类及其子类对象,所以如果提前捕获父类异常也会导致后边的子类异常无法被捕获

对于未知异常,catch可以用catch(...)来捕获

## STL库

### 容器类

C++中常用的容器类有

- Array
    
- Vector
    
- Deque
    
- List
    
- Map
    
- Set
    

其中前四个都是序列容器,可以按顺序读取其中的元素,后两个都是通过KV对存储键值的(set可以视为k和v相同的kv对)

#### Vector

```C++
template < class T, class Alloc = allocator<T>> class vector;
```

vector实际有两个模版参数,第一个是容器存储的类型,第二个是用于动态分配内存的类(一般使用默认值 )
![[Pasted image 20250715114127.png]]
vector的构造函数还提供了这种初始化方式,可以直接初始化一个装有相同元素的vector

vector的大小可以用size()获得,容量可以用capacity来获得

所有容器类都可以用iterator来迭代,它就类似于一个指针,可以使用解引用符来获取其当前遍历的元素

> 还有reverse_interator,在进行+1操作时会反而减一

- insert():向vecor任意位置插入任意个元素,返回值为插入的第一个元素的迭代器
    
- push_back()向vector末尾插入元素
    
- emplace()和emplace_back()在插入对象时可以减少一次拷贝,提高效率
    
    - emplace()还支持直接创建一个元素并插入
        
    - emplace(int index,<创建对象所需的属性..>)
![[Pasted image 20250715114142.png]]
- erase()可以删除任意位置的任意个元素,返回删除的元素之后的的迭代器
    
- pop_back()弹出最后一个元素
    
- reserve()可以指定vector的容量
    

迭代器在vector做了增删之后可能会不再有效

#### Array
![[Pasted image 20250715114156.png]]
array是定长数组,与正常arr区别是提供复制函数和迭代器,可以作为容器使用

#### Deque(Double ended queue)

dequq是双向链表,不支持随机访问

> deque的存储是不连续的,他是由多组固定大小的内存块组成

对于链表,只有在迭代器指向的元素被删除才会失效

#### Map

C++中的map是个有序容器,在构造时可以传入比较器,默认是按照key升序排列,底层存储结构为红黑树

**增:**

如果想要给map插入元素,可以直接使用[],下标值为一个map中没有的key时赋值就会直接新建一个元素,也可以使用insert函数来插入,参数为一个pair对象,可以使用std::make_pair(k,v)来创建一个pair对象,这个函数的返回值也是一个pair,k为指向新插入元素的迭代器,v为插入是否成功

**删:**

删除元素可以使用rease(key),返回删除的kv数量(删除失败就是0)

**查:**

- Find:参数为key,如果存在则返回迭代器,否则返回map.end
    
- equal_range
    
- lower_bound: 返回第一个不小于所给定key的元素的迭代器
    
- upper_bound: 返回键值大于所给元素的第一个元素的迭代器
![[Pasted image 20250715114213.png]]
- Count
    

**Multimap:**

类似map,但是他可以存储同一个key的多个值,即允许key重复

其有equal_range方法,传入key可以返回一个pair,key为满足条件的key的第一个迭代器,v为最后一个元素的下一个迭代器

#### Set

与map类似,也可以传入一个比较器,默认升序

**unordered_set:**
![[Pasted image 20250715114229.png]]
无序set插入和存取效率高于set,因为他是用hash计算放在哪里的,可以自己传入hash函数

### 函数封装与绑定

STL提供了函数包装的模版,可以对函数和可调用对象进行包装

- Function
![[Pasted image 20250715114240.png]]
![[Pasted image 20250715114245.png]]
> 上边是标准定义,我们用的是下边的特化模版

他是一个多态函数包装器,R为返回类型,Args为函数参数类型

```C++
function<R(Args...)> fnname = target;
//其中fnname为对象名,target为要封装的函数
```
![[Pasted image 20250715114300.png]]
它还可以封装类的方法
![[Pasted image 20250715114309.png]]
但是在封装时,参数表里的要添加类的引用到第一个参数位置

它甚至还可以封装类的成员属性,这样对这个函数传入一个对应类的对象 就可以取到封装的成员了

- mem_fn
![[Pasted image 20250715114320.png]]
这个模版则是专门用于封装类成员的
![[Pasted image 20250715114327.png]]
使用时可以直接传入类的成员,无需指定模版类型

- Bind
![[Pasted image 20250715114337.png]]
它是用来生成一个函数调用的转发包装器(可调用对象)
![[Pasted image 20250715114347.png]]
如图所示,可以在封装函数时指定参数,这样之后再调用时就可以不用写参数了
![[Pasted image 20250715114356.png]]
也可以使用placeholder中的占位符(_1,_2)来指定使用这个函数封装时传入的参数代表哪一个具体的参数
![[Pasted image 20250715114407.png]]
如果在声明时单纯传入了变量,之后改变变量值不会影响函数封装的效果,如果想要实时反映到函数封装中则可以使用cref

### 智能指针
![[Pasted image 20250715114416.png]]
智能指针封装了指向另一个对象的指针,当其离开作用域时就会被自动销毁,调用析构函数去释放分配的内存

#### unique_ptr
![[Pasted image 20250715114425.png]]
其中deleter是释放管理对象时使用的方法,一般使用默认值即可

> unique_ptr与管理的对象只能是一对一的,不能有多个unique_ptr指向同一个对象,所以不能被拷贝或赋值,作为函数形参时也无法直接传入,需要使用move方法包装来转移对象所有权,原来的智能指针会管理空指针

**常用方法:**
![[Pasted image 20250715114435.png]]
- get可以获取管理对象的指针
    
- 智能指针重载了运算符,可以直接操作智能指针对象来操作其中的指针
    
- release会返回管理对象的指针并且使这个指针脱离智能指针的管理,即不再会被自动释放
    
- reset会直接删除管理的对象,将传入的参数作为新的管理对象
    
- swap用于与另一个智能指针交换管理的对象
    

**构造函数:**
![[Pasted image 20250715114448.png]]
#### shared_ptr

多个shared_ptr可以管理同一个管理对象,此时会有一个引用计数器来记录有多少shared_ptr管理了这个对象,计数器为0时释放管理对象

**常用方法:**
![[Pasted image 20250715114459.png]]
![[Pasted image 20250715114505.png]]
- usecount可以获得引用计数器的值
    
- unique返回引用计数器是否为1
    

shared_ptr还有几个辅助函数

- dynamic_pointer_cast:可以
    
- static_pointer_cast
    
- const_pointer_cast
![[Pasted image 20250715114519.png]]
> 对于智能指针声明的封装对象不同但是指向的都是同一块地址时引用计数器会都算上

shared_ptr会存在循环依赖问题导致无法释放资源
![[Pasted image 20250715114527.png]]
要解决这个问题可以使用weak_ptr声明partner
![[Pasted image 20250715114536.png]]
#### weak_ptr

weak_ptr只能结合shared_ptr使用,构造函数可以传入一个shared_ptr对象,weak_ptr与shared_ptr的区别是不会增加引用计数器

可以使用其中的Lock函数来升级为shared_ptr
![[Pasted image 20250715114546.png]]
shared_ptr和weak_ptr都会管理两块内容,其中控制块是在shared_ptr第一次接管对象时创建的,在shared_ptr被释放后,use_count变为0,对象被释放,但是weak_ptr并不会被同时释放,而是仍存在,但是管理的内容已经不可用,并且此时控制块也不会被释放,只有weak_ptr也离开作用域才会被一起释放

### Algorithm&ranges库

stl的算法库封装了一些常用方法

#### copy_if
```C++
copy_id(first,last,out,pred(可调用对象))
```

这个方法可以找出容器中满足条件的值并复制到新的容器中
![[Pasted image 20250715114603.png]]
> back_inserter(<容器>)可以返回指向该容器末尾的迭代器

在ranges库中也有算法库的扩展,如
![[Pasted image 20250715114611.png]]
view库中还有filter也能实现类似功能
![[Pasted image 20250715114621.png]]
其用法类似linux的管道符,像图中那样调用这个方法,实际上是创建了一个新对象res,这是一个懒加载对象,只有在实际使用时才会计算函数的结果(实际执行函数)
![[Pasted image 20250715114629.png]]
#### Partition

```C++
partition(begin,end,可调用对象)
```

这个方法可以把容器分为满足条件和不满足条件的两部分
![[Pasted image 20250715114641.png]]
返回值bound是一个迭代器,其之前的是满足条件的(不包括bound),之后的是不满足条件的

#### 四个set_函数(差并交集)

要求两个容器是按相同规则按顺序排列的

```C++
set_difference() //在第一个容器中有n个相同的元素,在第二个容器中找到m个与之相同的元素(n>m),之后将n-m个这个元素拷贝到结果(差集)
set_symmetric_difference() //在第一个容器中有n个相同的元素,在第二个容器中找到m个与之相同的元素(n>m),之后将|n-m|(绝对值)个这个元素拷贝到结果
set_symmetric_difference()
```
![[Pasted image 20250715114652.png]]
![[Pasted image 20250715114659.png]]
#### map_reduce
![[Pasted image 20250715114707.png]]
map_reduce用于把大的数据处理任务拆分给各个节点处理,并生成键值对,最后按照键值对进行归并处理
![[Pasted image 20250715114717.png]]
for_each和transform可以进行映射,过滤使用remove_if,reduce进行合并,

最后三个可以看做是对map_reduce的整体封装
![[Pasted image 20250715114726.png]]
![[Pasted image 20250715114730.png]]
这个函数对范围内的元素进行计算,init用于计算初始值(一个映射函数),reduce是对计算结果的合并
![[Pasted image 20250715114739.png]]
![[Pasted image 20250715114744.png]]
## lambda表达式
![[Pasted image 20250715114752.png]]
[]是捕获表达式,用于捕获外层作用域中的变量
![[Pasted image 20250715114800.png]]
![[Pasted image 20250715114806.png]]
捕获也可以分为按值捕获和按引用捕获,在捕获变量前加上引用运算符就可以变为引用捕获,外界的修改可以实时反映到函数中,函数也可以修改捕获的变量了

或者在限定符位置加上mutable,这样捕获的成员就都可以修改了

### 默认捕获
![[Pasted image 20250715114816.png]]
![[Pasted image 20250715114821.png]]
这样就会在使用时自动捕获外部变量了
![[Pasted image 20250715114830.png]]
也可以添加特例

### 捕获类对象

在类中定义lambda可以捕获this指针,来让lambda可以访问类的成员
![[Pasted image 20250715114839.png]]
### 泛型Lambda
![[Pasted image 20250715114848.png]]
参数列表使用auto就可以做到类似泛型的效果了

## 右值引用和移动语义

能用在=左侧的叫做左值,能用在右侧但是不能用在左侧的叫右值

或者说能够获得这个表达式的地址或引用则称为左值
![[Pasted image 20250715114858.png]]
表达式分为两大类,泛左值和右值,泛左值又有左值和xvalue(即将消亡的值),右值包括x-value和纯右值,也可以直接分为左值,x-value和纯右值

### 左值
![[Pasted image 20250715114907.png]]
>其中r是一个左值引用,左值引用的右侧必须是左值

![[Pasted image 20250715114921.png]]
>类的数据成员也是左值

![[Pasted image 20250715114938.png]]
> 返回引用的函数的调用表达式也是左值

### 纯右值
![[Pasted image 20250715114950.png]]
>这里=右侧需要临时计算和转化的都是纯右值

![[Pasted image 20250715114959.png]]
>未命名的类对象也是纯右值(单指S{})

![[Pasted image 20250715115009.png]]
### 右值引用
![[Pasted image 20250715115017.png]]
平时使用的一般的引用都是左值引用
![[Pasted image 20250715115026.png]]
我们可以使用两个&来获得右值引用,右值引用只能绑定右值

> 左值与右值引用赋值时对参数的限制可以用来区别传入的是字面量还是变量
> ![[Pasted image 20250715115045.png]]

如果想要把正常变量转为右值引用,可以使用move函数或者static_cast< ... &&>(),效果是一样的

### 移动语义

要给一个类实现移动语义,需要实现移动构造函数和移动赋值运算符重载函数
![[Pasted image 20250715115058.png]]
> 平时使用单个&声明的是拷贝构造函数和拷贝赋值运算符(即重载=来进行拷贝并释放原先的内存)
> 
> ![[Pasted image 20250715115117.png]]

这两个函数不需要const修饰符,会将要拷贝对象的内容设置为空,转为自己指向那片内存

> 其实移动函数就是平时用的右值给变量赋值,这个过程中创建临时变量会用到移动函数,但是这个过程会被编译器优化掉(拷贝优化,C++17成为标准)

这些方法可以实现类似剪切的效果,省去了重复申请和释放空间的麻烦,而且拷贝需要设计深拷贝的问题,移动就不会有这个问题

> unique因为有对管理内容的唯一权限,所以要转移内容就只能使用移动语义

### Xvalue
![[Pasted image 20250715115125.png]]
这里的move返回的右值引用就是一个xvalue,使用移动拷贝可以重新利用它的内存

**常见的xvalue:**
![[Pasted image 20250715115135.png]]
### 完美转发

完美转发是指函数在用形参接收实参后还能按照实参的类型选择重载函数,因为使用形参接收右值后在函数内部调用其他函数就会被视为左值,所以可以使用万能引用和forward函数来实现完美转发
![[Pasted image 20250715115145.png]]
模版参数的右值引用出现在函数的参数表中时被称为万能引用,它实际上不是右值引用,可以绑定左值也可以绑定右值

对于这种参数,T的类型在判断时如果传入的是左值引用,T则会变为实参类型的引用,否则是非引用形式
![[Pasted image 20250715115155.png]]

> 这里的T实例化为string

**foward:**
![[Pasted image 20250715115224.png]]
参数中的remove_reference可以将T去掉引用转为实际类型

**引用折叠规则:**

因为引用的引用是不合法的,如果出现会采用以下规则修改
![[Pasted image 20250715115234.png]]
## 常量表达式
![[Pasted image 20250715115241.png]]
![[Pasted image 20250715115249.png]]
像这样的表达式就是常量表达式,编译器在编译时会直接替换为计算后的结果以提升运行效率

在C++中有的地方只能接收常量表达式,但是使用函数后不论内容都无法视为常量表达式,此时需要将返回值声明constexpr关键字
![[Pasted image 20250715115257.png]]
使用这个关键字的变量必须使用常量表达式初始化,声明整形时const和constexpr是一个效果,其他类型的就不行了,如果想要当做常量表达式则只能使用constexpr
![[Pasted image 20250715115305.png]]
constexpr是编译时就确定值的常量,const少数情况下是编译时的常量,大部分情况下是运行时的只读变量

使用constexpr修饰的函数被称为常量表达式函数,当其实参都为常量表达式时,其调用也被视为常量表达式,否则被视为一般函数
![[Pasted image 20250715115318.png]]
> 常量表达式函数可以在函数体中声明临时变量,如果这个变量也是constexpr也可以用于返回值
> 
> cmath中的方法可以用于常量表达式函数中

常量表达式函数也支持递归,但是存在最大递归深度,默认为512(同时也是最小值)

还可以声明一个constexpr类,声明方式是将构造函数定义为constexpr(不是修饰类本身)
![[Pasted image 20250715115327.png]]
## decltype运算符
![[Pasted image 20250715115335.png]]
它可以获取参数的类型(包括引用和const,volatile修饰词),但是是相当于替换这个表达式为参数的类型,如
![[Pasted image 20250715115344.png]]
![[Pasted image 20250715120257.png]]
![[Pasted image 20250715120303.png]]![[Pasted image 20250715120306.png]]
![[Pasted image 20250715120311.png]]
>区别于auto,auto不能获取引用和修饰词,只能获取基础类型,如果需要使用则要手动添加

当参数为一个表达式时,与单纯的变量又有所不同,会将表达式的结果去除引用后根据左右值或x值增添引用
![[Pasted image 20250715120330.png]]
![[Pasted image 20250715120335.png]]
对于函数调用,其判断后类型与函数的返回值类型正好一致
![[Pasted image 20250715120350.png]]
decltype是静态的,其中的表达式只会用于类型判断而不会改变变量实际的值

### 占位类型说明符
![[Pasted image 20250715120359.png]]
他会现将auto替换为初始值表达式或函数的返回值表达式

这种用法常用于模版函数返回值类型的自动推导
![[Pasted image 20250715120408.png]]
## 并行编程
![[Pasted image 20250715120416.png]]
### OpenMP

GCC增添一个参数 -fopenmp 后只要使用#pragma就可以将代码转变为并行代码
![[Pasted image 20250715120425.png]]
>Omp parallel for表示将for的每次循环转换为并行计算,其后的reduction是用于reduce计算的运算符和目标变量,图中示例为将每次for的并行结果累加到sum中,因为sum为共享资源,所以需要reduction来特殊声明,它会为sum创建一个本地临时拷贝,初始值与运算符有关,如这里是加则初始值为0,最后将这些临时变量reduce到原变量中

### STL并行算法库

C++17后新增了一些支持并行操作的方法,他们与原来的方法的差别就是第一个参数变为了执行策略

> 需要安装TBB并行执行才能生效

![[Pasted image 20250715120442.png]]
> seq:顺序执行 par:多线程并行 par_unseq:多线程加向量化

#### for_each
![[Pasted image 20250715120451.png]]
#### transform_reduce
![[Pasted image 20250715120459.png]]
>这里的accumulate效果类似于reduce,但是他的计算方法与reduce不同,并且accumulate没有提供并行版本

accumulate:
![[Pasted image 20250715120511.png]]
reduce:
![[Pasted image 20250715120515.png]]使用并行运算的有reduce的函数,用于reduce的操作符需要满足结合律和交换律,因为并行reduce计算顺序会被打乱

### 线程
![[Pasted image 20250715120613.png]]
我们可以使用thread类来创建线程,第一个参数为入口函数,即线程要执行的函数,args是传递给入口函数的参数,如果传入的函数是类的非静态方法,那么args中的第一个参数则会被视为是用于调用这个方法的对象地址,剩下的再作为实参传入

> 这个函数是右值引用,说明只能被移动赋值,这样保证了不会有多个线程对象代表同一个线程

这个入口函数的返回值会被忽略,如果想要获取返回值,需要使用按引用传递的参数或者把返回值存储在类对象中,或者使用promise对象

使用构造函数初始化线程对象后,就会创建一个新线程执行线程函数

> cout线程不安全,如果想在线程内部输出可以使用printf,这个是安全的

![[Pasted image 20250715123645.png]]
![[Pasted image 20250715123654.png]]
> 对于参数中的引用参数需要使用ref函数包装

其中第二个线程的创建是有问题的,f会被拷贝为临时变量,所以无法获取result

#### 常用方法

- get_id(): 可以获取当前线程的线程ID
    
- join(): 当创建并执行了一个线程后,必须等待这个线程运行结束才能结束主线程,可以使用join来使主线程阻塞直到调用这个方法的线程结束,如果在调用时对应的线程已经执行完毕,则会直接返回
![[Pasted image 20250715123708.png]]
> 阻塞的是书写这段代码的线程,等到调用这个方法的线程对象的线程函数执行完毕才会继续向下执行

- joinable(): 返回调用方法的线程是否处于可合并状态,即处于执行或执行完毕且未合并的状态,如果是则返回true,否则直接抛出异常
    

**不能被合并的状态:**
![[Pasted image 20250715123718.png]]
> 对于使用默认构造函数创建的线程,其是一个空线程,不会被执行,可以用于使用移动运算符来获取新的线程

- detach(): 会使调用的线程处于后台运行,主线程不再对其有操作权限
    

#### Fork and Join
![[Pasted image 20250715123728.png]]
就是把一组需要计算的数据平均分为几组,分别计算完毕后再整合

#### Devide and Conquer(分治)
![[Pasted image 20250715123737.png]]
采用递归方式,将一个任务分为两个小任务,让两个线程去执行小任务,子线程继续分解任务直到不能分解为止

但是这样的话只有叶子节点负责的真正的计算,我们可以先让节点分走一半的任务自己处理,再把剩下的任务分配给两个子线程

### promise和future
![[Pasted image 20250715123746.png]]
这两个类为线程之间提供了一种简单的通讯机制,一个线程中可以通过promise设置一个值或者异常,另一个线程则可以通过future获取这个值或异常

实现的核心就是shared state(共享状态),由一对promise和future共享

#### Promise
![[Pasted image 20250715123754.png]]
第一个模版用于传递值,第二个用于传递引用,第三个用于发送信号

**常用方法:**

- promise(): 默认构造函数
    
- promise(promise&& x): 移动构造函数,可以把x的共享状态一并转移
    

> promise没有拷贝构造函数和拷贝复制函数,保证了关联共享状态的唯一性

- get_future()用于获取一个future对象,与调用的promise共用同一个共享状态
    
- set_value用于设置共享状态中的值,并将其设置为就绪状态
    
- set_Exception(): 用于设置共享状态的异常
    

#### Future

一般通过promise的get_future获得

**常用方法:**

- get(): 获得结果,如果共享状态处于未就绪,就会阻塞直到就绪,获取结果只能获取一次
    
- wait(): 等待共享状态直到就绪
    
- wait_for(): 等待指定时长
    
- wait_untill(): 等待到指定时刻(这两个函数返回的都是状态码,包括ready,timeout,deferred(共享状态中含有延缓执行的函数,即只有在显式请求时才会执行的函数)三个枚举值)
![[Pasted image 20250715123810.png]]
> 将promise和future传递给线程时也要注意他们在主线程中的生命周期,避免线程中使用被释放的对象
> 
> 或者使用移动语义的方法

取值时如果共享状态中有异常,则会抛出这个异常

#### shared_future

可以使用这个类来让多个线程获取共享状态中的值
![[Pasted image 20250715123823.png]]
### 互斥和锁

C++中所有的运算如果没有声明是原子操作,默认都为非原子操作

#### Mutex(互斥量)

mutex提供了一种同步机制,来让多个线程安全的访问共享对象

**常用方法:**

- Lock(): 锁定某个互斥量,如果已经被其他线程锁定则进入阻塞,直到该对象被自己锁定
    
- try_lock(): 类似lock,但是没有 锁定成功时不等待,直接返回false(并不一定代表当前互斥量被其他线程锁定),成功返回true
    
- unlock(): 释放互斥量
![[Pasted image 20250715123838.png]]
##### **timed_mutex:**

这个类可以实现有等待时长的互斥

- Lock
    
- try_lock
    
- try_lock_for(): 在指定时长内获得mutex的所有权
    
- try_lock_until(): 在指定时刻前获取mutex的所有权
    
- unlock
    

但是单纯使用mutex可能会导致因为程序异常退出而未正常释放互斥量,可以结合lock_guard,unique_lock,scoped_lock来使用

##### **lock_guard:**
![[Pasted image 20250715123849.png]]
这个类在初始化后直接在构造函数中尝试上锁,在析构函数中再释放这个锁

其还有一个构造函数可以接管一个已经上锁的互斥量,这样就只会在销毁时释放锁了
![[Pasted image 20250715123901.png]]
这样就不需要显式的加解锁了

##### **unique_lock:**

这个类在构造时不锁定,而是显式加锁,也可以显式的解锁,还可以用于给锁计时,唯一与直接上锁不同的就是他的析构函数会尝试释放锁

#### 死锁
![[Pasted image 20250715123921.png]]
如上所示,在锁中再次尝试对已经上锁的互斥量加锁,会因为已经上锁而阻塞,但是此时也无法释放锁,所以会导致死锁

把原来的mutex改为recursive_mutex可以解决,这个锁在被锁定后再次被锁定不会阻塞而是成功,直到调用相同次数的unlock后才会被释放(可重入锁)

#### 活锁

活锁是指一个线程尝试获取锁,但是此时这个锁被另外一个线程所拥有,等待一段时间后该锁被释放,但是并没有被分配给这个等待的线程,而是分配给了另一个等待的线程,这种情况重复的次数多了,就造成了活锁,类似饥饿现象

想要解决活锁和死锁问题,最简单的方法就是按照一定的顺序获取和解锁,C++中提供了lock()方法和scoped_lock类来实现这种思想
![[Pasted image 20250715123932.png]]
![[Pasted image 20250715123936.png]]
lock方法可以同时传入多个锁,但是传入的顺序并不一定就是上锁的顺序,lock内部有算法保证不发生死锁

> 实现原理大致是:
> 
> 假设线程A设置的上锁顺序是ABC,线程B的是BAC,A先获取了A锁,B先获取了B锁,之后A再获取B锁的时候会发现try_lock返回false,此时会直接释放A锁,并将A锁放在上锁顺序的最后,再次lock()B锁进入阻塞,这时B再获取A锁和C锁,结束进程释放所有锁,A再按顺序获取所有锁
> 
> 概括一下就是任何线程在等待资源时不能锁定任何资源,必须释放掉已经锁定的资源才能进入等待

scoped_lock的构造函数可以传入多个锁,他会自动调用lock函数,析构时自动释放这些锁

#### 读写锁

在多个线程同时读取共享资源而不进行写入和修改时,使用mutex会导致这些本可以并发执行的操作串行,从而降低执行效率,此时就可以用读写锁 shared_mutex类

> 读写锁的机制: 当有写请求时,会上写锁,拒绝其他写请求和读请求,写入完毕后释放锁,当有读请求时,上读锁,拒绝写请求允许读请求,但是上了读锁后如果已经有写请求在等待了,那么其他的写请求也会进入等待,排在写请求之后

![[Pasted image 20250715123950.png]]
![[Pasted image 20250715123955.png]]
![](https://gagjcxhxrb.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJmNjUxODBmYmUyY2QzMzViYWI5YzYyNzZiZDdkMjRfQjdYUm1qZUZ6dmhaYUhKa3FXcVZQYUlyVGpnbzc5bzJfVG9rZW46VEhadGJXcENCb2VXU1h4NFFYbmNKTlhDbmJoXzE3NTI1NTQ0MDA6MTc1MjU1ODAwMF9WNA)

独占锁(写锁)的方法与普通锁一致,也可以使用mutex的包装类如lock_guard

此外还有shared_timed_mutex
![[Pasted image 20250715124004.png]]
### 条件变量

条件变量可以用于在线程间发送通知以实现线程之间的同步
![[Pasted image 20250715124013.png]]
接收线程需要一个条件变量等待来自发送线程的通知,直到接受到通知才可以继续运行
![[Pasted image 20250715124020.png]]
C++中的一次通讯大致是这样的:

发送线程用于写入共享数据,接收线程用于读取共享数据,首先接收线程首先获取mutex,然后使用条件变量,等待发送线程的通知,同时释放mutex,之后发送线程先获取mutex,写入共享数据后释放mutex,接收线程获取到通知后,会再次获取mutex开始运行之后的操作,处理完之后释放mutex完成一次通讯

#### 常用方法
![[Pasted image 20250715124030.png]]
![[Pasted image 20250715124035.png]]
调用wait之前当前线程必须先获取这个mutex,之后会立刻释放这个锁并使线程进入等待状态,直到另外一个线程调用了这个条件变量的notify函数才会继续运行,同时再次获取这个mutex

使用这个方法需要注意避免出现写线程提前发出了通知而导致之后进入等待状态的线程无限等待和虚假唤醒(没有满足唤醒条件就被唤醒了)问题

为此我们可以使用重载版本
![[Pasted image 20250715124043.png]]
这个方法就等效于下边的语句,pred就是判断当前是否满足条件,如果满足则不再进入等待,防止信号被提前发出导致永久等待,虚假唤醒会因为不满足pred而再次进入等待状态

#### 与promise的区别
![[Pasted image 20250715124052.png]]
### 信号量

信号量用于实现对有限资源的并发控制访问,它管理了当前资源的可用量,如果可用量不为0则可以进行访问并使可用量减一,为0则进入等待,有资源释放则会加一,并使等待的线程获取资源

信号量只能实现并发访问的数量,但是对共享资源的同步还是需要自己进行控制
![[Pasted image 20250715124100.png]]
counting_semaphore是C++中的信号量,他可以设置计数最大值

binary_semaphore是特化版本,计数最大值为1
![[Pasted image 20250715124109.png]]
他有两类函数,release()将计数器加一,acquire()将计数器减一(如果为0则等待),try_是非阻塞的版本

> 信号量可以由不同的线程获取和释放

### 异步任务

异步任务可以将函数交给另一个线程执行,而不是在本线程,原来的线程可以接着执行下边的代码,有需要时再进行回调
![[Pasted image 20250715124120.png]]
async()用于一般函数,package_task()用于函数封装类
![[Pasted image 20250715124130.png]]
第一个参数为执行策略,第二个是要执行的函数,第三个是传递给函数的参数

策略有三种:

- std::launch::async (对应1): 异步策略,调用时会新建一个线程或用线程池中的线程执行
    
- ~deferred (对应2):推迟调用:只有调用future的get时才会真正调用函数
    
- ~async|~deferred (3): 这个是由编译器决定的,一般都会实现为异步策略
![[Pasted image 20250715124141.png]]
![[Pasted image 20250715124146.png]]
可以看到这个类和函数包装类的定义是一样的,但是package可以调用get_future来获取future对象,直接调用()时不返回结果而是存储在future中,并且是同步执行的,reset可以用于通过future获取结果后重置future,这样就可以再次调用了
![[Pasted image 20250715124157.png]]
一般都是使用另一个线程去调用这个方法

### 线程屏障

latch(一次性)和barrier(多阶段)可以协调多个线程完成任务

线程屏障记录了当前参与同一个任务的正在运行的线程数(需要自己设置),主线程可以根据计数器是否为0来决定是否继续运行
![[Pasted image 20250715124210.png]]
- latch的初始化函数的参数是计数器的初始值
    
- count_down 将计数器减n(默认为1)
    
- wait会阻塞线程到计数器为0后
    
- try_wait 可以判断计数器是否为0,为0返回投入额,否则返回false(但是也不一定不为0,有极少数情况会这样)
    
- arrive_and_wait() :执行了count_down和wait两个函数
    

当计数器为0后,latch不能再次被使用
![[Pasted image 20250715124224.png]]
barrier在计数器归零后会重新设置为初始值,他的模版参数可以传入一个方法,每当计数器归零时都会调用一次

- arrive_and_drop 除了将本次计数减去n,下一阶段的初始值也会减n
    

> 传入的n的值不能大于当前计数值

### 协程(coroutine)

> C++的协程是一堆接口,需要自己实现

协程是一种特殊的函数,他可以在运行过程中暂停执行,并在需要的时候恢复运行,这类函数都必须返回一个协程对象(类似future)
![[Pasted image 20250715124237.png]]
协程对象需要内嵌一个名叫promise_type结构定义并实现其中方法,用于定义协程函数在运行开始结束以及返回时的行为

只要一个函数中包含了co_await,co_yield,co_return这三个协程关键字,编译器就会认为这个函数是一个协程函数

- co_return: 结束携程的执行并返回一个值(并不是协程对象,但是这个返回值需要协程对象获得)
    
- co_yield: 返回值并挂起协程
    
- co_await: 获取值并挂起协程
![[Pasted image 20250715124247.png]]
协程函数(大部分时候是在堆中)创建了一个协程帧(与函数栈帧类似),

#### co_await

这个关键字之后需要带一个表达式,可以是awaitable对象,也可以是重载了co_await运算符的对象,也可以是使用promise_type::await_transform()方法把表达式转换为可等待对象
![[Pasted image 20250715124255.png]]
实际使用时代码运行大致是这样的
![[Pasted image 20250715124303.png]]
首先判断是否就绪,未就绪则挂起,否则执行resume()

它有几种实现
![[Pasted image 20250715124312.png]]
sispend_always会直接将线程挂起,而suspend_never会直接执行resume函数

### 原子类型和操作

原子操作可以分为三类,Load(读),Store(写)和Read Modify Write(RMW,先读取,在修改,最后写入)
![[Pasted image 20250715124322.png]]
#### atomic_flag
![[Pasted image 20250715124333.png]]
这是唯一的无锁的原子操作,即内部没有使用互斥量等机制实现原子操作

,其本质是一个bool类型,true表示标志被设置,false表示标志被清除,也可以使用ATOMIC_FLAG_INIT 宏定义来初始化,其值为false

**成员函数:**
![[Pasted image 20250715124342.png]]
- clear(): 清除标志(将标志设置为false),其参数用于指定内存顺序
![[Pasted image 20250715124353.png]]
- 将标志设置为true,并返回原有的值
我们可以使用这两个方法实现一个自旋锁
![[Pasted image 20250715124408.png]]
- test(): 用于读取数据
    
- wait(oldvalue): 等待条件的达成
![[Pasted image 20250715124419.png]]
- notify_one/all(): 唤醒一个/所有等待线程
    

#### 原子模版
![[Pasted image 20250715124432.png]]
C++提供了原子模版来将普通变量变为原子类型,在主模板中T必须是可平凡拷贝的

这个模版类中有一个is_lock_free()方法,可以用于判断当前类型的原子操作是否是无锁的(这里的无锁即是指使用了操作系统的原子指令,不使用互斥量),基本类型和指针的原子操作都是无锁的,而自定义类型则与类型的大小和对齐有关,要让自定义类型的原子操作满足无锁需要满足对齐条件(类型的大小是2的n次方且小于最大对齐数(一般是16字节))

##### 常用操作
![[Pasted image 20250715124442.png]]
- load()和()重载: 用于原子的获取当前变量的值
    
- store()和=重载: 用于将变量原子的修改
![[Pasted image 20250715124452.png]]
>C++20 之后原子类型都提供了通知和等待函数

![[Pasted image 20250715124501.png]]
对于不同的基本类型还实现了他们之间的运算函数

#### CAS

在C++中想要实现CAS操作可以使用compare_exchange(),其定义如下
![[Pasted image 20250715124511.png]]
> strong和weak版本的区别是weak版本可能会虚假失败

具体实现类似这样:
![[Pasted image 20250715124520.png]]
>判断是否仍等于旧值是为了防止有并发线程在这期间修改了共享资源而导致修改覆盖,如果被修改了就会将新值读取一次进行重试

![[Pasted image 20250715124530.png]]
![[Pasted image 20250715124535.png]]
![[Pasted image 20250715124539.png]]
![[Pasted image 20250715124546.png]]
我们可以使用CAS操作实现无锁堆栈

### 内存模型和顺序

内存一致性模型用于处理多个线程中看到的代码执行顺序的问题

#### 内存模型

##### 顺序一致性模型(Sequentially Consistent)

程序按照编写的代码的顺序执行,并且所有线程都看到相同的执行顺序的内存模型叫做顺序一致性模型(Memory order sequentially consistent)

##### Relaxed
![[Pasted image 20250715124556.png]]
由于CPU和内存之间存在一层缓存,就有可能因为缓存与内存没有及时同步而导致线程在读取共享资源时读到过时资源,从而导致不同线程之间观测其他线程的执行顺序不是内存顺序(因为不同线程之间观测执行顺序是通过主存,就比如这里对线程2而言,线程1就是先读了b的值,再修改了a的值)

或者因为编译器的优化改变两条语句的执行顺序

总之在Relaxed的模式下不对内存顺序做约束

> 这个模式常用于与其他变量或逻辑没有依赖关系的原子量

##### Acquire/Release

对应以下三种枚举值
![[Pasted image 20250715124606.png]]
- memory_order_acquire: 常用于原子量的读取,即将值先读取到缓存中,在进行读取
    
- memory_order_release: 常用于原子量的写入,即在修改过原子量后将缓存中的所有变量都刷新到内存中
    

> 在读写时使用这两个模式可以形成内存屏障
> 
> ![[Pasted image 20250715124621.png]]
> 
> 
> 可以防止优化器改变执行顺序,lock之前的代码不可能移动到unlock后,unlock后的代码也不可能移动到lock前,acquire和release也是同理- memory_order_acquire: 用于先加载再修改的原子操作
    
- memory_order_acquire: 用于先加载再修改的原子操作
## 概念和约束

概念和约束用于限定模版类型实参的范围,关键字为concept和requires

### Requires

#### 使用
![[Pasted image 20250715124657.png]]
##### 表达式形式
![[Pasted image 20250715124706.png]]
它是个常量表达式,这样使用时可以有0-n个参数,求值时会依次对要求进行判断,遇到false则终止返回false,否则返回true

> 这样写时他的参数并不会被实例化,每条条件也不会被求值,而是仅仅判断这些要求是否有效

1. 要求
![[Pasted image 20250715124715.png]]
如上图所示,只会判断每一条条件是否是有效的,而不会进行计算

> 2. 最后一个条件叫做复合要求,大括号内还是判断该表达式是否有效,箭头则是表示这个表达式是否还满足某些特定条件,图中写的是A*1 是否可以被转化为T类型
>     

3. 还有一种要求叫做类型要求,这样的要求以typename开头
![[Pasted image 20250715124728.png]]
图中所示表示判断 T中是否有迭代器类型

4. 嵌套要求
    

这种要求格式是requires 约束表达式
![[Pasted image 20250715124738.png]]
##### 子句形式
![[Pasted image 20250715124746.png]]
常量表达式返回值要是一个bool
![[Pasted image 20250715124753.png]]
这个常量表达式也可以是requires的表达式形式
![[Pasted image 20250715124801.png]]
多个表达式可以使用逻辑运算符链接,如&&和||

### Concept
![[Pasted image 20250715124810.png]]
concept可以定义条件类型
![[Pasted image 20250715124817.png]]
之后就可以在require子句中直接使用概念
![[Pasted image 20250715124841.png]]
也可以在定义模版时直接替换typename,可以限制实参的范围
![[Pasted image 20250715124850.png]]
还有一种用法就是concept auto
![[Pasted image 20250715124858.png]]
这样定义的模版和使用template定义的模版效果一致

## 模块
![[Pasted image 20250715124906.png]]
模块可以用来代替传统的.h文件
![[Pasted image 20250715124914.png]]
模块的拓展名并没有标准,在msvc中使用.ixx,gcc使用.cpp/.cxx
![[Pasted image 20250715124923.png]]
在module到export module 之间的区域叫做全局模块片段,用于包含头文件,定义宏等,只用于模块内部,对外不可见,也意味着这里的宏定义不会影响其他源文件中的宏定义

Export module <模块名> 用于声明和导出模块,模块名尽量和文件名保持一致(不强制要求)

模块中添加了export的内容才是对外可见的,其他的都不可见

使用时使用import导入
![[Pasted image 20250715124933.png]]
也可以模块中只声明不定义,具体定义由另外的文件负责,此时就不需要在内容前加export了

### 分区

一个模块可以分为多个模块单元
![[Pasted image 20250715124943.png]]
![[Pasted image 20250715124947.png]]
在主模块中声明导出内容,在子模块中导入主模块导出的内容,实现后进行导出,这样就实现了模块分区

这样在使用时就只需要导入主模块,子模块会被自动导入

## Ranges库

这个库提供了范围(Range)概念,视图(views),适配器(Adaptor),管道式的函数组合(function composition)以及一系列优化了与容器交互的方法

如常规的sort()函数需要传入容器的起始地址和结束地址,但是ranges库里提供的sort只需要传入容器即可

> ranges里提供的sort并不是函数,而是一个函数对象,其他方法也都是函数对象,这种函数对象称为定制点(CPO)

### Range概念

符合range概念的类型要求能够通过迭代器进行遍历,提供表示范围开始的迭代器和一个结束标记(sentiel),例如begin()作为范围开始的迭代器,end()作为结束标记

所有的容器类型都符合Range概念

range概念还有几个细分的概念
![[Pasted image 20250715124959.png]]
- random_access_range: 要求容器可以随机访问某个元素
    
- contiguous_range: 具有连续存储
    
- bidirectional_range: 提供双向迭代器
    
- forward_range: 提供单向迭代器
    

### View

view也符合range概念,但是他本身不包含元素,而是基于其他Range对象的元素,改变了查看其他容器的方式(类似SQL视图)

视图都有惰性求值的概念,即创建视图时并不立刻进行处理,而是真正使用时才进行处理,但是多次访问也会导致多次计算

创建视图时可以根据其他视图

### Adapter

view中有views::filter()函数对象,可以传入一个容器和方法来过滤容器中的内容,类似这样的函数对象叫做adapter

我们在使用view时一般都是通过适配器创建视图,而不是直接创建
![[Pasted image 20250715125011.png]]
![[Pasted image 20250715125015.png]]
常用的适配器还有

- Transform: 将容器中的元素按照提供的函数进行变换
    
- Drop: 获取容器中第n个元素及之后的元素
    
- Iota: 生成的视图可以通过重复递增初始值来生成有限和无限个元素
![[Pasted image 20250715125024.png]]
> 如图,会生成一个从11到25的数列,如果不传入结束值,则会生成无穷数列

- take_while: 获得第一个不满足条件的元素之前的所有元素
    

### 管道运算符
![[Pasted image 20250715125034.png]]
ranges库重载了|运算,作用类似linux的管道符,图中例子意为依次将左边的容器传入右侧的视图中,可以增加符合视图代码的可读性,此处复合视图也都满足惰性计算的性质

### Generator

通过协程产生元素的视图类,generator是一个协程对象,也是一个视图
![[Pasted image 20250715125049.png]]
在主函数中将协程对象当做视图使用,每次遍历新元素都会自动resume协程函数来获取新的值

## 工具类

C++17中引入了几个工具类

- Any: 可以存储任何可复制构造类型的值
    
- Variant: 表示一个类型安全的联合
    
- Optional: 封装一个可选对象
    

### Any
![[Pasted image 20250715125059.png]]
any实际上存储了被存储对象的类型和值
![[Pasted image 20250715125106.png]]
- any_cast<>: 这是一个函数模版,会尝试获取a中所包含的值,如果与传入的类型实参相匹配,则可以成功返回值,否则抛异常
    
- any.emplace<>: 可以直接在any对象中构建所包含的值并替换原有对象
    
- 直接使用赋值运算符会将b中内容复制一份到a中
    

### Variant

variant可以视为是union类的安全替代,与any功能类似,但是只能存储指定范围内的类型

正常的union在以不是其中存储的值的类型取出时会发生未定义行为,但是varient会直接抛异常
![[Pasted image 20250715125120.png]]
- get<>() 可以获取variant中的值,类型不匹配时会报错
![[Pasted image 20250715125129.png]]
- variant.index(): 可以获取当前值的类型的索引
    
- holds_alternative<>(): 可以判断variant对象是否含有指定类型的值
    

但是这样操作还是比较麻烦,所以C++还提供了visit函数

#### Visit()
![[Pasted image 20250715125139.png]]
我们可以在一个结构体中自定义每种值的操作,在调用visit函数,传入自定义结构体和variant对象,这样visit就可以自动判别应该怎么处理variant了

> 还有另外一种调用方式--overload
> 
> ![[Pasted image 20250715125154.png]]
> 
> 
> 在形参类型前的class...表示可以同时传入不定数量的模版实参,之后的Ts..表示将传入的类型展开,这样overload就可以同时继承多个类型
> 
> 再在结构体定义中加上using Ts::operator()(这里是一个方法)...;这样编译器就会将所有基类中的指定方法引入成为自己的成员函数
> 
> 如果要在C++17使用这种方式,还需要加上这样一段语句
> 
> ![[Pasted image 20250715125223.png]]
>  
> 指导C++将参数的实例化参数类型作为模版参数的实参

### Optional

optional可以作为函数返回值来判断函数是否调用成功
![[Pasted image 20250715125412.png]]
optional可以直接作为bool使用,存在值返回true,否则返回false

在C++23中还为optional添加了几个方法
![[Pasted image 20250715125424.png]]
- and_then(<可执行对象>): 如果optional对象中不含有值,则会调用传入的可执行对象,并将执行后的结果填入optional中,如果含有值则返回optional本身
    
- Transform(<~>): 对optional对象中的值进行变化
    
- or_else(<~>): 如果optional含有值则会执行可调用对象,并返回一个新的optional对象
    

这几个操作称为单子式操作

#### Expected
![[Pasted image 20250715125434.png]]
这个类型模版可以传入两个类型实参,第一个是预期的值的类型,第二个是得不到值时返回的类型

一般这个模板是用于错误处理使用的,可以将第二个类型指定为错误信息
![[Pasted image 20250715125442.png]]
> 得到值和未得到值实际是代码中赋予expected不同的值确定的,如果未得到值则赋给unexpected,否则则直接赋值想要的值

这个模板与variant一样可以使用单子式操作,不同的是or_else操作,传入的可调用类型需要以未获得值时的类型作为形参

## 实参依赖查找
![[Pasted image 20250715125451.png]]
![[Pasted image 20250715125456.png]]
cat::func()这种标识符叫做有限定的标识符,func()叫做未限定的标识符,编译器会分别进行有限定的查找和无限定的查找

有限定的查找就会在对应的命名空间中查找对应的函数,而无限定查找则会查找常规查找范围和实参所在的命名空间,之后会选择参数类型更加匹配的那个

ADL只适用于函数和函数模板,如果找到了成员函数,函数对象或lambda对象就不在进行实参依赖查找

### 定制点
![[Pasted image 20250715125504.png]]
有些标准库中的函数允许用户在自己的命名空间,为某些类型定义函数重载,并能够通过ADL找到这个函数,这样的函数就叫做定制点,如swap,begin和end等

除了我们自己定义的函数会受自己重载的定制点函数的影响,所有使用定制点的函数都会受影响,如reverse中就调用了swap,如果参数为自定义的命名空间中的类型就会调用自己的重载而不是标准库中的函数

> 如果想让一个地方能够尝试使用定制点函数,需要引入对应的定制点函数原型,否则无法使用

### 定制点对象

C++20中,存在一些定制点对象,他们是一些可调用类型,使用这些对象时不需要自己using导入原定制点函数,如ranges中的swap,begin,end等

#### Niebloid

niebloid在ranges中叫做算法函数对象(AFO),也是一组定制点对象,是为了避免使用非限定名的算法函数时,因为ADL而无法使用ranges库(ranges中的算法函数参数更宽泛,优先级不如std的算法库)
![[Pasted image 20250715125518.png]]
也就是说在使用ranges中的函数是ADL不会起作用