![[Pasted image 20250715131526.png]]
![[Pasted image 20250715131537.png]]
![[Pasted image 20250715131544.png]]
![[Pasted image 20250715131552.png]]
![[Pasted image 20250715131557.png]]


**进程:** 进程就是用来加载指令、管理内存、管理 IO 的,当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程,进程就可以视为程序的一个实例,在windows 中进程是不活动的，只是作为线程的容器

**线程:** 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行

**区别:**

1. 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
    
2. 进程拥有共享的资源，如内存空间等，供其内部的线程共享
    
3. 进程间通信较为复杂,同一台计算机的进程通信称为IPC(Inter-process communication),不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
    
4. 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
    
5. 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低
    

**单核和多核问题:**

- 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu，不至于一个线程总占用 cpu，别的线程没法干活
    
- 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
    
- I0 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 I0】，这时相当于线程虽然不用 cpu，但需要一直等待 I0 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化
    

**同步和异步:**

以调用方角度来讲,如果需要等待结果返回，才能继续运行就是同步。不需要等待结果返回，就能继续运行就是异步

## 基础

#### 创建线程

New Thread时可以传入形参作为线程的名字

在新建线程的时候除了使用匿名内部类的方法,还可以使用lamda方法实现方法

主线程调用回调方法时还是会阻塞的,阻塞到对应线程返回结果

#### 查看和杀死进程

在windows的cmd中可以使用tasklist查看进程,taskkill结束进程

对于java程序,可以使用jps命令查看所有java进程,jstack `<PID>`查看某个Java进程的所有线程状态

jconso1e 来査看某个 Java 进程中线程的运行情况(图形界面)

**jconsole 远程监控配置:**

需要以如下方式运行你的 java 类

```Java
java -Diava.rmi.server.hostname=<ip地址> -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=<连接端口> -Dcom.sun.management.imxremote.ss1=(是否安全连
接) -Dcom.sun.management.jmxremote.authenticate=(是否认证java类)
```

修改 /etc/hosts 文件将 127.0.0.1 映射至主机名

如果要认证访问，还需要做如下步骤

复制jmxremote.password 文件

修改 jmxremote.password 和imxremote.access 文件的权限为 600 即文件所有者可读写

连接时填入controlRole(用户名)，R&D(密码)

**Linux:**

- ps -fe 查看所有进程
    
- ps-fT -P`<PID>`查看某个进程(PID)的所有线程
    
- kill 杀死进程
    
- top 按大写 H 切换是否显示线程
    
- top-H-P`<PID>`查看某个进程(PID)的所有线程
    

#### 线程运行原理

每个线程启动后，虚拟机就会为其分配一块栈内存。每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存,每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法

**线程上下文切换(Thread Context Switch):**

是指因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码

- 线程的 cpu 时间片用完(失去CPU使用权)
    
- 垃圾回收(给GC线程让步)
    
- 有更高优先级的线程需要运行
    
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法
    

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器(Program Counter Register)，它的作用是记住下一条jvm指令的执行地址，是线程私有的。状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等,Context Switch 频繁发生会影响性能

#### 常用方法

1. Sleep
    

调用Thread.sleep()可以让调用的线程休眠

> 使用线程对象调用sleep和直接调用sleep(相当于当前对象调用sleep)都是等效于使用Thred调用的,sleep()是一个静态方法,这么设计的原因是为了防止一个线程休眠另一个线程导致的死锁

新版本JDK建议使用TimeUnit的sleep(),这个方法支持指定时间单位,可读性更好

`TimeUnit.`_`SECONDS`_`.sleep(1);`

2. interrupt（非静态）
    

对于正在sleep()的线程,其他线程可以调用<要打断的线程的对象>.interrupt()方法来唤醒,但是这样睡眠线程会报错,需要使用try-catch进行捕获,并且该线程的代码并不一定会立刻得到执行

3. yield
    

调用Thread.yield会让当前线程从Ruming进入Runnable就绪状态,然后调度执行其它线程

4. setPriority(非静态): 设置当前线程的优先级,默认为5,越高越容易被调用
    
5. Join(非静态)
    

使用线程对象调用.join()可以使当前线程阻塞直到调用方法的线程结束,可以传入最长的等待时间

6. interrupt(非静态)
    

使用对应的线程对象调用.interrupt()可以打断调用该方法的线程,同时线程对象中都会有一个打断标记,打断标记默认为false,如果是调用了wait,join或者sleep等方法后处于阻塞的线程被打断,会抛出异常同时将打断标记恢复为false,正常线程被打断后不会影响原线程的运行,只是打断标记会变为true,可以调用isInterrupted()来获取打断标记,这样就可以优雅的打断线程,在结束线程前可以再执行一些操作(两阶段终止模式)

7. interrupted
    

这是一个静态方法,作用类似于isInterrupted(),但是这个方法同时会清除打断标记

8. stop()(非静态,已弃用)
    

这个方法会直接kill线程,如果线程此时持有锁就会导致锁无法被释放

9. LockSupport.park
    

这个方法会使当前线程停止运行,被打断后使打断标记变为真,但是如果执行此方法时打断标记不为false则不会暂停

#### 守护线程

守护线程会在其他非守护线程结束后强制结束,即使代码没有执行完也会结束

> GC就是一个守护线程

#### 线程的五种状态

五种状态是从操作系统层面来描述的

![[Pasted image 20250715131618.png]]

- 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联(即在代码中创建了Thread对象但是还没有调用start)
    
- 【可运行状态】(就绪状态)指该线程已经被创建(与操作系统线程关联)，可以由CPU调度执行
    
- 【运行状态】指获取了 CPU 时间片运行中的状态,当 CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换
    
- 【阻塞状态】如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】,等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态),与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们
    
- 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态
    

#### 线程的六种状态

六种状态是从JAVA的api来区分的(通过getState()来获取)

![[Pasted image 20250715131706.png]]

- NEW 线程刚被创建，但是还没有调用 start()方法
    
- RUNNABLE 当调用了 start()方法之后，Java API层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】(由于 BIO 导致的线程阻塞(即调用阻塞api)，在 Java 里无法区分，仍然认为是可运行)
    
- BLOCKED(锁阻塞)，WAITING(join等无时限阻塞)，TIMED_WAITING(sleep等有时限阻塞) 都是Java API层面对【阻塞状态】(JAVA的阻塞状态,和上边的系统的阻塞状态不一样)的细分
    
- TERMINATED 当前线程代码运行结束