> JVM本质是运行在计算机上的程序,他的职责是运行java字节码文件

## JVM的功能

#### 1.解释和运行

![[Pasted image 20250715131859.png]]

JVM会将字节码转换为机器码,使其能在计算机上运行.

#### 2.内存管理

JVM会自动为对象,方法等分配内存,其GC机制还可以回收不再使用的对象.

#### 3.即时编译(Just-In-Time,JIT)

JVM会把热点代码(即被多次调用的代码)编译为机器码后存储在内存中,之后在运行这些代码时就省略了翻译的步骤,提高了运行效率.

## 常见的JVM

- HotSpot(自带)
    
- GraalVM(微服务,云原生,多语言)
    
- DragonWell JDK(并发,性能)
    
- Eclipse OpenJ9(微服务,云原生)
    

## JVM的组成
![[Pasted image 20250715131910.png]]

**1.类加载器:**加载.class文件到内存中.

**2.运行时数据区域:**管理JVM使用到的内存.

**3.执行引擎:**包括即时编译器,翻译器,垃圾回收器等,将字节码文件中的指令解释成机器码，同时使用即时编译器优化性能.

**4.本地接口:**调用本地已经编译的方法，比如虚拟机中提供的c/c++的方法.

## 字节码文件的组成

**1.基础信息**:魔数(文件头)、字节码文件对应的Java版本号(主版本号 - 44即为JDK版本),访问标识(public final等等),父类和接口

**2.常量池**:保存了字符串常量(常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。字节码指令中通过编号引用到常量池的过程称之为符号引用。)、类或接口名、字段名,主要在字节码指令中使用

**3.字段**:当前类或接口声明的字段信息

**4.方法**:当前类或接口声明的方法信息,字节码指令

> 常见的字节码指令(`<n>`替换为具体数值):
> 
> iconst_`<n>` 将n放入操作数栈(用于临时存放数据)中
> 
> `istore_<n>`将操作数栈中的值存放在下标为n的局部变量表数组中
> 
> `iload_<n>`将数组中下标为n的值复制到操作数栈中
> 
> iadd 将操作数栈中最上边的两个数相加
> 
> `iinc<a>by<b>`将局部变量表中下标为a的值增加b(不取到操作数栈中进行)

```Java
int i = 0;//结果为i=0,因为i++先使用iload将i=0加载到了操作数栈,然后又用iinc将变量表中的i增加1变为1,
i = i++;  //最后才把操作数栈中的0存储到变量表中的i中,所以最后才会是0(++i会先iinc在iload)
```

**5.类的属性**:类的属性，比如源码的文件名,内部类的列表等

## 类的生命周期

![[Pasted image 20250715132034.png]]

#### 1.加载阶段

- 第一步是类加载器根据类的全限定名通过不同的渠道(本地文件,动态代理生成,网络传输)以二进制流的方式获取字节码信息,程序员可以使用Java代码拓展的不同的渠道。
    
- 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中,生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能(比如多态)的信息.
    
- 同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象,作用是在Java代码中去获取类的信息以及存储静态字段的数据(JDK8及之后).
    

#### 2.连接阶段

![[Pasted image 20250715132042.png]]

![[Pasted image 20250715132050.png]]
![[Pasted image 20250715132100.png]]

#### 3.初始化阶段

![[Pasted image 20250715132110.png]]

![[Pasted image 20250715132116.png]]

以下几种方式不会导致类的初始化:

- 数组的创建不会导致数组中作为元素的类进行初始化
    

对于存在继承关系的类:

![[Pasted image 20250715132126.png]]

```Java
{                            //对于类中这样的代码块,他会在新建类的对象
    System.out.println("c"); //时先于构造函数执行,但是在类第一次初始化
}                            //的时候并不会执行
```

![[Pasted image 20250715132140.png]]

## 类加载器

类加载器会获取字节码并将其加载到内存中(类加载器也只负责加载过程中的这一部分),同时还可以让应用程序去获取类和接口字节码数据.

类加载器分为两类，一类是Java代码中实现的，他们都继承自ClassLoader这个抽象类,另一类是Java虚拟机底层源码实现的(这种类一般无法在java代码中获取,因为语言可能不同),他们的实现语言与虚拟机底层语言一致,作用是用于加载java的基础类(如String).

#### 1.启动类加载器(Bootstrap ClassLoader,底层加载器)

它负责加载java安装目录下的/jre/lib中的基础类文件,它也可以加载我们自己写的比较底层的jar包,只要在启动时加上虚拟机参数-Xbootclasspath/a:<jar包所在目录>/<jar包名>即可.

#### 2.扩展类加载器(ExtClassLoader,普通加载器)

用于拓展java中比较通用的类,默认加载java安装目录下的/jre/lib/ext中的类文件,如要加载自己的jar包,则要使用-Djava.ext.dirs="<jar包目录1>;<jar包目录2>"参数(使用此参数后默认的路径会被覆盖,需要在参数中再添加上)

#### 3.应用程序类加载器(AppClassLoader,普通加载器)

加载项目中自己编写的类和引用的依赖中的类

PS.应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。

## 类加载器的双亲委派机制

> 内容:当一个类加载器接受到加载类的任务时,会自底向上查找是否加载过,如果加载过则直接返回,否则将加载请求委派给自己的父类加载器,以此避免重复加载同一个类,如果所有类加载器都没有加载过这个类,则会由顶向下进行加载,即由顶级加载器在自己的加载路径中寻找这个类,如果有则进行加载,否则将加载请求委派给自己的下级加载器,直到加载成功,之后再有这个类的加载请求时就只会由底向上了.

双亲委派机制可以保证类加载的安全性,避免恶意代码替换JDK中的核心类库,还可以避免一个类被重复加载.

#### 打破双亲委派机制的方法

**1****.自定义类加载器****:**自定义类加载器并且重写loadclass方法，就可以将双亲委派机制的代码去除.

ClassLoader中的核心方法有四个

- loadClass(String):类加载的入口，提供了双亲委派机制。内部会调用findClass.
    
- findClass(String):由类加载器子类实现,获取二进制数据调用defineClass.
    
- defineClass(String,byte[],int,int):做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中.
    
- `resolveClass(Class<?>)`:执行类生命周期中的连接阶段.
    

![[Pasted image 20250715132203.png]]

我们要自定义类加载器,就要继承ClassLoader这个接口,主要重写里边的LoadClass方法,要实现通过类的全限定名来找到对应字节码文件的逻辑,然后将获取到的byte[]传入defineClass方法中直接返回即可,其中对于自定义目录下没有java自己的基础类如Object但所有类又都继承自它,可以在自定义加载器中对java开头的类的加载请求交给父类加载(自定义加载器的默认父类都是AppClassLoader,如要特别指定需要通过构造方法自行传入).

2.**线程上下文类加载器(?实际上并没有打破双亲委派机制)**:利用上下文类加载器加载类，比如JDBC和JNDI等都使用了这种方法.

在一个线程启动后他的.currentThread()中便会存储一个默认应用程序加载器,调用.getContextClassLoader()即可得到,也可以调用.setContextClassLoader()来自定义上下文类加载器.

![[Pasted image 20250715132211.png]]

**3.Osgi框架的类加载器(过时)**:0sgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载.

## JDK9之后的类加载器

因为从JDK9开始引入了模块的概念,类加载器也发生了变化

1. 扩展类加载器和应用程序类加载器的源码从存放在rt.jar的类中变为JDK目录下的jmods文件夹下的.jmod文件中.
    
2. 启动类加载器不再是由C++编写的Bootstrap,而是使用java编写的BootClassLoader,实现了从模块中找到要加载的字节码资源文件的功能,但是虽然是用java编写但是仍无法在类中获取.
    
3. 扩展类加载器也改为了平台类加载器,但是由于模块化的概念和拓展类的目的其实是一致的,所以并没有新增逻辑,其存在目的只是为了兼容老版本.
    
4. 启动类加载器,平台类加载器和应用程序类加载器都改为继承自BuiltinClassLoader
    

## 运行时数据区(即JVM管理的内存)的组成

运行时数据区是有一定规范的,其组成部分可以分为两类,一类是线程不共享的,有程序计数器,java虚拟机栈和本地方法栈,另一类则是线程共享的,有方法区和堆.

#### 1.程序计数器

程序计数器(Program Counter Register)也叫PC寄存器，每个线程会通过程序计数器记录当前执行字节码下一条(不一定是下一行,因为存在分支,跳转等逻辑)的字节码指令的地址,当执行完当前指令后再由虚拟机根据程序计数器执行下一指令,其应用有线程之间切换时记录当前线程执行到哪里,以及控制解释器执行指令的顺序.

> 对于字节码指令的地址,是由虚拟机在加载阶段根据每条字节码指令前边的偏移量(字节码指令前边的数字不是行数而是偏移量)转换而来的,因此每一条字节码指令都有自己的内存地址

#### 2.java虚拟机栈

Java虚拟机栈(Java Virtual Machine stack)采用栈的数据结构来管理方法调用中的基本数据，先进后出(First In Last 0ut),每一个方法的调用使用一个栈帧(Stack Frame)来保存。

当执行一个方法时,就会将这个方法以栈帧的方式压入虚拟机栈中,方法返回时再弹出,如果上一个方法内再次调用了其他方法,则会依次向上叠加存放,返回弹出时也遵循先进后出的顺序,如果其中某个方法抛出了错误,则会打印错误信息后,将下边的栈帧依次弹出,其实控制台报错的at就是弹出的方法名.

Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行,Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出,Java虚拟机栈内存溢出时会出现StackOverflowError的错误.

要修改Java虚拟机栈的大小，可以使用虚拟机参数-Xss语法:

-Xss<栈大小>,单位:字节(默认，必须是 1024的倍数)、k或者K(KB)、m或者M(MB)、g或者G(GB).

Windows(64位)下的IDK8测试最小值为180k，最大值为1024m.

**栈帧的组成:**

1. 局部变量表:局部变量表的作用是在运行过程中存放所有的局部变量,如果当前方法不是静态类,第一个元素则会是调用该方法的对象引用,栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot)，long和double类型占用两个槽，其他类型占用一个槽,为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。
    
2. 操作数栈:操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域,他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值,在编译期就可以确定操作数栈的最大深度(即操作数栈中最多同时存在的数据个数)，从而在执行时正确的分配内存大小。
    
3. 帧数据(不同虚拟机可能有差异):帧数据主要包含动态链接、方法出口、异常表的引用
    

#### 3.本地方法栈

本地方法栈存储的是native本地方法的栈帧。在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。

#### 4.堆

一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用,但此时该对象只能由当前线程访问到,静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

堆空间有三个需要关注的值，used total max。used指的是当前已使用的堆内存，total是iava虚拟机已经分配的可用堆内存，max是iava虚拟机可以分配的最大堆内存,即total满了之后能拓展到的极限大小,但是total并不能扩展到max的大小,在这之前就会出现堆内存溢出.

如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64.要修改堆的大小，可以使用虚拟机参数-Xmx(max最大值)和-Xms(初始的total).

语法:-Xmx值 -Xms值

单位:字节(默认，必须是1024 的倍数)、k或者K(KB)、m或者M(MB)、g或者G(GB)

限制:Xmx必须大于2MB，Xms必须大于1MB

> Java服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩堆收缩的情况

#### 5.  方法区
    

方法区是存放基础信息的位置，线程共享，主要包含三部分内容:

1. 类的元信息: 保存了所有类的基本信息(即类的InstanceKlass(Class类似Klass的镜像对象),在类的加载阶段存储在方法区中,其中的常量池和方法会单独存储,Klass中只保存引用)
    

![[Pasted image 20250715132336.png]]

2. 运行时常量池: 保存了字节码文件中的常量池内容(程序运行时会把常量池中的内容读取到内存中,本来在字节码中需要通过符号引用的常量此时就可以使用内存地址引用,效率更高)
    

> JDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermsize=值来控制。
> 
> JDK8将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用-xX:MaxMetaspacesize=值将元空间最大大小进行限制。

3. 字符串常量池： 保存了字符串常量
    

> String有一个方法可以把该字符串存放在字符串常量池中,在较老的版本中该方法会直接把字符串放进字符串常量池,而之后的版本只会把字符串的引用放进字符串常量池

```Java
public class Test {
    public static void main(String[] args) {
        String s1 = new String("abc");
        String s2 ="abc";
        System.outprintln(s1 == s2);
    }
}
```

比如这个类,在编译为字节码时就会把"abc"放入静态常量池中,而在字节码文件加载到内存中后就会自动把"abc"加载到字符串常量池中,其中s1的引用是指向堆内存的,而s2的引用直接指向字符串常量池中的地址

![[Pasted image 20250715132348.png]]

对于常量字符串的引用(Stirng s1 = "a")的直接+拼接,底层还是调用了stringBuilder的append方法,所以这样得出的字符串会存储在堆内存中,而直接用常量进行+拼接就会存放在字符串常量池中

> 对于静态变量,jkd6及之前的版本是存放在Klass中的,而jdk7及之后就存放在Class对象中了

#### 6. 直接内存
    

直接内存(Direct Memory)并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。(但是不存在直接引用时也会被GC)

在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:

1. Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。
    
2. IO操作比如读文件，需要先把文件读入直接内存(缓冲区)再把数据复制到Java堆中。现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。
    

> ByteBuffer有一个方法.allocateDirect(size)可以在直接内存上创建数据,但是这样创建的内存和之前运行时常量池在arthas中名字不一样,这样申请出来的叫direct

如果需要手动调整直接内存的大小，可以使用-XX:MaxDirectMemorySize=大小。默认不设置该参数情况下，JVM 自动选择最大分配的大小。

## GC

GC不会管理线程不共享的区域(即程序计数器,Java虚拟机栈和本地方法栈),线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。

#### 方法区的回收(不常用)

方法区中能回收的内容主要就是不再使用的类。

判定一个类可以被卸载。需要同时满足下面三个条件:

1. 此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象
    
2. 加载该类的类加载器已经被回收。
    
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用。
    

因为我们的类都是由应用程序加载器加载的,这个加载器是系统的加载器,不会被回收,所以我们写的类不会被这样回收

> -XX:+TraceClassLoading :打印类的加载
> 
> -XX:+TraceClassUnloading :打印类的卸载日志

System.gc()可以手动触发GC,但是并不一定会立刻回收垃圾,仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。

#### 堆的回收

#### 判断是否回收的方法

1. 引用计数法(JVM没有使用)
    

引用计数法会为每个对象维护一个引用计数器,当对象被引用时加1，取消引用时减1。

优点: 实现简单

缺点:

1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题

> 如果想要查看垃圾回收的信息，可以使用-verbose:gc参数。
> 
> 语法:-verbose:gc

![[Pasted image 20250715132417.png]]

2. 可达性分析算法
    

Java使用的是可达性分析算法来判断对象是否可以被回收。

可达性算法中描述的对象引用，一般指的是强用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在普通对象就不会被回收

可达性分析将对象分为两类:垃圾回收的根对象(GC Root,一般不会被回收,而且JVM会维护一个存有所有跟对象的列表)和普通对象，对象与对象之间存在引用关系。

下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可被回收。

![[Pasted image 20250715132424.png]]

以下这些对象被称之为GC Root对象

- 线程Thread对象,引用线程栈帧中的方法参数、局部变量等
    
- 系统类加载器加载的java.lang.Class对象
    
- 监视器对象，用来保存同步锁synchronized关键字持有的对象
    
- 本地方法调用时使用的全局对象
    

#### 软引用

软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。

软引用的执行过程如下

1. 将对象使用软引用包装起来，new SoftReference<对象类型>(对象)
    
2. 内存不足时，虚拟机尝试进行垃圾回收。
    
3. 如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。
    
4. 如果依然内存不足，抛出OutOfMemory异常
    

```Java
//将100m的数据放入软引用中 
byte[] bytes = new byte[1024 * 1024 * 100];
SoftReference<byte[]> softReference = new SoftReference<byte[l]>(bytes);
```

内存不足时回收的只是软引用的内容,但是软引用本身并没有被回收, 此时的软引用已经没有用了,但是只是把对应的变量设为null不够优雅,所以SoftReference提供了一套队列机制:

1、软引用创建时，通过构造器传入引用队列

2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列

3、通过代码遍历引用队列，将SoftReference的强引用删除

![[Pasted image 20250715132434.png]]

#### 弱引用

弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。

在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。

弱引用对象本身也可以使用引用队列进行回收。

> 之后这两种引用在常规开发中是不会使用的

#### 虚引用

虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。

ByteBuffer在申请直接内存时,会先在堆中新建对应的对象,再在对象的构造方法中去申请直接内存,所以即使将对象的强引用删除,也不会释放对应的直接内存,所以在申请完直接内存后,会有一个单独的线程去监听这个bytebuffer对象,其中有一个Cleaner属性就继承了虚引用,在这个bytebuffer对象被回收后就会收到消息,从而对直接内存进行回收

#### 终结器引用

终结器引用指的是在对象需要被回收时，对象将会被放置在Finalizer类中的引用队列中，并在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法(这个方法是Object中的,并且这个方法会在GC的时候自动调用一次并且只能被调用一次,所以对于在这个方法中再次使用强引用让自身不被回收的对象,第二次被gc的时候就不会调用这个finalize方法了)。但是这样并不会导致内存被回收,因为内存回收主要还是由GC控制的,只有在对象第二次被GC回收时才会被真正回收.在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。

#### 垃圾回收算法

Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。所以需要选择合适的垃圾回收算法

判断GC算法是否优秀，可以从三个方面来考虑:

1. 吞吐量
    

吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量=执行用户代码时间/

(执行用户代码时间 +GC时间)。吞吐量数值越高，垃圾回收的效率就越高。

2. 最大暂停时间
    

最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值

3. 堆使用效率
    

不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。

上述三种评价标准:堆使用效率、吞吐量，以及最大暂停时间不可兼得。一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量,不同的垃圾回收算法，适用于不同的场景

#### 标记-清除算法(Mark Sweep GC)

标记清除算法的核心思想分为两个阶段:

1. 标记阶段，将所有存活的对象进行标记。java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
    
2. 清除阶段，从内存中删除没有被标记也就是非存活对象。
    

优点:实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。

缺点:

1. 碎片化问题
    

由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是

个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。

2. 分配速度慢。由于内存碎片的存在，JVM需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。
    

#### 复制算法(copy GC)

复制算法的核心思想是:

1. 准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间(From空间)
    
2. 在垃圾回收GC阶段，将From中存活对象(优先把root转移到to空间,接着把与root存在引用链的对象复制到to,之后就会把From空间全删了)复制到To空间。
    
3. 将两块空间的From和To名字互换。
    

优点:

1. 吞吐量高
    

复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动

2. 不会发生碎片化
    

复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

缺点:

内存使用效率低

每次只能让一半的内存空间来为创建对象使用

#### 标记-整理算法

标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。

核心思想分为两个阶段:

1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出

所有存活对象。

2.整理阶段，将存活对象移动到堆的一端。清理掉非存活对象的内存空间。

优点:

1. 内存使用效率高
    

整个堆内存都可以使用，不会像复制算法只能使用半个堆内存

2. 不会发生碎片化
    

在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

缺点:

整理阶段的效率不高

整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGc等高效的整理算法优化此阶段的性能

#### 分代垃圾回收算法

分代垃圾回收将整个内存区域划分为新生代(年轻代)和老年代,新生代用于存放存活时间比较短的对象,老年区用于存放存活时间较长的对象,其中新生代又有Eden区和s0(From),s1(to)幸存区(默认分别占新生代的8:1:1),Eden用于存放新创建的对象

![[Pasted image 20250715132449.png]]

分代回收时，创建出来的对象，首先会被放入Eden伊甸园区,随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC.Minor GC会把eden中和From中需要回收的对象回收，把没有回收的对象放入To区(复制算法)。接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor Gc。此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0.

注意:每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。如果Minor GC后对象的年龄达到阈值(最大15，默认值和垃圾回收器有关)，对象就会被晋升至老年代(或者说新生区已经完全占满minor GC后也不够就会存放到老年代),当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Ful GC，Ful GC会对整个堆进行垃圾回收。

堆分为年轻代和老年代的原因

1. 可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。
    
2. 新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记,整理算法，由程序员来选择灵活度较高。
    
3. 分代的设计中允许只回收新生代(minor gc)，如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。
    

#### 垃圾回收器

垃圾回收器是垃圾回收算法的具体实现。

由于垃圾回收器分为年轻代和老年代，除了G1(jdk9后推荐使用)之外其他垃圾回收器必须成对组合进行使用。

具体的关系图如下,实线连接的是可以搭配使用的:

![[Pasted image 20250715132458.png]]

  

#### Serial + SerialOld

![[Pasted image 20250715132505.png]]

![[Pasted image 20250715132511.png]]

#### ParNew + CMS

![[Pasted image 20250715132517.png]]

![[Pasted image 20250715132523.png]]

CMS执行步骤:

1. 初始标记,用极短的时间标记出GC Roots能直接关联到的对象。
    
2. 并发标记，标记所有的对象，用户线程不需要暂停
    
3. 重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。
    
4. 并发清理，清理死亡的对象，用户线程不需要暂停。
    

缺点:

1. CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在FuIGC时进行碎片的整理,这样会导致用户线程暂停，可以使用-xX:CMSFullGCsBeforeCompaction=N参数(默认0)调整N次FuGC之后再整理。
    
2. 无法处理在并发清理过程中产生的“浮动坛圾”，不能做到完全的垃圾回收。
    
3. 如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代
    

#### Parallel Scavenge + Parallel Old

![[Pasted image 20250715132535.png]]

![[Pasted image 20250715132543.png]]

#### G1(Garbage First)

![[Pasted image 20250715132549.png]]

JDK9之后默认的垃圾回收器是G1垃圾回收器。

Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小，

CMS关注暂停时间，但是吞吐量方面会下降。

而G1设计目标就是将上述两种垃圾回收器的优点融合:

1. 支持巨大的堆空间回收，并有较高的吞吐量。
    
2. 支持多CPU并行垃圾回收
    
3. 允许用户设置最大暂停时间。
    

G1出现之前的垃圾回收器，内存结构一般是连续的,而G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、Old区。Region的大小通过堆空间大小2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其中32m指定region大小为32M)，Region size必须是2的指数幕，取值范围从1M到32M。

![[Pasted image 20250715132612.png]]

G1垃圾回收有两种方式:

1. 年轻代回收(Young GC)，回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数-XX:MaxGCPauseMilis=n(默认200)设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。
    

**过程:**

1、新创建的对象会存放在Eden区。当G1判断年轻代区不足(max默认60%)，无法分配对象时需要回收时会执行Young GC.

2.标记出Eden和Survivor区域中的存活对象

3.根据配置的最大暂停时间选择某些区域(其他回收器一般是全部的eden,这也是G1与别的垃圾回收器最大的不同)将存活对象复制到一个新的Survivor区中(年龄+1)，清空这些区域

> G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。比如 -XX:MaxGCPauseMiis=n(默认200)，每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。

![[Pasted image 20250715132628.png]]
![[Pasted image 20250715132633.png]]

4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。

5、当某个存活对象的年龄到达阈值(默认15)，将被放入老年代,

![[Pasted image 20250715132700.png]]
![[Pasted image 20250715132704.png]]
![[Pasted image 20250715132708.png]]
6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代(与正常的老年代不同)被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。

![[Pasted image 20250715132717.png]]

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时(-XX:InitiatingHeapOccupancyPercent默认45%)会触发混合回收MixedGc。回收所有年轻代和部分(防止STW过大)老年代的对象以及大对象区。采用复制算法来完成。

2. 混合回收(Mixed GC)
    

混合回收分为:初始标记(initial mark)、并发标记(concurrent mark)、最终标记(remark或者Finalize Marking)、并发清理(cleanup)

**混合回收的步骤:**

1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象

2、并发标记，并发执行，对存活对象进行标记,

3、最终标记，STW，处理SATB相关的对象标记

4、清理，STW，如果区域中没有任何存活对象就直接清理，

5、转移，将存活对象复制到别的区域。

![[Pasted image 20250715132724.png]]

![[Pasted image 20250715132732.png]]

G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1(Garbage first)名称的由来。最后清理阶段使用复制算法，不会产生内存碎片

如果清理过程中发现没有足够的空Region存放转移的对象，会出现FulGC。单线程执行标记-整理算法此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。