## 栈上的数据存储

Java8的基本数据类型所占的字节数实际上指的都是堆上或者数组中内存分配的空间大小，栈上的实现更加复杂

![[Pasted image 20250715132751.png]]

对于局部变量表,其中每个元素空间大小在32位虚拟机上为4个字节,64位虚拟机上为8个字节,但是对于8字节的long和double不论在什么虚拟机上都会直接占用两个数组元素的位置(即占有两个槽),所以在64位虚拟机上就会存在8字节的浪费,这是为了实现字节码的跨平台性,使其在任意操作系统上都可以运行所做的让步,类似的其他的类型也会存在内存的浪费

与此同时,在从局部变量表取到操作数栈中时,该变量所占的大小与局部变量表中的也是相同的

#### boolean在栈上的存储方式

由于boolean在栈上只占一个槽,所以为了操作方便会直接将其等效于int,所以编译出的字节码会是把一个常量一(true)或零(false)赋值到对应的变量表位置上(byte等同理,float会有自己的操作)

#### 栈上和堆上的数据的转化

1、堆中的数据加载到栈上，由于栈上的空间大于或者等于堆上的空间，所以直接处理但是需要注意下符号位。如boolean、char为无符号，低位复制，高位补0

2、栈中的数据要保存到堆上，byte、char、short由于堆上存储空间较小，需要将高位去掉。boolean比较特殊，只取低位的最后一位保存。

## 堆上的数据存储

![[Pasted image 20250715132757.png]]

#### 标记字段

![[Pasted image 20250715132804.png]]

调用Hash方法后就会把哈希值存入标记字段中的HashCode,之后就不用重复计算了

![[Pasted image 20250715132810.png]]

![[Pasted image 20250715132816.png]]

这三行就是对象头,这个方法的显示是从后往前的,所以一开始的00000001是那四块内容,后边的4个八位(舍去第四个八位的第一个位,因为hash只有31位)才是hashCode值,并且这四个八位要从后往前读(上边的一行输出就是二进制的哈希码),

![[Pasted image 20250715132825.png]]

#### 元数据的指针

元数据的指针指向的就是方法区中的InstanceKlass对象

![[Pasted image 20250715132831.png]]
因为八个字节可以代指的空间太大了,一般不需要那么大
![[Pasted image 20250715132850.png]]

![[Pasted image 20250715132901.png]]

![[Pasted image 20250715132906.png]]

> 使用指针压缩时会使用四个字节存储这种空间的最大个数(即2^32个,所以是2^3*2^32个字节)

#### 内存对齐

![[Pasted image 20250715132912.png]]

Cpu中存在缓存行(占用8字节)用于加快操作速度(操作类似缓存,读取数据时会先从缓存行读取,没有再去内存读),修改时先修改缓存的数据,再写回内存中,同时令其他包含这个被修改的数据缓存的缓存行都删掉,但是这样也会影响该缓存行上其他数据的读取

![[Pasted image 20250715132918.png]]

#### 字段重排列

![[Pasted image 20250715132923.png]]

> 在JVM中,对象类型的属性必须在基础类型之后,所以会有一些在属性之间的间隔

![[Pasted image 20250715132929.png]]

总之内存对齐和字段重排列实现了两个对缓存行的优化

1. 对象的总字节数要能被8整除
    
2. 每个字段的偏移量必须能被当前字段类型的长度整除
    

> 对于存在继承关系的对象,子类对象中父类对象的属性的偏移量是和父类对象本身一模一样的,之后再放自己的属性(即使是对象也会排在子类属性的前边)

## 方法调用的原理

方法调用的本质是通过字节码指令的执行，能在栈上创建栈帧，并执行调用方法中的字节码执行。

![[Pasted image 20250715132940.png]]

这些方法的核心作用就是找到字节码指令并执行,而这些字节码都是存储在方法区的InstanceKlass中的,但是方法区中有很多Klass对象,所以还需要一种方法去找到对应的Klass中的方法,常见的有两种

#### 静态绑定

1、编译期间，

invoke指令会携带一个参数符号引用，引用到常量池中的方法定义。方法定义中包含了类名+方法名+返回值+参数。

2、在方法第一次调用时，这些符号引用就会被替换成内存地址的直接引用，这种方式称之为静态绑定

```Java
private long test2(int a){
    System.out.println("invoke private method...");
    return 1L;
}
```

![[Pasted image 20250715132948.png]]

在名字和描述符中,括号内的为参数类型,括号后的为返回值类型(都是字节码中的符号表示)

静态绑定适用于处理静态方法、私有方法、或者使用final修饰的方法，因为这些方法不能被继承之后重写。

#### 动态绑定

在代码中出现向上造型时,使用父类引用调用子类方法在字节码中实际上会编译为直接调用父类引用的方法,这就需要动态绑定去找到子类的方法了

动态绑定是基于方法表来完成的，invokevirtual使用了虚方法表(vtable)，invokeinterface使用了接口方法表(itable)，整体思路类似。每个类中都有一个虚方法表，本质上它是一个数组，记录了方法的地址。子类方法表中包含父类方法表中的所有方法,子类如果重写了父类方法，则使用自己类中方法的地址进行替换。

![[Pasted image 20250715132954.png]]

产生invokevirtual调用时，先根据对象头中的类型指针找到方法区中(动态类型的)InstanceKlass对象，获得虚方法表。再根据虚方法表找到对应的对方，获得方法的地址，最后调用方法。

## 异常捕获的原理

异常捕获机制的实现，需要借助于编译时生成的异常表

异常表在编译期生成，存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。

#### 过程

程序运行中触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目(寻找对应的错误类型)。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。

1. 如果匹配，跳转到“跳转PC”对应的字节码位置。
    
2. 如果遍历完都不能匹配，说明异常无法在当前方法执行时被捕获，此方法栈帧直接弹出，在上一层的栈帧中进行异常捕获的查询(throw)。
    

代码抛出异常后,这个异常会先进入操作数栈中,然后异常表维护的跳转地址就会把这个异常从操作数栈中放到局部变量表中,所以我们可以从catch块中拿到Exception对象

#### finally的处理

1、finally中的字节码指令会插入到try和 catch代码块后(相当于在两块代码中都添加一次finally中的代码),保证在try和catch执行之后一定会执行finally中的代码。

2、如果抛出的异常范围超过了Exception，比如Error或者Throwable，此时也要执行finally，所以异常表中增加了两个条目(一条覆盖try的内容另一条覆盖catch的内容)。覆盖了try和catch两段字节码指令的范围，any代表可以捕获所有种类的异常

finally也会把异常取到局部变量表中,但是处理完之后会放回操作栈中继续向上抛出

## JIT即时编译

在Java中，JIT即时编译器是一项用来提升应用程序代码执行效率的技术。

字节码指令被 Java 虚拟机解释执行，如果有一些指令执行频率高，称之为热点代码，这些字节码指令则被JIT即时编译器编译成机器码同时进行一些优化最后保存在内存中，将来执行时直接读取就可以运行在计算机硬件上了

![[Pasted image 20250715133006.png]]

> 如果优化后的机器码还不如原先解释器直接执行的话(极少数情况),JIT还会把内存中的机械码删除.继续使用解释器执行

C1即时编译器和C2即时编译器都有独立的线程去进行处理，内部会保存一个队列，队列中存放需要编译的任务,一般即时编译器是针对方法级别来进行优化的，当然也有对循环进行优化的设计

![[Pasted image 20250715133012.png]]

![[Pasted image 20250715133019.png]]

#### 优化手段

JIT编译器主要优化手段是方法内联和逃逸分析

1. 方法内联(Method Inline):
    

方法体中的字节码指令直接复制到调用方的字节码指令中，节省了创建栈帧的开销,其中C2甚至还会更改程序的运行逻辑,优化逻辑(如把累加变为乘法).

并不是所有的方法都可以内联，内联有一定的限制:

1、方法编译之后的字节码指令总大小<35字节，可以直接内联。(通过-XX:MaxInlineSize=值 控制)

2、方法编译之后的字节码指令总大小<325字节，并且是一个热方法。(通过-XX:FreqlnlineSize=值 控制)

3.方法编译生成的机器码不能大于1000字节。(通过-XX:InlineSmallCode=值 控制)

4.一个接口的实现必须小于3个，如果大于三个就不会发生内联。

2. 逃逸分析
    

逃逸分析指的是如果JIT发现在方法内创建的对象不会被外部引用(如果这个内部变量作为了外部静态方法的参数,那么也不会进行优化)，那么就可以采用锁消除、标量替换等方式进行优化。
未发生逃逸:
![[Pasted image 20250715133042.png]]
发生逃逸:
![[Pasted image 20250715133056.png]]

1.锁消除: 锁消除指的是如果对象被判断不会逃逸出去，那么在对象就不存在并发访问问题，对象上的锁处理都不会执行从而提高性能。(不常见,因为加锁的方法一般都会被多线程访问,这样是不会被优化的)

2.标量替换

逃逸分析真正对性能优化比较大的方式是标量替换，在Java虚拟机中，对象中的基本数据类型称为标量，引用的其他对象称为聚合量。标量替换指的是如果方法中的对象不会逃逸，那么其中的标量就可以直接在栈上分配。

![[Pasted image 20250715133116.png]]

根据JIT即时编器优化代码的特性，在编写代码注意以下几个事项，可以让代码执行时拥有更好的性能

1、尽量编写比较小的方法，让方法内联可以生效

2、高频使用的代码，特别是第三方依赖库甚至是JDK中的，如果内容过度复杂是无法内联的，可以自行实现一个特定的优化版本，

3、注意下接口的实现数量，尽量不要超过2个,否则会影响内联的处理

4、高频调用的方法中创建对象临时使用，尽量不要让对象逃逸。

## GC原理

#### G1

1. 年轻代回收
    

核心技术:

1、卡表 Card Table

每一个Region都拥有一个自己的卡表，卡表是一个字节数组,整个堆会被每512字节分为一个卡页,每个卡表里有所有的卡页的标记,如果产生了跨代引用(老年代引用年轻代)，G1会将卡表上引用对象所在的位置字节内容进行修改为0，称为脏卡。卡表的主要作用是生成记忆集。

> 卡表会占用一定的内存空间，堆大小是1G时，卡表大小为1G=1024 MB/512=2MB

2、记忆集 Rememberedset(简称RS或RSet)

每一个Region都拥有一个自己的记忆集，如果产生了跨代引用，记忆集中会记录引用对象所在的卡表位置(在卡表中的下标,也会标记这张卡表在那个块中,块1->12,14就代表在块1(一个老年代)中有两个卡页中的内容引用了当前卡表所在的块的对象)。标记阶段将记忆集中的对象加入GC ROOT集合中一起扫描，就可以将被引用的对象标记为存活。

3、写屏障 Write Barrier

G1使用写屏障技术，在执行引用关系建立的代码执行后插入一段指令，完成卡表的维护工作。会损失一部分的性能，大约在5%~10%之间。

记忆集的生成流程:

![[Pasted image 20250715133128.png]]

年轻代回收的详细过程(整个过程都是STW):

1、Root扫描，将所有的静态变量、局部变量扫描出来

2、处理脏卡队列中的没有处理完的信息(此时GC线程会协助Refinement线程一起消费)，更新记忆集的数据，此阶段完成后，记忆集中包含了所有老年代对当前Region的引用关系。

3.标记存活对象。记忆集中的对象会加入到GC Root对象集合中，在GC Root引用链上的对象也会被标记为存活对象

4、根据设定的最大停顿时间，选择本次收集的区域，称之为回收集合Collection Set。

5、复制对象:将标记出来的对象复制到新的区中，将年龄加1，如果年龄到达15则晋升到老年代。老的区域内存直接清空。

6、处理软、弱、虚、终结器引用(通知对应的队列)，以及JNI中的弱引用。

2. 混合回收
    

1.初始标记

初始标记会暂停所有用户线程，只标记从GC root可直达的对象，所以停顿时间不会太长。采用三色标记法进行标记,三色标记法在原有双色标记(黑也就是1代表存活，白0代表可回收)增加了一种灰色，采用队列的方式保存标记为灰色的对象。

黑色:当前对象在GC Root引用链上，同时他引用的其他对象也都已经标记完成。

灰色:当前对象在GC Root引用链上，他引用的其他对象还未标记完成。

白色:不在GC Root引用链上。

所以这个阶段没有被直接引用的对象也会暂时为白色

三色标记中的黑色和白色是使用位图(bitmap)来实现的,比如8个字节使用1个bit来标识标记的内容，黑色为1，白色为0，灰色不会体现在位图中，会单独放入一个队列中。如果对象超过8个字节，仅仅使用第一个bit位处理(对象的大小因为内存对齐都是8的倍数)。

![[Pasted image 20250715133136.png]]

其中占16个字节大小的对象就只有第一个bit标记了

2.并发标记

接下来进入并发标记阶段，继续进行未完成的标记任务。此阶段和用户线程并发执行。

从灰色队列中获取尚未完成标记的对象B。标记B关联的A和C对象，由于A对象并未引用其他对象，可以直接标记成黑色,而B也完成了所有引用对象的标记，也标记为黑色。C对象有引用对象E，所以先标记成灰色。

> 三色标记存在一个比较严重的问题，由于用户线程可能同时在修改对象的引用关系，就会出现错标的情况，比如:这个案例中正常情况下，B和C都会被标记成黑色。但是在BC标记前，用户线程执行了B.c= null;将B到c的引用去除了。同时执行了A.c=c;添加了A到C的引用。此时会出现错标的情况，C是白色可回收。
> 
>![[Pasted image 20250715133148.png]]

![[Pasted image 20250715133154.png]]

3.最终标记

最终标记会暂停所有用户线程，主要是为了处理SATB相关的对象标记。这一步中，将所有线程的SATB队列中剩余的数据合并到总的SATB队列中，然后逐一处理。SATB队列中的对象，默认按照存活处理，同时要处理他们引用的对象。

> SATB的缺点是在本轮清理时可能会将不存活的对象标记成存活对象，产生了一些所谓的浮动垃圾，等到下一轮清理时才能回收。

4.转移的步骤如下:

1、根据最终标记的结果，可以计算出每一个区域的垃圾对象占用内存大小，根据停顿时间，选择转移效率最高(垃圾对象最多)的几个区域。

2、转移时先转移GC Root直接引用的对象，然后再转移其他对象。

3.回收老的区域，如果外部有其他区域对象引用了转移对象，也需要重新设置引用关系。