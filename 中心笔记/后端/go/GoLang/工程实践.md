## 项目结构

#### 路由划分

1. GET: 取出资源(一项或多项)
    
2. POST: 新建一个资源
    
3. PUT: 更新资源(客户端提供完整资源数据)
    
4. PATCH: 更新资源(客户端提供需要修改的资源数据)
    
5. DELETE: 删除资源。
    

  

#### yaml使用

创建config包,包下创建config.go和config.yaml来使用配置文件

.yaml中就和平时一样写配置信息,.go中要仿照.yaml中写一个结构体

.yaml

```YAML
app:
  name: CurrencyExchangeApp
  port: :3000

database:
  host: localhost
  port: :3306
  user: your_username
  password: your_password
  name: currency_exchange_db
```

.go

```Go
type Config struct {
    App struct {
        Name string
        Port string
    }
    Database struct {
        Host     string
        Port     string
        User     string
        Password string
        Name     string
    }
}
```

之后要安装viper来读取配置文件

`go get` `github.com/spf13/viper`

之后再在config.go文件中声明一个Config指针的公有变量,再写一个构造函数InitConfig(),其写法如下

```Go
func InitConfig() {
    viper.SetConfigName("config") //设置配置文件的名称(不用带后缀)
    viper.SetConfigType("yml") //设置文件后缀
    viper.AddConfigPath("./config") //设置文件路径

    if err := viper.ReadInConfig(); err !=nil{
       log.Fatalf("Error reading config file: %v", err)
    }

    AppConfig = &Config{} //解决Config未被使用,并使变量指向一个实例

    if err:= viper.Unmarshal(AppConfig); err !=nil{ //将配置文件中的属性映射到结构体实例中
       log.Fatalf("Unable to decode into struct: %v", err)
    }
}
```

这样之后在main中调用config.InitConfig后就可以直接调用其中的Config对象来获取配置信息了

#### gin

gin的路由不应该全部放在main中,我们可以新建一个Router包,其中有Router.go,写一个方法来对应路由和路由组,然后返回Engine在main中启动

```Go
func SetupRouter() *gin.Engine {
    router := gin.Default()

    auth := router.Group("/api/auth")
    {
       auth.POST("login", func(context *gin.Context) {
          context.AbortWithStatusJSON(http.StatusOK, gin.H{
             "msg": "Login Success",
          })
       })
       auth.POST("register", func(context *gin.Context) {
          context.AbortWithStatusJSON(http.StatusOK, gin.H{
             "msg": "Register Success",
          })
       })
    }
    return router
}
```

#### Gorm

在Config中新建db.go来初始化数据库会话

```Go
func initDB() {
    db, err := gorm.Open(mysql.Open(AppConfig.Database.dsn), &gorm.Config{})
    if err != nil {
       log.Fatalf("Failed to initialize database, got error: %v", err)
    }

    sqlDB, err := db.DB()

    sqlDB.SetMaxIdleConns(AppConfig.Database.MaxIdleCons)
    sqlDB.SetMaxOpenConns(AppConfig.Database.MaxOpenCons)
    sqlDB.SetConnMaxLifetime(time.Hour)

    if err != nil {
       log.Fatalf("Failed to configure database, got error: %v", err)
    }
}
```

对于这样的类似的函数需要在config中的init调用一下使其生效

#### 实体类

实体类应该写在models文件夹下,起名即为数据库名,每个实体类应该继承Model

```Go
type Model struct {
    ID        uint `gorm:"primarykey"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt DeletedAt `gorm:"index"`
}
```

#### 全局变量

可以创建一个global文件夹,其中有global.go,可以在其中声明一些全局变量,在项目中就可以到处使用了

#### Controller

可以创建一个Controller包,在其中写各种的的Controller.go,其中就有各种处理逻辑方法(类似Service)

```Go
func Register(ctx *gin.Context) {
    var user models.User
    if err := ctx.ShouldBindJSON(&user); err != nil {
       ctx.JSON(http.StatusBadRequest, gin.H{
          "error": err.Error(),
       })
       return
    }
}
```

#### 工具类

utils包下可以写utils.go,里边可以写各种工具方法

**加密:**

加密算法可以使用Bcrypt Package

Bcrypt 是一种用于密码哈希的加密算法，它是基于 Blowfish 算法的加强版, 被广泛应用于存储密码和进行身份验证。

优势:安全性高：Bcrypt 采用了 `Salt` 和 `Cost` 两种机制, 可有效地防止彩虹表攻击和暴力破解攻击, 从而保证安全性。

```Plain
$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW
\__/\/ \____________________/\_____________________________/
Alg Cost      Salt                        Hash
```

使用:

go get -u golang.org/x/crypto/bcrypt

```Go
func HashPassword(pwd string) (string, error) {
    hash, err := bcrypt.GenerateFromPassword([]byte(pwd), 12)
    return string(hash), err
}
```

bcrypt中还有专门用于对比密码明文和密码密文的方法

```Go
func CheckPassword(password string, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

**JWT****:**

go中进行jwt可以使用

`go get` `github.com/golang-jwt/jwt/v5`

```Go
func GenerateJWT(username string)(string, error){
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ //指定加密方式和负载内容
       "username": username,
       "exp": time.Now().Add(time.Hour * 72).Unix(), //指定过期时间,这里的时间是从计算机元年过去了多久,需要用Unix转为时间戳
    })

    signedToken, err := token.SignedString([]byte("secret")) //指定秘钥
    return "Bearer " + signedToken, err //
}
```

#### 问题解决

项目启动显示缺少依赖可以执行go mod tidy来整理依赖

Json中参数名的大小写是不区分的

数据库查询的错误需要在最后调用.Error来获取,直接获取可能会出bug

errors.Is(err,<对应错误类型>)可以判断err是否为对应类型

#### 中间件

中间件可以放在middlewares包下,

#### CORS

CORS, 全称为"跨域(跨源)资源共享"(Cross-Origin Resource Sharing), 是一种机制, 使用额外的 HTTP 头来告诉浏览器允许一个网页从另一个域(不同于该网页所在的域)请求资源。这样可以在服务器和客户端之间进行安全的跨域通信。

浏览器将 CORS 请求分成两类:

- 简单请求(simple req)
    

方法如`GET`, `POST`

头部字段如: `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`(需要注意额外的限制)等

- 非简单请求(not-so-simple req)。
    

方法如`PUT`

在正式通信之前, 增加一次`HTTP`查询请求, 称为`预检(Preflight)`请求

该请求是`Option`方法的, 通过该请求来知道服务端是否允许跨域请求。

我们可以在 Code 内看到:

![[Pasted image 20250715131351.png]]

对于简单请求, 浏览器直接发出 CORS 请求。

  

Origin, 可译为源, 亦可译为域, 在 CORS 上下文中 Origin 由三个元素组成：

Origin 即为 `协议(如https)` + `域名(如``www.example.com``)` + `端口(如80)`

  

**同源策略(Same-Origin Policy, SOP)**

浏览器的一种安全机制, 用于防止恶意网站通过脚本对其他网站的内容进行访问。

以下 URL 属于同源地址：

如: `example.com:443` 和 `example.com:443/articles`

但`inkkaplum频道B站.``example.com/articles` 和 `example.com/articles`则不是。

自然, `example.com:80`和`example.com:443`则不是

  

**跨域请求**

指从一个域向另一个域发起的 HTTP 请求。

如从前端应用向不同的后端 API 服务器请求数据, 但是同源策略默认会阻止这些请求。

所以需要 CORS 机制来显式允许跨域访问。

本案例的 URL:

(前端)[http://localhost:5173](http://localhost:5173/) 和(后端)[http://localhost:3000](http://localhost:3000/)

浏览器默认允许同源请求, 但是默认会阻止这些跨域请求, 除非服务器明确允许。

要解决这个问题, 需在后端应用中配置 CORS, 允许前端应用[http://localhost:5173](http://localhost:5173/)访问后端 API。

  

使用 `Gin CORS middleware`, 可以很方便地在 Gin 中配置 CORS。

官方案例:

[https://github.com/gin-contrib/cors](https://github.com/gin-contrib/cors)

命令

```Bash
go get github.com/gin-contrib/cors
```

下边的配置应写在所有路由之前(比如router的最前边)

```Go
package main

import ("time""github.com/gin-contrib/cors""github.com/gin-gonic/gin")

func main() {
    router := gin.Default()// CORS for https://foo.com and https://github.com origins, allowing:// - PUT and PATCH methods// - Origin header// - Credentials share// - Preflight requests cached for 12 hours
    router.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"http://localhost:5173"}, //允许跨域的源
        AllowMethods:     []string{"GET", "POST","OPTIONS"}, //允许的请求方法
        AllowHeaders:     []string{"Origin"},                //非简单请求允许的头字段
        ExposeHeaders:    []string{"Content-Length"}, //那些响应头可以暴露
        AllowCredentials: true, //是否允许发送COOKIE等凭证信息
        AllowOriginFunc: func(origin string) bool { //自定义动态验证来源的方法(可以没有)
           return origin == "https://github.com"
        },
        MaxAge: 12 * time.Hour, //表示客户端发送一次预检请求后多长时间内可以不再发送
    }))
    router.Run()
}
```

#### 优雅的退出应用

```Go
// +build go1.8

package main

import (
 "context"
 "log"
 "net/http"
 "os"
 "os/signal"
 "time"

 "github.com/gin-gonic/gin"
)

func main() {
 router := gin.Default()
 router.GET("/", func(c *gin.Context) {
 time.Sleep(5 * time.Second)
 c.String(http.StatusOK, "Welcome Gin Server")
 })

 srv := &http.Server{ //创建一个服务器实例
 Addr:    ":8080", //运行端口
 Handler: router, //Engine对象的变量名
}

 go func() { //多线程
 if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed { //启动端口监听
 log.Fatalf("listen: %s\n", err)
}
}()

quit := make(chan os.Signal, 1) //声明Channel,用于接收信号
signal.Notify(quit, os.Interrupt) //将系统信号(如ctrl+c)输入Channel
<-quit //如果没有信号则一直阻塞,收到信号则继续执行下边的代码
log.Println("Shutdown Server ...")

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
if err := srv.Shutdown(ctx); err != nil {
log.Fatal("Server Shutdown:", err)
}
log.Println("Server exiting")
}
```

## 创建路由

```Go
package main
import(
    "context"
    
    "code.byted.org/middleware/hertz/pkg/app"
    "code.byted.org/middleware/hertz/pkg/app/server"
)
func main(){
    h := server.New() //注册server
    //绑定路由到server上,并编辑逻辑
    h.POST("/sis",func(c context.Context, ctx *app.RequestContext){
        ctx.Data(200,"text/plain;charset=utf-8",[]byte("OK")) //返回响应
    })
    
    h.spin()
}
```

## 分层

![[Pasted image 20250715131403.png]]

#### 应用层(Application)

提供合理的API(可理解性,简单性,冗余性,兼容性,可测性,可见性)

#### 中间件层

- 配合 Handler 实现一个完整的请求处理生命周期
    
- 拥有预处理逻辑与后处理逻辑
    
- 可以注册多中间件
    
- 对上层模块用户逻辑模块易用
    

![[Pasted image 20250715131410.png]]

**路由层:**

![[Pasted image 20250715131416.png]]

**协议层:**

抽象出合适的接口

**传输层:**