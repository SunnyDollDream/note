#### 哈希表的初始化

```Java
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
```

#### 函数式接口/Lambda表达式

它指的是有且只有一个未实现的方法的接口，一般通过**@FunctionalInterface**这个注解来表明某个接口是一个函数式接口。函数式接口是Java支持函数式编程的基础。

**使用:**

```Java
Consumer c = new Consumer() {
    @Override
    public void accept(Object o) {
        System.out.println(o);
    }
};
```

使用函数式编程实现方法:(类似于直接省略原来的下划线部分)

```Java
Consumer c = (o) -> {
    System.out.println(o);
};  
```

当函数体中只有一个语句时，可以去掉{}进一步简化:

```Java
Consumer c = (o) -> System.out.println(o);
//甚至感觉有点像js把函数直接当对象来用了,或者说把接口看做一个函数(只有当两个方法返回值类型和形参都一致时才能使用这种方法)
Consumer c = System.out::println;
//它表示的意思就是针对输入的参数将其调用System.out中的静态方法println进行打印。
```

如果只有一行语句且该语句为返回语句时,还可以这样写(对于这样的方法,去掉大括号的同时还必须去掉Return)

```Java
       MyInterface1 test1 = new MyInterface1() {
            @Override
            public int test(int a, int b) {
                return a - b;
            }
        };
        
        MyInterface1 test4 = (a, b) -> a - b;
```

#### Optional(JDK8新增功能,用于判空对象)

1.Java 8新增了一个类 - Optional

2.Optional是一个容器，用于放置可能为空的值，它可以合理而优雅的处理 null。

3.Optional的本质，就是内部储存了一个真实的值，在构造的时候，就直接判断其值是否为空

4.java.util.Optiona`l<T>`类本质上就是一个容器，该容器的数值可以是空代表一个值不存在，也可以是非空代表一个值存在。

5.Optional类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。

我们可以把Optional想象成一个盒子，而里面装的就是你需要判空的对象，这样你只需要判断盒子里是不是空的，就可以判断是不是空对象,而不需要判断盒子本身,因为盒子一直存在(盒子不可能为NULL).

Optional类常用方法：

- Optional.of(T t) : 创建一个 Optional 实例。(传入的值必须是非空值，否则如果传入的值为空值，则会抛出空指针异常。)
    
- Optional.empty() : 创建一个空的 Optional 实例。
    
- Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例。
    
- isPresent() : 判断是否包含值。
    
- orElse(T t) : 如果调用对象包含值，返回该值，否则返回t。
    
- orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值。
    
- map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()。
    
- flatMap(Function mapper):与 map 类似，要求返回值必须是Optional。
    

> public String getStreetName( Province province ) {
> 
> return Optional.ofNullable( province )
> 
> .map( i -> i.getCity() )
> 
> .map( i -> i.getDistrict() )
> 
> .map( i -> i.getStreet() )
> 
> .map( i -> i.getName() )
> 
> .orElse( "未找到该道路名" );
> 
> }

Optional是一个包装类，且不可变，不可序列化

空Optional是单例，都是引用Optional.EMPTY 想要获取Optional的值，可以使用get、orElse、orElseGet、orElseThrow

#### MessageDigest

MessageDigest 类是一个引擎类，全类名是：java.security.MessageDigest ，是Java自带的一个类，它是为了提供诸如 SHA1 或 MD5 等密码上安全的报文摘要功能而设计的。密码上安全的报文摘要可接受任意大小的输入（一个字节数组），并产生固定大小的输出，该输出称为一个摘要或散列。摘要具有以下属性：

1、无法通过计算找到两个散列成相同值的报文。

2、摘要不反映任何与输入有关的内容。

使用报文摘要可以生成数据唯一且可靠的标识符。有时它们被称为数据的“数字指纹”。

#### 七牛云OSS:

```JavaScript
<dependency>
  <groupId>com.qiniu</groupId>
  <artifactId>qiniu-java-sdk</artifactId>
  <version>[7.13.0, 7.13.99]</version>
</dependency>
```

#### ObjectMapper(Jackson):

ObjectMapper对象定义位于Jackson Databind项目中

```JavaScript
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-core</artifactId>
  <version>2.9.6</version>
</dependency>
 
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-annotations</artifactId>
  <version>2.9.6</version>
</dependency>
 
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.9.6</version>
</dependency>
```

常用方法:

Car car = objectMapper.readValue(carJson, Car.class);将JSON序列化为自定义对象

默认情况下, Jackson映射一个JSON对象的属性到Java对象, 是用JSON属性的名字在Java对象中查找匹配的getter/setter方法. Jackson移除了getter/setter方法名中的get/set字符部分, 并把方法名剩余字符的第一个字符小写, 得到的就是JSON属性名.

#### Sql xml `<foreach>`用法:

foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。

foreach元素的属性主要有 item，index，collection，open，separator，close。

item表示集合中每一个元素进行迭代时的别名

index指 定一个名字，用于表示在迭代过程中，每次迭代到的位置

separator表示在每次进行迭代之间以什么符号作为分隔符

open表示该语句以什么开始

close表示以什么结束。

在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况 下，该属性的值是不一样的，主要有以下3种情况：

  

如果传入的是单参数且参数类型是一个List的时候，collection属性值为list

如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array

如果传入的参数是Map的时候，collection 的属性值为map 的key值

当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。

当使用 Map 对象（或者 Map.Entry对象的集合）时，index 是键，item 是值。

#### mybatis的association标签

这个标签可以用来对应类中的成员类的属性,嵌套在在Resultmap标签内,有autoMapping属性,改为true可以自动装配,property是实体类中的成员类的对象名,javaType是成员类的类名,

```SQL
<resultMap id="userMap" type="User">
    <id property="id" column="user_id"/>
    <result property="username" column="user_name"/>
    <result property="password" column="user_password"/>
    <association property="role" javaType="Role" resultMap="roleMap" autoMapping="false">
        <id property="id" column="role_id"/>
        <result property="roleName" column="role_name"/>
        <result property="roleDesc" column="role_desc"/>
    </association>
</resultMap>
```

#### java类重写equals

就是要重写形参为Object的方法,将Object强转为对应的类,要让一些类中判断相等的方法变为判断内容则要重新equals和hashash方法,缺一不可

#### MP的逻辑删除字段和id自增策略都可以在yaml中配置

分别为mybatis-plus: global-config: db-config-idtype: <策略> 和logic-delete-field: <逻辑字段名>,此外logic-delete-value 和 logic-not-delete-value可以指定删除和未删除的值

#### MP实现乐观锁

mp实现乐观锁时,修改需要先从数据库查出来对应的实体类,再对实体类进行修改,最后调用MP的update函数去更新数据库,这样才能在更新时将数据库version字段自增,实现乐观锁,而不是直接构建类然后修改.

#### @Lazy注解可以让Bean在第一次被引用时才初始化

默认为程序启动时全部初始化,注解加在@Component上边

#### @Scope("prototype")可以使Bean变为多例

默认单例

#### @PostConstruct和@preDestory可以指定Bean实例化时和销毁时的行为

打在对应的方法上

#### @propertySource("<property文件>")打在配置类上就可以用${}导入常量了

#### @Aspect需要和@Component一起使用

#### @RequestParam里的required和Defaultvalue属性可以设置形参是否为必须和默认值

#### 在起步依赖的`<dependency>`中添加`<exclusions>``<exclision>`可以排除其中的特定依赖

#### 日志输出文件

在yaml中的logging.file或者logging.path中设置存放路径(从src开始)

#### 微服务多模块之间请求头的传递

1.在Openfeign的client的模块(不是网关模块)定义RequestInteceptor,在拦截器中对请求头进行拼接(可以事先把请求头放在threadlocal中),拦截时机是在OpenFeign调用Restful接口前拦截.

2.在Openfeign的client接口参数中增加一个请求头参数,类型为MultiValueMap<String, String>,给这个注解打上@RequestHeader注解,然后在调用对应方法时手动构建一个MultiValueMap作为参数传入即可(使用这个注解时其他的参数必须加上@RequestParam指定对应的参数)

```Java
@FeignClient(contextId = "cityFeignService",
        value = "hub-example-301-nacos",
        fallbackFactory = CityFeignServiceFallbackFactory.class,
        configuration = {FeignConfiguration.class})
public interface CityFeignService {
    @PostMapping("/hub-301-nacos/hub/example/city/queryCityByCityName")
    ResultObj<CityDTO> queryCityByCityName(@RequestParam("cityName") String cityName, 
                                      @RequestHeader MultiValueMap<String, String> headers);
}
```

#### 想要在另一个构造函数中调用其他构造函数需要使用this()调用而不是用<类名>()

#### [正则表达式](https://blog.csdn.net/weixin_43860260/article/details/91417485)

**一、概述：**

用来描述或者匹配一系列符合某个语句规则的字符串

**二、单个符号**

1、英文句点.符号：匹配单个任意字符。

> 表达式t.o 可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。

2、中括号[]：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。

> 表达式：t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn等。

3、| 符号。相当于“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。

> 表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn等。

4、表示匹配次数的符号

![[Pasted image 20250715151530.png]]

> 表达式：[0-9]{ 3 } \- [0-9]{ 2 } \- [0-9]{ 3 } 的匹配格式为：999-99-999
> 
> (因为—符号在正则表达式中有特殊的含义，它表示一个范围，所以在前面加转义字符\)

5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符。

> 表达式：[^x] 第一个字符不能是x

6、\S符号：非空字符

7、\s符号：空字符，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。

8、\r符号：空格符，与\n、\tab相同

**三、快捷符号**

1、\d表示[0—9]

2、\D表示[^0—9]

3、\w表示[0—9A—Z_a—z]

4、\W表示[^0—9A—Z_a—z]

5、\s表示[\t\n\r\f]

6、\S表示[^\t\n\r\f]

**四.Java 中正则表达式的应用**

1、判断功能

`public boolean matches(String regex)`

```Java
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入手机号：");
        String s = sc.nextLine();
        //判断录入的手机号是否为13或者18开头
        String regex = "1[38]\\d{9}";//定义手机号规则
        boolean flag = s.matches(regex);//判断功能
        System.out.println("flag:"+flag);
    }
```

2、替换功能

`public String replaceAll(String regex,String replacement)`

```Java
    public static void main(String[] args){
        String s = "12342jasfkgnas234";
        //把字符串里面的数字替换成*
        String regex = "\\d";
        String ss = "*";
        String result = s.replaceAll(regex,ss);
        System.out.println(result);
    }
```

#### Try with resources

括号内的语句需要用分号隔开

#### java内不声明为static的默认都是virtual

#### 接口允许多继承

#### [java8流计算](https://blog.csdn.net/CNpeaceful/article/details/135391095)

每一个集合他的父类Collection类中有一个stream方法，会返回一个Stream流对象，Stream的泛型为集合的泛型

**创建流:**

```Java
    //单列集合创建流
    List<Map<String, Object>> birthdayData = null;
    Stream<Map<String, Object>> stream = birthdayData.stream();
    
    //单列数组创建流(两种方法)
    Integer[] arr = {1,2,3};
    Stream<Integer> stream1 = Arrays.stream(arr);
    Stream<Integer> stream2 = Stream.of(arr);
 
    //双列Map集合创建流(Map集合不能直接创建Stream流，需要先转换成单列集合)
    Map<Object, Object> hashMap = new HashMap<>();
    hashMap.put("start_date", nowDateStr);
    hashMap.put("end_date", nowDateStr);
    hashMap.put("calendar_search", searchText);
    Set<Map.Entry<Object, Object>> entrySet = hashMap.entrySet();
    Stream<Map.Entry<Object, Object>> mapStream = entrySet.stream();
```

**常用方法:**

1. filter()
    

一、作用

可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中

二、实现原理

会将Stream中的每个元素依次作为filter方法中的，断定行接口中的test方法(支持Lambda表达式)的参数，我们可以自定义test方法的方法体（实现我们自定义的过滤规则），符合条件的将被留在stream流中，如果为false则被剔除

2. map()
    

一、作用 可以把对流中的元素进行计算或转换

二、原理 这个方法的参数一个function函数型接口，重写里面的apply方法，通过遍历这个集合或者数组，拿到集合中某个对象的某个属性

```Java
        list.stream()
                .map(new Function<CalendarFuzzyVo, String>() {
                    @Override
                    public String apply(CalendarFuzzyVo calendarFuzzyVo) {
                        //拿到对象中的日程ID并返回
                        return calendarFuzzyVo.getSchedule_id();
                    }
                })
                .forEach(new Consumer<String>() {
                    @Override
                    public void accept(String s) {
                        System.out.println(s);
                    }
                });
        //Lambda形式
        list.stream()
                .map(calendarFuzzyVo -> calendarFuzzyVo.getSchedule_id())
                .forEach(s -> System.out.println(s));
```

3. distinct()
    

一、作用 可以去除流中重复的元素

二、实现原理 distinct方法是依赖Object中的equals方法来判断是否是相同的对象，所以需要重写对象中的equals方法！

4. sorted()
    

一、作用 可以对流中的元素进行排序

二、实现原理

Java的Stream类中有两个sorted重载方法

1、如果想调用无参数的sorted方法，被排序的对象，需要实现Comparable接口，重写cpmpareTo方法

2、如果调用带参的sorted方法，直接在调该方法的时候，使用匿名内部类的方式进行重写compare方法

#### Hutool Json和List互相转化

```Java
//List转Json，maps是List类型的参数
String json = JSONUtil.toJsonStr(maps);
System.out.println("这是json字符串: "+json);

//Json转List
JSONArray objects =JSONUtil.parseArray(json);
List<Map> maps1 = JSONUtil.toList(objects, Map.class);
System.out.println("这是list集合: "+maps1);
```

#### MP updateById() 对象的空属性不会被更新进数据库

mybatis-plus FieldStrategy 有三种策略：

- IGNORED：0 忽略
    
- NOT_NULL：1 非 NULL，默认策略
    
- NOT_EMPTY：2 非空
    

而默认更新策略是NOT_NULL：非 NULL；即通过接口更新数据时数据为NULL值时将不更新进数据库。

**对某个字段设置单独的field-strategy**

根据具体情况，在需要更新的字段中调整验证注解，如验证非空： @TableField(strategy=FieldStrategy.NOT_EMPTY),这样就可以更改对应字段更新时的策略,但是对于需要设置为null,推荐使用Wrapper的update方法更新.

#### Boot项目文件本地存储

1. 配置文件上传的路径以及请求可以访问的路径(如果不想把文件存在项目里的话)
    

```YAML
web:
  upload-path: D:/data/ #文件存储位置
spring:
  web:
    resources: #请求可以访问的路径
      static-locations: classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,file:${web.upload-path}
```

#### 字符串的拼接

除了使用stringbuilder和buffer，还有stringjoiner（不常用），并且builder和joiner都支持链式调用函数，但是join功能没有builder强大；

#### ☆Spring工具类批量注入静态属性

可以把工具类声明为一个bean,然后写他的构造方法,里边的参数就是要注入的属性,前边打上@Value对应配置文件中的属性即可自动注入

#### XML中SQL冲突字符的写法(如>)

![[Pasted image 20250715151553.png]]

![[Pasted image 20250715151601.png]]

#### [Maven打包跳过测试阶段](https://blog.csdn.net/fengling_smile/article/details/123784734)

mvn clean install -DskipTests

mvn clean install -Dmaven.test.skip=true

DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下

Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类

使用maven.test.skip，不但跳过单元测试的运行，也跳过测试代码的编译;

使用 mvn package -DskipTests 跳过单元测试，但是会继续编译。

#### 将本地文件读取为multipartfile

```XML
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
  </dependency>
```

```Java
  File pdfFile = new File("D://test.pdf");
  FileInputStream fileInputStream = new FileInputStream(pdfFile);
  MultipartFile multipartFile = new MockMultipartFile(pdfFile.getName(), pdfFile.getName(),
  ContentType.APPLICATION_OCTET_STREAM.toString(), fileInputStream);
```

#### java保存文件会直接覆盖同名文件

#### java生成随机数

1. Random类
    

```Java
public static void main(String[] args) {
    Random rand = new Random();
    for (int i = 0; i < 10; i++) {
        System.out.println(rand.nextInt(100) + 1);
    }
}
```

2. Math类
    

返回的数值是`[0.0, 1.0)`的double型数值

```Java
num = (int)(Math.random()*100) + 1;
```

#### JAVA格式化输出

1. 使用 replace 函数动态填充字符串
    

```Java
String str="Hello {0}，我是 {1},今年{2}岁";
str = str.replace("{0}", "CSDN");
str = str.replace("{1}", "小猪");
str = str.replace("{2}", "12");
System.out.println(str);
```

2. 使用 String.format() 占位符替换
    

作用：使用指定的格式字符串和参数返回一个格式化字符串。

```Java
String str=String.format("Hello %s，我是 %s，今年 %s 岁", "CSDN","小猪","12");
System.out.println(str);
```

#### java休眠

方法一：通过线程的sleep方法。

```Java
Thread.currentThread().sleep(1000);
```

在需要程序等待的地方加入这个语句，实现让程序等待，这里的参数1000是以毫秒为单位，即这语句可以让程序等待1秒。

方法二：TimeUnit类里的sleep方法。

```Java
import java.util.concurrent.TimeUnit;
1 TimeUnit.DAYS.sleep(1);//天
2 TimeUnit.HOURS.sleep(1);//小时
3 TimeUnit.MINUTES.sleep(1);//分
4 TimeUnit.SECONDS.sleep(1);//秒
5 TimeUnit.MILLISECONDS.sleep(1000);//毫秒
6 TimeUnit.MICROSECONDS.sleep(1000);//微妙
7 TimeUnit.NANOSECONDS.sleep(1000);//纳秒
```

TimeUnit类提供的方法，其实底层调用的也是Thread类的sleep方法，让程序进行等待。只不过他在上层根据时间单位进行了封装，如上图，共有7种可以选择，可以方便的选择自己需要的时间单位进行使用。

#### JAVA日期格式化

**SimpleDateFormat(已过时):**

1. 创建 SimpleDateFormat 对象
    

要使用 SimpleDateFormat，首先需要创建一个 SimpleDateFormat 对象。你可以在构造函数中传递一个日期时间格式的字符串，该字符串定义了你希望生成的日期时间字符串的格式。下面是创建 SimpleDateFormat 对象的示例：

```Java
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
```

在上述示例中，我们创建了一个 SimpleDateFormat 对象，指定了日期时间的格式为 “yyyy-MM-dd HH:mm:ss”，这意味着生成的日期时间字符串将以年、月、日、小时、分钟和秒的格式呈现。

2. 格式化日期和时间
    

一旦有了 SimpleDateFormat 对象，你可以使用它的 format() 方法将日期和时间对象格式化成字符串。下面是一个示例：

```Java
Date now = new Date(); // 获取当前日期和时间
String formattedDate = dateFormat.format(now);
System.out.println(formattedDate);
```

在上述示例中，我们获取了当前日期和时间，并使用 dateFormat 对象将其格式化成字符串。输出将显示如下格式的日期时间：“2023-09-01 12:30:45”。

3. 解析日期和时间
    

SimpleDateFormat 也可以用于解析字符串并将其转换成日期和时间对象。这在从用户输入或外部数据源中接收日期时间字符串时非常有用。下面是一个示例：

```Java
String dateStr = "2023-09-01 12:30:45";
try {
    Date parsedDate = dateFormat.parse(dateStr);
    System.out.println(parsedDate);
} catch (ParseException e) {
    e.printStackTrace();
}
```

在上述示例中，我们将一个日期时间字符串解析成 Date 对象。输出将显示解析后的日期时间对象。

> 常见的模式字母：
> 
> y：年份（例如，“yy” 表示年份的后两位，“yyyy” 表示完整的年份）。
> 
> M：月份（1 到 12 或 01 到 12）。
> 
> d：日期（1 到 31 或 01 到 31）。
> 
> H：小时（0 到 23 或 00 到 23）。
> 
> h：小时（1 到 12 或 01 到 12）。
> 
> m：分钟（0 到 59或00到59）。
> 
> s：秒（0 到 59 或 00 到 59）。
> 
> S：毫秒。

需要注意的是，SimpleDateFormat 类并不是线程安全的。如果多个线程同时访问同一个 SimpleDateFormat 对象，可能会导致并发问题。为了避免这种情况，你可以使用局部变量或者使用 ThreadLocal 来确保每个线程都有自己的 SimpleDateFormat 实例

**Time:**

1. LocalDateTime
    

我们首先来看最常用的`LocalDateTime`，它表示一个本地日期和时间：

```Java
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDate d = LocalDate.now(); // 当前日期
        LocalTime t = LocalTime.now(); // 当前时间
        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
        System.out.println(d); // 严格按照ISO 8601格式打印
        System.out.println(t); // 严格按照ISO 8601格式打印
        System.out.println(dt); // 严格按照ISO 8601格式打印
    }
}
```

本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，`LocalDateTime`、`LocalDate`和`LocalTime`默认严格按照[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)规定的日期和时间格式进行打印。

> ISO 8601规定的日期和时间分隔符是`T`。标准格式如下：
> 
> - 日期：yyyy-MM-dd
>     
> - 时间：HH:mm:ss
>     
> - 带毫秒的时间：HH:mm:ss.SSS
>     
> - 日期和时间：yyyy-MM-dd'T'HH:mm:ss (注意用T分隔了)
>     
> - 带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS
>     

这三个类之间都有.to可以从高精度向低精度转化

```Java
LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
LocalDate d = dt.toLocalDate(); // 转换到当前日期
LocalTime t = dt.toLocalTime(); // 转换到当前时间
```

还支持简单的创建方式

```Java
// 指定日期和时间:
LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月
LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17
LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
LocalDateTime dt3 = LocalDateTime.of(d2, t2); //支持组合
```

字符串转化

```Java
LocalDateTime dt = LocalDateTime.parse("2019-11-19T15:16:17");
LocalDate d = LocalDate.parse("2019-11-19");
LocalTime t = LocalTime.parse("15:16:17");
```

2. DateTimeFormatter(泛用)
    

这个是SimpleDateFormat的优化版本,基本功能一致

```Java
import java.time.*;
import java.time.format.*;

public class Main {
    public static void main(String[] args) {
        // 自定义格式化:
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        System.out.println(dtf.format(LocalDateTime.now()));
        // 用自定义格式解析:
        LocalDateTime dt2 = LocalDateTime.parse("2019/11/30 15:16:17", dtf);
        System.out.println(dt2);
    }
}
```

`LocalDateTime`提供了对日期和时间进行加减的非常简单的链式调用：

```Java
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
        System.out.println(dt);
        // 加5天减3小时:
        LocalDateTime dt2 = dt.plusDays(5).minusHours(3);
        System.out.println(dt2); // 2019-10-31T17:30:59
        // 减1月:
        LocalDateTime dt3 = dt2.minusMonths(1);
        System.out.println(dt3); // 2019-09-30T17:30:59
    }
}
```

注意到月份加减会自动调整日期，例如从`2019-10-31`减去1个月得到的结果是`2019-09-30`，因为9月没有31日。

对日期和时间进行单独调整则使用`withXxx()`方法，例如：`withHour(15)`会把`10:11:12`变为`15:11:12`：

- 调整年：withYear()
    
- 调整月：withMonth()
    
- 调整日：withDayOfMonth()
    
- 调整时：withHour()
    
- 调整分：withMinute()
    
- 调整秒：withSecond()
    

示例代码如下：

```Java
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
        System.out.println(dt);
        // 日期变为31日:
        LocalDateTime dt2 = dt.withDayOfMonth(31);
        System.out.println(dt2); // 2019-10-31T20:30:59
        // 月份变为9:
        LocalDateTime dt3 = dt2.withMonth(9);
        System.out.println(dt3); // 2019-09-30T20:30:59
    }
}
```

同样注意到调整月份时，会相应地调整日期，即把`2019-10-31`的月份调整为`9`时，日期也自动变为`30`。

.with()方法可以和TemporalAdjusters搭配完成一些复杂的操作,比如求某个月的第一个周一

```Java
import java.time.*;
import java.time.temporal.*;

public class Main {
    public static void main(String[] args) {
        // 本月第一天0:00时刻:
        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();
        System.out.println(firstDay);

        // 本月最后1天:
        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
        System.out.println(lastDay);

        // 下月第1天:
        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
        System.out.println(nextMonthFirstDay);

        // 本月第1个周一:
        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
        System.out.println(firstWeekday);
    }
}
```

要判断两个`LocalDateTime`的先后，可以使用`isBefore()`、`isAfter()`方法，对于`LocalDate`和`LocalTime`类似：

```Java
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
        System.out.println(now.isBefore(target));
        System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));
        System.out.println(LocalTime.now().isAfter(LocalTime.parse("08:15:00")));
    }
}
```

注意到`LocalDateTime`无法与时间戳进行转换，因为`LocalDateTime`没有时区，无法确定某一时刻

3. Duration和Period
    

`Duration`表示两个时刻之间的时间间隔。另一个类似的`Period`表示两个日期之间的天数：

```Java
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
        LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);
        Duration d = Duration.between(start, end);
        System.out.println(d); // PT1235H10M30S
        Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));
        System.out.println(p); // P1M21D
    }
}
```

注意到两个`LocalDateTime`之间的差值使用`Duration`表示，类似`PT1235H10M30S`，表示1235小时10分钟30秒。而两个`LocalDate`之间的差值用`Period`表示，类似`P1M21D`，表示1个月21天。

`Duration`和`Period`的表示方法也符合ISO 8601的格式，它以`P...T...`的形式表示，`P...T`之间表示日期间隔，`T`后面表示时间间隔。如果是`PT...`的格式表示仅有时间间隔。利用`ofXxx()`或者`parse()`方法也可以直接创建`Duration`：

```Java
Duration d1 = Duration.ofHours(10); // 10 hours
Duration d2 = Duration.parse("P1DT2H3M"); // 1 day, 2 hours, 3 minutes
```

#### Validation

常用注解:

![[Pasted image 20250715151623.png]]

**使用:**

1、在Controller层中，放在模型参数对象前。

当Controller层中参数是一个对象模型时，只有将@Validated直接放在该模型前，该模型内部的字段才会被校验(如果有对该模型的字段进行约束的话)。

2、在Controller层中，放在类上。

当一些约束是直接出现在Controller层中的参数前时，只有将@Validated放在类上时，参数前的约束才会生效。

> 大致是只有打了@validated的类中的校验注解才会生效

**@Validated与@Valid的简单对比说明:**

@Valid注解与@Validated注解功能大部分类似；两者的不同主要在于:@Valid属于javax下的，而@Validated属于spring下；@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。