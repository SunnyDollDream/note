![[Pasted image 20250715150137.png]]
![[Pasted image 20250715150144.png]]
![[Pasted image 20250715150150.png]]
![[Pasted image 20250715150159.png]]
![[Pasted image 20250715150204.png]]
![[Pasted image 20250715150209.png]]
![[Pasted image 20250715150215.png]]
![[Pasted image 20250715150221.png]]
![[Pasted image 20250715150231.png]]
![[Pasted image 20250715150238.png]]
![[Pasted image 20250715150244.png]]
完全二叉树的左右子树也是完全二叉树。

完全二叉树的左右子树中，至少有一棵是满二叉树。
![[Pasted image 20250715150300.png]]
假设平衡二叉树中共有 N个节点，那么平衡二叉树的高度是 O(log⁡N)
#### DFS

```Java
// 基本的二叉树节点
class TreeNode {
    int val;
    TreeNode left, right;
}

// 二叉树的遍历框架
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.left);
    traverse(root.right);
}

// 二叉树的遍历框架
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}

// N 叉树的遍历框架
void traverse(Node root) {
    if (root == null) {
        return;
    }
    // 前序位置
    for (Node child : root.children) {
        traverse(child);
    }
    // 后序位置
}
```

二叉搜索树（BST） 的中序遍历结果是有序的，这是 BST 的一个重要性质

#### 回溯算法

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

```Java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个蓝色节点的属性：
![[Pasted image 20250715150342.png]]
```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    // 主函数，输入一组不重复的数字，返回它们的全排列
    List<List<Integer>> permute(int[] nums) {
        // 记录「路径」
        LinkedList<Integer> track = new LinkedList<>();
        // 「路径」中的元素会被标记为 true，避免重复使用
        boolean[] used = new boolean[nums.length];
        
        backtrack(nums, track, used);
        return res;
    }

    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
        // 触发结束条件
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            // 排除不合法的选择
            if (used[i]) {
                // nums[i] 已经在 track 中，跳过
                continue;
            }
            // 做选择
            track.add(nums[i]);
            used[i] = true;
            // 进入下一层决策树
            backtrack(nums, track, used);
            // 取消选择
            track.removeLast();
            used[i] = false;
        }
    }
}
```

#### BFS

```Java
//写法1
void levelOrderTraverse(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode cur = q.poll();
        // 访问 cur 节点
        System.out.println(cur.val);

        // 把 cur 的左右子节点加入队列
        if (cur.left != null) {
            q.offer(cur.left);
        }
        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}
//写法二(常用)
void levelOrderTraverse(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.isEmpty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            // 访问 cur 节点，同时知道它所在的层数
            System.out.println("depth = " + depth + ", val = " + cur.val);

            // 把 cur 的左右子节点加入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
        depth++;
    }
}
//N叉树
//写法一
void levelOrderTraverse(Node root) {
    if (root == null) {
        return;
    }
    Queue<Node> q = new LinkedList<>();
    q.offer(root);
    while (!q.isEmpty()) {
        Node cur = q.poll();
        // 访问 cur 节点
        System.out.println(cur.val);

        // 把 cur 的所有子节点加入队列
        for (Node child : cur.children) {
            q.offer(child);
        }
    }
}
//写法二
void levelOrderTraverse(Node root) {
    if (root == null) {
        return;
    }
    Queue<Node> q = new LinkedList<>();
    q.offer(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.isEmpty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            // 访问 cur 节点，同时知道它所在的层数
            System.out.println("depth = " + depth + ", val = " + cur.val);

            for (Node child : cur.children) {
                q.offer(child);
            }
        }
        depth++;
    }
}
//写法三
class State {
    Node node;
    int depth;

    public State(Node node, int depth) {
        this.node = node;
        this.depth = depth;
    }
}

void levelOrderTraverse(Node root) {
    if (root == null) {
        return;
    }
    Queue<State> q = new LinkedList<>();
    // 记录当前遍历到的层数（根节点视为第 1 层）
    q.offer(new State(root, 1));

    while (!q.isEmpty()) {
        State state = q.poll();
        Node cur = state.node;
        int depth = state.depth;
        // 访问 cur 节点，同时知道它所在的层数
        System.out.println("depth = " + depth + ", val = " + cur.val);

        for (Node child : cur.children) {
            q.offer(new State(child, depth + 1));
        }
    }
}
//用递归方式实现BFS
class Solution {

    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> levelTraverse(TreeNode root) {
        if (root == null) {
            return res;
        }
        List<TreeNode> nodes = new LinkedList<>();
        nodes.add(root);
        traverse(nodes);
        return res;
    }

    void traverse(List<TreeNode> curLevelNodes) {
        // base case
        if (curLevelNodes.isEmpty()) {
            return;
        }
        // 前序位置，计算当前层的值和下一层的节点列表
        List<Integer> nodeValues = new LinkedList<>();
        List<TreeNode> nextLevelNodes = new LinkedList<>();
        for (TreeNode node : curLevelNodes) {
            nodeValues.add(node.val);
            if (node.left != null) {
                nextLevelNodes.add(node.left);
            }
            if (node.right != null) {
                nextLevelNodes.add(node.right);
            }
        }
        // 前序位置添加结果，可以得到自顶向下的层序遍历
        res.add(nodeValues);
        traverse(nextLevelNodes);
        // 后序位置添加结果，可以得到自底向上的层序遍历结果
        // res.add(nodeValues);
    }
}
```

```java
// 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数
// 当走到目标节点 target 时，返回步数
int bfs(int s, int target) {
    boolean[] visited = new boolean[graph.size()];
    Queue<Integer> q = new LinkedList<>();
    q.offer(s);
    visited[s] = true;
    // 记录从 s 开始走到当前节点的步数
    int step = 0;
    while (!q.isEmpty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            int cur = q.poll();
            System.out.println("visit " + cur + " at step " + step);
            // 判断是否到达终点
            if (cur == target) {
                return step;
            }
            // 将邻居节点加入队列，向四周扩散搜索
            for (int to : neighborsOf(cur)) {
                if (!visited[to]) {
                    q.offer(to);
                    visited[to] = true;
                }
            }
        }
        step++;
    }
    // 如果走到这里，说明在图中没有找到目标节点
    return -1;
}
```

#### 双向BFS

你必须知道终点在哪里，才能使用双向 BFS 进行优化。
![[Pasted image 20250715150410.png]]
```typescript
class Solution {
    public int openLock(String[] deadends, String target) {
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // base case
        if (deads.contains("0000")) return -1;
        if (target.equals("0000")) return 0;

        // 用集合不用队列，可以快速判断元素是否存在
        Set<String> q1 = new HashSet<>();
        Set<String> q2 = new HashSet<>();
        Set<String> visited = new HashSet<>();
        
        int step = 0;
        q1.add("0000");
        visited.add("0000");
        q2.add(target);
        visited.add(target);

        while (!q1.isEmpty() && !q2.isEmpty()) {
            // 在这里增加步数
            step++;

            // 哈希集合在遍历的过程中不能修改，所以用 newQ1 存储邻居节点
            Set<String> newQ1 = new HashSet<>();

            // 获取 q1 中的所有节点的邻居
            for (String cur : q1) {
                // 将一个节点的未遍历相邻节点加入集合
                for (String neighbor : getNeighbors(cur)) {
                    // 判断是否到达终点
                    if (q2.contains(neighbor)) {
                        return step;
                    }
                    if (!visited.contains(neighbor) && !deads.contains(neighbor)) {
                        newQ1.add(neighbor);
                        visited.add(neighbor);
                    }
                }
            }
            // newQ1 存储着 q1 的邻居节点
            q1 = newQ1;
            // 因为每次 BFS 都是扩散 q1，所以把元素数量少的集合作为 q1
            if (q1.size() > q2.size()) {
                Set<String> temp = q1;
                q1 = q2;
                q2 = temp;
            }
        }
        return -1;
    }

    // 将 s[j] 向上拨动一次
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    // 将 s[i] 向下拨动一次
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }

    List<String> getNeighbors(String s) {
        List<String> neighbors = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            neighbors.add(plusOne(s, i));
            neighbors.add(minusOne(s, i));
        }
        return neighbors;
    }
}
```

#### 拓扑排序

对于图中节点1->2定义为做完1才能做2时,此时的拓扑排序就是图中后序遍历结果的逆序
## 时间复杂度的计算

**等差数列求和公式:**

![[Pasted image 20250715150432.png]]

  

![[Pasted image 20250715150438.png]]

**等比数列求和公式:**
![[Pasted image 20250715150454.png]]
![[Pasted image 20250715150458.png]]

#### 单层循环

可以找出i与轮次t之间的关系,再和循环条件进行联立,解出t关于n的表达式,再换算为T即可

![[Pasted image 20250715150513.png]]

#### 二层循环

先找出内层循环次数和外层i之间的关系,将i推导到循环条件的结束,再对内层的循环次数求和即为t的表达式

![[Pasted image 20250715150522.png]]

#### 三层循环

可以把整个循环体看做是一个椎体每个轴上的长度就是对应循环所能达到的最大次数,再计算体积就得到了T

#### 多层循环

可以从最内层循环开始以外层循环的变量列出单轮运行次数与k的关系,依次向外求和得到T

![[Pasted image 20250715150529.png]]
## 双指针

#### 倒序单链表

对于链表无法从后往前遍历的情况,可以使用递归方法来模拟

```Java
// 倒序打印单链表中的元素值
void traverse(ListNode head) {
    if (head == null) return;
    traverse(head.next);
    // 后序遍历代码
    print(head.val);
}
//https://leetcode.cn/problems/palindrome-linked-list/description/
```

#### 滑动窗口

```Java
// 滑动窗口算法伪码框架
void slidingWindow(String s) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    Object window = ...
    
    int left = 0, right = 0;
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s[right];
        window.add(c)
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        // *** debug 输出的位置 ***
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时
        printf("window: [%d, %d)\n", left, right);
        // ***********************

        // 判断左侧窗口是否要收缩
        while (left < right && window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            window.remove(d)
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

滑动窗口应该操作窗口的左右指针,而不是根据数组去修改左右指针

https://leetcode.cn/problems/minimum-window-substring/description/

#### 二分查找

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

```Java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}

//寻找左右边界
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 最后改成返回 right
    if (right < 0 || right >= nums.length) {
        return -1;
    }
    return nums[right] == target ? right : -1;
}
```

## 环形数组

环形数组的关键在于，它维护了两个指针 `start` 和 `end`，`start` 指向第一个有效元素的索引，`end` 指向最后一个有效元素的下一个位置索引。

```Java
public class CycleArray<T> {
    private T[] arr;
    private int start;
    private int end;
    private int count;
    private int size;

    public CycleArray() {
        this(1);
    }

    @SuppressWarnings("unchecked")
    public CycleArray(int size) {
        this.size = size;
        // 因为 Java 不支持直接创建泛型数组，所以这里使用了类型转换
        this.arr = (T[]) new Object[size];
        // start 指向第一个有效元素的索引，闭区间
        this.start = 0;
        // 切记 end 是一个开区间，
        // 即 end 指向最后一个有效元素的下一个位置索引
        this.end = 0;
        this.count = 0;
    }

    // 自动扩缩容辅助函数
    @SuppressWarnings("unchecked")
    private void resize(int newSize) {
        // 创建新的数组
        T[] newArr = (T[]) new Object[newSize];
        // 将旧数组的元素复制到新数组中
        for (int i = 0; i < count; i++) {
            newArr[i] = arr[(start + i) % size];
        }
        arr = newArr;
        // 重置 start 和 end 指针
        start = 0;
        end = count;
        size = newSize;
    }

    // 在数组头部添加元素，时间复杂度 O(1)
    public void addFirst(T val) {
        // 当数组满时，扩容为原来的两倍
        if (isFull()) {
            resize(size * 2);
        }
        // 因为 start 是闭区间，所以先左移，再赋值
        start = (start - 1 + size) % size;
        arr[start] = val;
        count++;
    }

    // 删除数组头部元素，时间复杂度 O(1)
    public void removeFirst() {
        if (isEmpty()) {
            throw new IllegalStateException("Array is empty");
        }
        // 因为 start 是闭区间，所以先赋值，再右移
        arr[start] = null;
        start = (start + 1) % size;
        count--;
        // 如果数组元素数量减少到原大小的四分之一，则减小数组大小为一半
        if (count > 0 && count == size / 4) {
            resize(size / 2);
        }
    }

    // 在数组尾部添加元素，时间复杂度 O(1)
    public void addLast(T val) {
        if (isFull()) {
            resize(size * 2);
        }
        // 因为 end 是开区间，所以是先赋值，再右移
        arr[end] = val;
        end = (end + 1) % size;
        count++;
    }

    // 删除数组尾部元素，时间复杂度 O(1)
    public void removeLast() {
        if (isEmpty()) {
            throw new IllegalStateException("Array is empty");
        }
        // 因为 end 是开区间，所以先左移，再赋值
        end = (end - 1 + size) % size;
        arr[end] = null;
        count--;
        // 缩容
        if (count > 0 && count == size / 4) {
            resize(size / 2);
        }
    }

    // 获取数组头部元素，时间复杂度 O(1)
    public T getFirst() {
        if (isEmpty()) {
            throw new IllegalStateException("Array is empty");
        }
        return arr[start];
    }

    // 获取数组尾部元素，时间复杂度 O(1)
    public T getLast() {
        if (isEmpty()) {
            throw new IllegalStateException("Array is empty");
        }
        // end 是开区间，指向的是下一个元素的位置，所以要减 1
        return arr[(end - 1 + size) % size];
    }

    public boolean isFull() {
        return count == size;
    }
    
    public int size() {
        return count;
    }

    public boolean isEmpty() {
        return count == 0;
    }
}
```

## 前缀和

```c++
class NumArray {
    // 前缀和数组
    private int[] preSum;

    // 输入一个数组，构造前缀和
    public NumArray(int[] nums) {
        // preSum[0] = 0，便于计算累加和
        preSum = new int[nums.length + 1];
        // 计算 nums 的累加和
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }

    // 查询闭区间 [left, right] 的累加和
    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}

//二维前缀和
class NumMatrix {
    // preSum[i][j] 记录矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```

## 差分数组

```c++
// 差分数组工具类
class Difference {
    // 差分数组
    private int[] diff;
    
    // 输入一个初始数组，区间操作将在这个数组上进行
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    // 给闭区间 [i, j] 增加 val（可以是负数）
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    // 返回结果数组
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}
//这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可
```

Goal[i] = origin[i] - origin[i-1]

## 单调栈

下一个最大元素,上一个最小元素

```Java
int[] calculateGreaterElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>(); 
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.isEmpty() && s.peek() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的更大元素
        res[i] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i]);
    }
    return res;
}

//环形数组变体
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        Stack<Integer> s = new Stack<>();
        // 数组长度加倍模拟环形数组
        for (int i = 2 * n - 1; i >= 0; i--) {
            // 索引 i 要求模，其他的和模板一样
            while (!s.isEmpty() && s.peek() <= nums[i % n]) {
                s.pop();
            }
            res[i % n] = s.isEmpty() ? -1 : s.peek();
            s.push(nums[i % n]);
        }
        return res;
    }
}
```

## 单调队列

滑动窗口中的最大值问题

类似优先队列,但是单调队列既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构。

```java
// 单调队列的实现
class MonotonicQueue {
    LinkedList<Integer> maxq = new LinkedList<>();
    public void push(int n) {
        // 将小于 n 的元素全部删除
        while (!maxq.isEmpty() && maxq.getLast() < n) {

            maxq.pollLast();
        }
        // 然后将 n 加入尾部
        maxq.addLast(n);
    }
    
    public int max() {
        return maxq.getFirst();
    }
    
    public void pop(int n) {
        if (n == maxq.getFirst()) {
            maxq.pollFirst();
        }
    }
}
```

## 递归

#### 分解问题

用这种方法写的递归函数一定要有一个清晰的定义，说明这个函数参数的含义是什么，返回什么结果。

```java
// 定义：输入一个非负整数 n，返回斐波那契数列中的第 n 个数
int fib(int n) {
    if (n < 2) {
        return n;
    }
    // 利用定义，计算前两个斐波那契数（子问题）
    int fib_n_1 = fib(n - 1);
    int fib_n_2 = fib(n - 2);

    // 通过子问题的解，计算原问题的解
    return fib_n_1 + fib_n_2;
}
```

#### 遍历

用这种方法写的递归函数没有返回值,而是在遍历的过程中选择合适的时间点收集结果

```java
// 全排列算法主要结构

// 全局变量，存储 backtrack 函数的遍历状态
List<List<Integer>> res = new LinkedList<>();
List<Integer> track = new LinkedList<>();

// 递归树遍历函数
void backtrack(int[] nums, List<Integer> track) {
    if (track.size() == nums.length) {
        // 到达叶子节点，收集结果
        res.add(new LinkedList<>(track));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.add(nums[i]);

        backtrack(nums, track);

        // 撤销选择
        track.removeLast();
    }
}
```

1、首先，这个问题是否可以抽象成一棵树结构？如果可以，那么就要用递归算法了。

2、如果要用递归算法，那么就思考「遍历」和「分解问题」这两种思维模式，看看哪种更适合这个问题。

3、如果用「分解问题」的思维模式，那么一定要写清楚这个递归函数的定义是什么，然后利用这个定义来分解问题，利用子问题的答案推导原问题的答案；如果用「遍历」的思维模式，那么要用一个无返回值的递归函数，单纯起到遍历递归树，收集目标结果的作用。

> 有的时候两种方法会在同一道题中出现,如在遍历过程中使用分解问题的方式去维护答案

https://leetcode.cn/problems/diameter-of-binary-tree/description/

递归套递归大部分都可以优化为一个递归,即把第二个递归合并到第一个递归的后序部分

```java
public class LC543 {
        int ans = 0;
        public int getDepth(TreeNode root) {//这是分解为求左右深度再求周长,但是求深度时需要遍历,所以可以把下边的遍历方法在求深度的遍历过程中完成,而不需要再次遍历
                if (root == null) {
                        return 0;
                }
                int left =  getDepth(root.left);
                int right = getDepth(root.right);
                int res = left + right;
                ans = Math.max(ans, res);
                return Math.max(left,right)+1; 
        }
//    public void trver(TreeNode root) {
//            if (root == null) {
//                        return ;
//                }
//            int res = getDepth(root.left) + getDepth(root.right);
//            ans = Math.max(ans, res);
//            trver(root.left);
//        trver(root.right);
//    }
    public int diameterOfBinaryTree(TreeNode root) {
        getDepth(root);
        return ans;
    }
}
如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了
```

## 二叉树

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
![[Pasted image 20250715150616.png]]
动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：

- 动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」。
    
- 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。
    
- DFS 算法属于遍历的思路，它的关注点在单个「节点」。
    

## 二叉搜索树

二叉搜索树的中序遍历结果为一个递增的序列

如要插入数据,只要在末尾插入即可,因为有多种插入的位置,但是在中间插入的话需要维护二叉树的性质所以很麻烦

删除的话有三种情况,一种是要删除的节点左右子树都没有,可以直接删除,有一个子树可以直接用该子树替换(不会出现左子树应该放在要删除的节点的父节点的左边还是右边的问题,直接替换),有两个子树则可以把左右子树中的一个暂存,另一个直接替换要删除的节点,再在替换后的子树里插入暂存的子树即可,插入过程和正常过程一致.

## LRU(Least Recently Used)算法

java中的LinkedHashMap对这种数据结构提供了支持,他有三个构造器参数,第一个为初始容量(int),第二个为负载因子(float),第三个为是否要按LRU排序(boolean),默认为false,按照插入顺序排序,如果传入true则会按照最近访问进行排序,最近被访问的元素会被移到队尾;其中还有一个方法为removeEldestEntry(),可以自己实现LinkedHashMap时进行重写,其返回值为一个boolean,返回为true时会删除最老的元素;

另外,他的构造函数还支持直接传入一个hashmap来构造

## 设计计算器

```Java
class Solution {
    public int calculate(String s) {
        // key 是左括号的索引，value 是对应的右括号的索引
        Map<Integer, Integer> rightIndex = new HashMap<>();
        // 利用栈结构来找到对应的括号
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else if (s.charAt(i) == ')') {
                rightIndex.put(stack.pop(), i);
            }
        }
        return _calculate(s, 0, s.length() - 1, rightIndex);
    }

    // 定义：返回 s[start..end] 内的表达式的计算结果
    private int _calculate(String s, int start, int end, Map<Integer, Integer> rightIndex) {
        // 需要把字符串转成双端队列方便操作
        Stack<Integer> stk = new Stack<>();
        // 记录算式中的数字
        int num = 0;
        // 记录 num 前的符号，初始化为 +
        char sign = '+';
        for (int i = start; i <= end; i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = 10 * num + (c - '0');
            }
            if (c == '(') {
                // 递归计算括号内的表达式
                num = _calculate(s, i + 1, rightIndex.get(i) - 1, rightIndex);
                i = rightIndex.get(i);
            }
            if (c == '+' || c == '-' || c == '*' || c == '/' || i == end) {
                int pre;
                switch (sign) {
                    case '+':
                        stk.push(num);
                        break;
                    case '-':
                        stk.push(-num);
                        break;
                    // 只要拿出前一个数字做对应运算即可
                    case '*':
                        pre = stk.pop();
                        stk.push(pre * num);
                        break;
                    case '/':
                        pre = stk.pop();
                        stk.push(pre / num);
                        break;
                }
                // 更新符号为当前符号，数字清零
                sign = c;
                num = 0;
            }
        }
        // 将栈中所有结果求和就是答案
        int res = 0;
        while (!stk.isEmpty()) {
            res += stk.pop();
        }
        return res;
    }
}
```
## 最短路

对于边有权重(即边有长度时),邻接表的泛型可以为一个结构体,里边存放出点和权重

#### dijkstra(单源最短路)

当边数大于点数的时候,该图为稠密图,此时用枚举的方法会比小根堆更快

![[Pasted image 20250715150808.png]]

![[Pasted image 20250715150815.png]]

```C++
#include <bits/stdc++.h>
using namespace std;
vector<pair<int,int>> g[(int) 1e5+10];//存边
long dis[(int)1e3+10];//存每一个点到原点的距离
bitset<(int)1e3+10> vis;
int main(){
   int n,m; cin>>n>>m;
   for (int i = 1; i <= m; ++i) {//存图
       int u,v,w; cin>>u>>v>>w;
       pair<int,int> pair(v,w);
       if(u != v) g[u].push_back(pair);
   }
   
   //
   for(int i=1;i<=n;i++) dis[i]=INT_MAX;
   dis[1]=0;
   for (int i = 1; i <= n; ++i) {
       int u = 1;
       for (int j = 1; j < n; ++j) {
           if (vis[u]||(!vis[j]&&dis[j]<dis[u])) u = j;
       }
       vis[u]=true;
       for(pair<int,int> tem:g[u]){
           if (!vis[tem.first] && dis[tem.first] > dis[u]+tem.second) dis[tem.first]=dis[u]+tem.second;
       }
   }
   //
   
   if(dis[n] == INT_MAX) cout<<-1;
   else cout<<dis[n];
   return 0;
}
```

**优先队列优化:**

```C++
#include <bits/stdc++.h>
using namespace std;
struct cmp{
   bool operator()(pair<int,int> a,pair<int,int> b){
       return a.second == b.second ? a.first > b.first : a.second > b.second;
   }
};
vector<pair<int,int>> g[(int) 1e5+10];//存边
long dis[(int)1e5+10];//存每一个点到原点的距离
bitset<(int)1e5+10> vis;
priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> pq;
int main(){
   int n,m; cin>>n>>m;
   for (int i = 1; i <= m; ++i) {//存图
       int u,v,w; cin>>u>>v>>w;
       pair<int,int> pair(v,w);
       if(u != v) g[u].push_back(pair);
   }
   
   //
   for(int i=1;i<=n;i++) dis[i]=INT_MAX;
   dis[1]=0;
   pq.push({1,dis[1]});
   while (pq.size()) {

       pair<int,int> now = pq.top();
       pq.pop();
       if (vis[now.first]) continue;
       vis[now.first]= true;

       for(pair<int,int> tem:g[now.first]){
           if (!vis[tem.first] && dis[tem.first] > dis[now.first]+tem.second)
               dis[tem.first] = now.second + tem.second;
               pq.push({tem.first,dis[tem.first]});
       }
   }
   //
   
   if(dis[n] == INT_MAX) cout<<-1;
   else cout<<dis[n];
   return 0;
}
```

LC743:

```Java
public static int networkDelayTime(int[][] times, int n, int k) {
    class Pair implements Comparable<Pair>{ //没有Pair写一个代替的
        Integer first,second;

        public Pair(Integer first, Integer second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(Pair o) {
            return second.equals(o.second) ? first - o.first : second - o.second;
        }
    }
    Integer ans = -1;//结果
    Integer[] dis = new Integer[n+1];//记录距离原点的距离
    BitSet vis = new BitSet();//记录是否拓展过
    Arrays.fill(dis, Integer.MAX_VALUE);//初始化
    List<Pair>[] g = new List[110];
    for (int[] time : times) {//存图
        if (g[time[0]] == null) g[time[0]] = new ArrayList<>();
        g[time[0]].add(new Pair(time[1],time[2]));
    }
    PriorityQueue<Pair> priorityQueue = new PriorityQueue<>();
    dis[k] = 0;
    priorityQueue.add(new Pair(k,dis[k]));//放入初始点
    while (!priorityQueue.isEmpty()){//迪杰斯特拉 bfs
        Pair now = priorityQueue.poll();
        if (vis.get(now.first)) continue;
        vis.set(now.first);
        if(g[now.first] == null) continue;
        for (Pair tem: g[now.first]) {
            if (!vis.get(tem.first))
                dis[tem.first] = Math.min(dis[now.first]+tem.second,dis[tem.first]);
            priorityQueue.add(new Pair(tem.first,dis[tem.first]));
        }
    }
    for (int i = 1;i<= n;i++) {
        ans = Math.max(ans,dis[i]);
    }
    return ans.equals(0) ? -1 : ans;
}
```

#### floyd(非单源但点较少)

![[Pasted image 20250715150833.png]]
>n为点的个数,m为边的个数,q为要查询的节点区间个数

![[Pasted image 20250715150849.png]]
#### 根据前序和后序序列构建二叉树
![[Pasted image 20250715150910.png]]
1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

为什么通过前序遍历和后序遍历结果还原的二叉树可能不唯一呢？

关键在这一句：

```Java
int leftRootVal = preorder[preStart + 1];
```

我们假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。
## 递归算法的时间复杂度计算:主定理

![[Pasted image 20250715150937.png]]

## 排序

![[Pasted image 20250715150949.png]]

![[Pasted image 20250715150956.png]]

![[Pasted image 20250715151003.png]]

![[Pasted image 20250715151008.png]]

![[Pasted image 20250715151017.png]]

![[Pasted image 20250715151024.png]]

![[Pasted image 20250715151050.png]]
![[Pasted image 20250715151056.png]]
## 最小生成树

#### Prim(基于点)

**朴素:**
## 动态规划

动态规划的一般形式是求最值,如最长递增子序列,最小编辑距离等

```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
            
int fib(int n) {
    if (n == 0 || n == 1) {
        // base case
        return n;
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    int dp_i_1 = 1, dp_i_2 = 0;
    for (int i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        int dp_i = dp_i_1 + dp_i_2;
        // 滚动更新
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
}
```

#### 几个概念

**重叠子问题:** 即在把原问题分解为子问题时,有的子问题是重复的,如递归计算斐波那契数列时,递归树的左右子树中会存在部分完全一样的过程,如求F(20)时先求F(19)和F(18),而计算F(19)时又需要计算一次F(18),产生冗余

解决办法:添加一个备忘录存储之前计算过的子问题结果,之后如果遇到相同的问题直接返回即可,进行函数前查备忘录,函数返回前存备忘录

**状态转移方程:** 描述问题的数学公式

**最优子结构:** 动态规划问题一定有最优子结构,要符合「最优子结构」，子问题间必须互相独立,即子问题之间不能相互影响

#### 求状态转移方程的过程

**明确「状态」-> 明确「选择」 -> 定义** **`dp`** **数组/函数的含义。**

1、确定「状态」，也就是原问题和子问题中会变化的变量

2、确定「选择」，也就是导致「状态」产生变化的行为

3、明确 `dp` 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。如果是自底向上的迭代解法,就要给出dp数组的定义,如`dp` 数组的定义：当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出。

> 1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。
> 
> 2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。
> 
> 但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

#### 凑零钱

1、确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

2、确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

3、明确 `dp` 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量。

`dp` 数组的定义：当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出。

```java
class Solution {
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // 备忘录初始化为一个不会被取到的特殊值，代表还未被计算
        Arrays.fill(memo, -666);

        return dp(coins, amount);
    }

    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // 查备忘录，防止重复计算
        if (memo[amount] != -666)
            return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        // 把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}
```

```c++
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        // 数组大小为 amount + 1，初始值也为 amount + 1
        Arrays.fill(dp, amount + 1);

        // base case
        dp[0] = 0;
        // 外层 for 循环在遍历所有状态的所有取值
        for (int i = 0; i < dp.length; i++) {
            // 内层 for 循环在求所有选择的最小值
            for (int coin : coins) {
                // 子问题无解，跳过
                if (i - coin < 0) {
                    continue;
                }
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
```

#### 最长递增子序列（Longest Increasing Subsequence，简写 LIS）

状态是结尾的数的下标

选择是前边或后边的任意一个数

`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

#### 0-1背包

**第一步要明确两点，「状态」和「选择」。**

先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。

---

**第二步要明确** **`dp`** **数组的定义。**

`dp[i][w]` 的定义如下：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`。

---

**第三步，根据「选择」，思考状态转移的逻辑。**

简单说就是，上面伪码中「把物品 `i` 装进背包」和「不把物品 `i` 装进背包」怎么用代码体现出来呢？

这就要结合对 `dp` 数组的定义，看看这两种选择会对状态产生什么影响：

先重申一下刚才我们的 `dp` 数组的定义：

`dp[i][w]` 表示：对于前 `i` 个物品（从 1 开始计数），当前背包的容量为 `w` 时，这种情况下可以装下的最大价值是 `dp[i][w]`。

如果你没有把这第 `i` 个物品装入背包，那么很显然，最大价值 `dp[i][w]` 应该等于 `dp[i-1][w]`，继承之前的结果。

如果你把这第 `i` 个物品装入了背包，那么 `dp[i][w]` 应该等于 `val[i-1] + dp[i-1][w - wt[i-1]]`。

首先，由于数组索引从 0 开始，而我们定义中的 `i` 是从 1 开始计数的，所以 `val[i-1]` 和 `wt[i-1]` 表示第 `i` 个物品的价值和重量。

你如果选择将第 `i` 个物品装进背包，那么第 `i` 个物品的价值 `val[i-1]` 肯定就到手了，接下来你就要在剩余容量 `w - wt[i-1]` 的限制下，在前 `i - 1` 个物品中挑选，求最大价值，即 `dp[i-1][w - wt[i-1]]`。

```java
int knapsack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    
    return dp[N][W];
}
```

#### 编辑距离

> 解决两个字符串的动态规划问题，一般都是用两个指针 `i, j` 分别指向两个字符串的头部或尾部，然后尝试写状态转移方程。
> 
> 比方说让 `i, j` 分别指向两个字符串的尾部，把 `dp[i], dp[j]` 定义为 `s1[0..i], s2[0..j]` 子串的编辑距离，那么 `i, j` 一步步往前移动的过程，就是问题规模（子串长度）逐步减小的过程。
> 
> 当然，你想让让 `i, j` 分别指向字符串头部，然后一步步往后移动也可以，本质上并无区别，只要改一下 `dp` 函数/数组的定义即可。

https://labuladong.online/algo/dynamic-programming/edit-distance/

base case 是 `i` 走完 `s1` 或 `j` 走完 `s2`，可以直接返回另一个字符串剩下的长度。

两个状态（索引 `i` 和 `j`）(两个字符串子串的尾索引)

选择是增删改和跳过

int dp(String s1, int i, String s2, int j)

// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离

dp[i-1][j-1]

// 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离

```typescript
class Solution {
    // 备忘录
    int[][] memo;
        
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 备忘录初始化为特殊值，代表还未计算
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dp(s1, m - 1, s2, n - 1);
    }

    int dp(String s1, int i, String s2, int j) {
        if (i == -1) return j + 1;
        if (j == -1) return i + 1;
        // 查备忘录，避免重叠子问题
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 状态转移，结果存入备忘录
        //每次的目的就是要让s1[i] == s2[j]
        if (s1.charAt(i) == s2.charAt(j)) {
            //两个字母相同不需要处理
            memo[i][j] = dp(s1, i - 1, s2, j - 1);
            // 解释：
            // 本来就相等，不需要任何操作
            // s1[0..i] 和 s2[0..j] 的最小编辑距离等于
            // s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
            // 也就是说 dp(i, j) 等于 dp(i-1, j-1)
        } else {
            memo[i][j] =  min(
                //插入(如果我在尾部插入,我就是想让s1[0...i]和s2[0...j-1]相同)
                dp(s1, i, s2, j - 1) + 1,
                // 解释：
                // 我直接在 s1[i] 后面插入一个和 s2[j] 一样的字符
                // 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比
                // 别忘了操作数加一
                
                //删除(如果我删了i,那我就是想让s1[0...i-1]和s2[0...j]一样)
                dp(s1, i - 1, s2, j) + 1,
                // 解释：
                // 我直接把 s[i] 这个字符删掉
                // 前移 i，继续跟 j 对比
                // 操作数加一
                
                //替换
                dp(s1, i - 1, s2, j - 1) + 1
                // 解释：
                // 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了
                // 同时前移 i，j 继续对比
                // 操作数加一
            );
        }
        return memo[i][j];
    }

    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}

```
![[Pasted image 20250715151127.png]]
```java
class Solution {
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 定义：s1[0..i] 和 s2[0..j] 的最小编辑距离是 dp[i+1][j+1]
        int[][] dp = new int[m + 1][n + 1];
        // base case 
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;
        // 自底向上求解
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i - 1][j - 1] + 1
                    );
                }
            }
        }
        // 储存着整个 s1 和 s2 的最小编辑距离
        return dp[m][n];
    }

    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

## N数之和

```Java
// 注意：调用这个函数之前一定要先给 nums 排序
// n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和
List<List<Integer>> nSumTarget(int[] nums, int n, int start, long target) {
    int sz = nums.length;
    List<List<Integer>> res = new ArrayList<>();
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.add(new ArrayList<>(Arrays.asList(left, right)));
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (List<Integer> arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.add(nums[i]);
                res.add(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

## 判断素数

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        for (int i = 2; i * i < n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) count++;
        }
        
        return count;
    }
}
```