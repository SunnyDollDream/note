## 项目结构

 1. pages 用来存放所有小程序的页面
	 小程序官方建议把所有小程序的页面，都存放在 pages 目录中，以单独的文件夹存在,其中，每个页面由 4 个基本文件组成，它们分别是：
	 1.  .js 文件（页面的脚本文件，存放页面的数据、事件处理函数等）
	 2.  .json 文件（当前页面的配置文件，配置窗口的外观、表现等）
	 3.  .wxml 文件（页面的模板结构文件,对标.html）
	 4.  .wxss 文件（当前页面的样式表文件,对标.css）
 2. utils 用来存放工具性质的模块（例如：格式化时间的自定义模块）
 3. app.js 小程序项目的入口文件
 4. app.json 小程序项目的全局配置文件
 5. app.wxss 小程序项目的全局样式文件
 6. project.config.json 项目的配置文件
 7. sitemap.json 用来配置小程序及其页面是否允许被微信索引
### .json文件 
 JSON 是一种数据格式，在实际开发中，JSON 总是以配置文件的形式出现。小程序项目中也不例外：通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。

小程序项目中有 4 种 json 配置文件，分别是：
1. 项目根目录中的 app.json 配置文件
2. 项目根目录中的 project.config.json 配置文件
3. 项目根目录中的 sitemap.json 配置文件
4. 每个页面文件夹中的 .json 配置文件
#### app.json

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab 等。Demo 项目里边的 app.json 配置内容如下：

![[Pasted image 20250512123140.png]]

简单了解下这 4 个配置项的作用：
1. pages：用来记录当前小程序所有页面的路径
2. window：全局定义小程序所有页面的背景色、文字颜色等
3. style：全局定义小程序组件所使用的样式版本
4. sitemapLocation：用来指明 sitemap.json 的位置
#### project.config.json

project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：
 1. setting 中保存了编译相关的配置
 2. projectname 中保存的是项目名称
 3. appid 中保存的是小程序的账号 ID
#### sitemap.json

微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许微信索引。
当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。

>注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false,或者把sitemap.json中的rule.action改为 disallow

#### 页面的.json文件

小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖 app.json 的 window 中相同的配置项

#### 新建小程序页面

只需要在 app.json -> pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件

![[Pasted image 20250512140036.png]]
#### 修改项目首页

只需要调整 app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页面，当作项目首页进行渲染
### .wxml文件

WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的 HTML。
#### WXML 和 HTML 的区别

1. 标签名称不同
	1. HTML （div, span, img, a）
	2. WXML（view, text, image, navigator）
2. 属性节点不同
	1. `<a href="#">超链接</a>`
	2. `<navigator url="/pages/home/home"></navigator>`
3. 提供了类似于 Vue 中的模板语法
	1. 数据绑定
	2. 列表渲染
	3. 条件渲染
### .wxss文件

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。
#### WXSS 和 CSS 的区别
1. 新增了 rpx 尺寸单位
	1. CSS 中需要手动进行像素单位换算，例如 rem
	2. WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算
2. 提供了全局的样式和局部样式
	1. 项目根目录中的 app.wxss 会作用于所有小程序页面
	2. 局部页面的 .wxss 样式仅对当前页面生效
3. WXSS 仅支持部分 CSS 选择器
	1. .class 和 `#id`
	2. element
	3. 并集选择器、后代选择器
	4. ::after 和 ::before 等伪类选择器
### .js文件

在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户的点击、获取用户的位置等等。

小程序中的 JS 文件分为三大类，分别是：
- app.js
	- 是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序
- 页面的 .js 文件
	- 是页面的入口文件，通过调用 Page() 函数来创建并运行页面
- 普通的 .js 文件
	- 是普通的功能模块文件，用来封装公共的函数或属性供页面使用
## 小程序的宿主环境

宿主环境（host environment）指的是程序运行所必须的依赖环境。

手机微信是小程序的宿主环境
小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能，例如：微信扫码、微信支付、微信登录、地理定位、etc…

小程序宿主环境主要包含以下四部分内容
1. 通信模型
2. 运行机制
3. 组件
4. API
### 通信模型
#### 通信的主体

小程序中通信的主体是渲染层和逻辑层，其中：
- WXML 模板和 WXSS 样式工作在渲染层
- JS 脚本工作在逻辑层

![[Pasted image 20250512142031.png]]

#### 小程序的通信模型

小程序中的通信模型分为两部分：
 - 渲染层和逻辑层之间的通信由微信客户端进行转发
 - 逻辑层和第三方服务器之间的通信由微信客户端进行转发
 
![[Pasted image 20250512142203.png]]
### 运行机制
#### 小程序启动的过程

1. 把小程序的代码包下载到本地
2. 解析 app.json 全局配置文件
3. 执行 app.js 小程序入口文件，调用 App() 创建小程序实例
4. 渲染小程序首页
5. 小程序启动完成
#### 页面渲染的过程

1. 加载解析页面的 .json 配置文件
2. 加载页面的 .wxml 模板和 .wxss 样式
3. 执行页面的 .js 文件，调用 Page() 创建页面实例
4. 页面渲染完成
### 组件

小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组件分为了 9 大类，分别是：
1. **视图容器**
2. **基础内容**
3. **表单组件**
4. **导航组件**
5. 媒体组件
6. map 地图组件
7. canvas 画布组件
8. 开放能力
9. 无障碍访问
#### 视图容器类
1. view
	- 普通视图区域
	- 类似于 HTML 中的 div，是一个块级元素
	- 常用来实现页面的布局效果![[Pasted image 20250512143302.png]]
2. scroll-view
	- 可滚动的视图区域
	- 常用来实现**滚动列表**效果![[Pasted image 20250512144202.png]]
	- ==scroll-x/y 有一个属性为bool,可以不写但是不要留空,留空为false属性不生效==
3. swiper 和 swiper-item
	- 轮播图容器组件 和 轮播图 item 组件![[Pasted image 20250512145053.png]]
	- swiper 组件的常用属性![[Pasted image 20250512150050.png]]
#### 基础内容组件

1. text
	- 文本组件
	- 类似于 HTML 中的 span 标签，是一个行内元素
	- text 组件的 selectable 属性可以实现长按选中文本内容的效果![[Pasted image 20250512151735.png]]
2. rich-text
	- 富文本组件
	- 支持把 HTML 字符串渲染为 WXML 结构
	- 可以写成单标签也可以写双标签
	- rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构![[Pasted image 20250512151706.png]]
#### 其他常用组件

1. button
	- 按钮组件
	- 功能比 HTML 中的 button 按钮丰富
	- 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）![[Pasted image 20250512153130.png]]
2. image
	- 图片组件
	- image 组件默认宽度约 300px、高度约 240px
	- image 组件的 mode 属性用来指定图片的裁剪和缩放模式，常用的 mode 属性值如下：![[Pasted image 20250512153847.png]]
3. navigator
	- 页面导航组件
	- 类似于 HTML 中的 a 链接
### API
小程序官方把 API 分为了如下 3 大类：
1. 事件监听 API
	- 特点：以 on 开头，用来监听某些事件的触发
	- 举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件
2. 同步 API
	- 特点1：以 Sync 结尾的 API 都是同步 API
	- 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
	- 举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容
3. 异步 API
	- 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果
	- 举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据
## 模版与配置
### 数据绑定

数据绑定的基本原则:
1. 在 data 中定义数据
2. 在 WXML 中使用数据
在页面对应的 .js 文件中，把数据定义到 data 对象中即可：

![[Pasted image 20250512154842.png]]

把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。语法格式为： 

![[Pasted image 20250512154914.png]]

>微信小程序的框架中数据绑定可以直接绑定属性值
![[Pasted image 20250512155117.png]]
![[Pasted image 20250512155124.png]]
### 事件绑定

事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理

![[Pasted image 20250512155155.png]]

#### 常用事件

![[Pasted image 20250512155315.png]]

当事件回调触发的时候，会收到一个事件对象 event，它的详细属性如下表所示：

![[Pasted image 20250512155358.png]]

**target 和 currentTarget 的区别:**

target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件。举例如下：

![[Pasted image 20250512155702.png]]

点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层 view 的 tap 事件处理函数。此时，对于外层的 view 来说：
- e.target 指向的是触发事件的源头组件，因此，e.target 是内部的按钮组件
- e.currentTarget 指向的是当前正在触发事件的那个组件，因此，e.currentTarget 是当前的 view 组件
#### bindtap

在小程序中，不存在 HTML 中的 onclick 鼠标点击事件，而是通过 tap 事件来响应用户的触摸行为。
1. 通过 bindtap，可以为组件绑定 tap 触摸事件，语法如下：

*![[Pasted image 20250512155953.png]]*

2. 在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event（一般简写成 e） 来接收：

![[Pasted image 20250512160006.png]]

通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，示例如下：

![[Pasted image 20250512160132.png]]
小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能正常工作：![[Pasted image 20250512160209.png]]
因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123) 的事件处理函数。

可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字，示例代码如下：

![[Pasted image 20250512162500.png]]

最终info 会被解析为参数的名字,数值 2 会被解析为参数的值,在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值，示例代码如下：
![[Pasted image 20250512163407.png]]
#### bindinput

在小程序中，通过 input 事件来响应文本框的输入事件，语法格式如下：
1. 通过 bindinput，可以为文本框绑定输入事件：
![[Pasted image 20250512163453.png]]
2. 在页面的 .js 文件中定义事件处理函数：
![[Pasted image 20250512163528.png]]
### 条件渲染
#### wx:if

在小程序中，使用 wx:if="{{condition}}" 来判断是否需要渲染该代码块：
![[Pasted image 20250512163814.png]]
也可以用 wx:elif 和 wx:else 来添加 else 判断：
![[Pasted image 20250512163828.png]]
#### block

如果要一次性控制多个组件的展示与隐藏，可以使用一个 <block></block> 标签将多个组件包装起来，并在`<block>` 标签上使用 wx:if 控制属性，示例如下：
![[Pasted image 20250512163907.png]]
>`<block>` 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。
#### hidden

在小程序中，直接使用 hidden="{{ condition }}" 也能控制元素的显示与隐藏：
![[Pasted image 20250512170941.png]]
**与wx:if的区别:**(类似v-if和v-show的区别)
1. 运行方式不同
	- wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏
	-  hidden 以切换样式的方式（display: none/block;），控制元素的显示与隐藏
2. 使用建议
	-  频繁切换时，建议使用 hidden
	- 控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换
#### wx:for

通过 wx:for 可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：
![[Pasted image 20250512171208.png]]
默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。(即无需额外声明),但是也可以手动指定索引和当前项的变量名
 
- 使用 wx:for-index 可以指定当前循环项的索引的变量名
-  使用 wx:for-item 可以指定当前项的变量名
![[Pasted image 20250512171441.png]]
#### wx:key

类似于 Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值，从而提高渲染的效率，示例代码如下：
![[Pasted image 20250512171524.png]]
### WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。与 CSS 相比，WXSS 扩展的特性有：
 1. rpx 尺寸单位
 2. @import 样式导入
![[Pasted image 20250513100615.png]]
#### rpx

rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。

rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）。
在较小的设备上，1rpx 所代表的宽度较小
在较大的设备上，1rpx 所代表的宽度较大

小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配
#### 样式导入

使用 WXSS 提供的 @import 语法，可以导入外联的样式表。@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下：
![[Pasted image 20250513100929.png]]
#### 全局样式和局部样式

定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在页面的 .wxss 文件中定义的样式为局部样式，只作用于当前页面。

- 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式
- 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式
### 全局配置
#### 全局配置文件及常用的配置项

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下：
 1. pages: 记录当前小程序所有页面的存放路径
 2. window: 全局设置小程序窗口的外观
 3. tabBar: 设置小程序底部的  tabBar 效果
 4. style: 是否启用新版的组件样式
>小程序窗口的组成![[Pasted image 20250513101415.png]]
#### window 节点常用的配置项

![[Pasted image 20250513101544.png]]

**上拉触底**:

上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。
>默认距离为50px，如果没有特殊需求，建议使用默认值即可。
#### tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为：底部 tabBar和顶部 tabBar

![[Pasted image 20250513102043.png]]
##### tabBar的六个组成部分
![[Pasted image 20250513102213.png]]
![[Pasted image 20250513102237.png]]
![[Pasted image 20250513102341.png]]
### 页面配置

小程序中，每个页面都有自己的 .json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置。

**常用配置项**:
![[Pasted image 20250513102726.png]]
### 网络数据请求
出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：
1. 只能请求 HTTPS 类型的接口
2. 必须将接口的域名添加到信任列表中
![[Pasted image 20250513103101.png]]
#### 发送请求
- GET
调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下：
![[Pasted image 20250513103212.png]]
- POST
调用微信小程序提供的 wx.request() 方法，可以发起 POST 数据请求，示例代码如下：
![[Pasted image 20250513103241.png]]
#### 在页面刚加载时请求数据
在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件中调用获取数据的函数，示例代码如下：
![[Pasted image 20250513103417.png]]
#### 跨域问题
跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小程序中不存在跨域的问题。
Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象，由于小程序的宿主环境是微信客户端，所以小程序中不能叫做“发起 Ajax 请求”，而是叫做“发起网络数据请求”。
## 视图与逻辑
### 页面导航

页面导航指的是页面之间的相互跳转。例如，浏览器中实现页面导航的方式有如下两种：
1. `<a>` 链接
2. location.href
小程序中实现页面导航的两种方式:
- 声明式导航: 在页面上声明一个 `<navigator>` 导航组件,通过点击 `<navigator>` 组件实现页面跳转
- 编程式导航: 调用小程序的导航 API，实现页面的跳转
#### 声明式导航
##### 导航到tabBar页面
tabBar 页面指的是被配置为 tabBar 的页面。(即被配置到tabBar中的页面)
在使用 `<navigator>` 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中：
- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 switchTab
示例代码如下：
![[Pasted image 20250513104456.png]]
##### 导航到非 tabBar 页面
非 tabBar 页面指的是没有被配置为 tabBar 的页面。
在使用 `<navigator>` 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：
- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 navigate
![[Pasted image 20250513104532.png]]
>为了简便，在导航到非 tabBar 页面时，open-type="navigate" 属性可以省略。
##### 后退导航
如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：
 - open-type 的值必须是 navigateBack，表示要进行后退导航
 - delta 的值必须是数字，表示要后退的层级
示例代码如下：
![[Pasted image 20250513104618.png]]
>为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。
#### 编程式导航
##### 导航到tabBar页面
调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下
![[Pasted image 20250513104709.png]]
![[Pasted image 20250513111458.png]]
##### 导航到非 tabBar 页面

调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：

![[Pasted image 20250513111600.png]]
![[Pasted image 20250513111614.png]]
##### 后退导航

调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的属性列表如下：

![[Pasted image 20250513111640.png]]![[Pasted image 20250513111645.png]]
#### 导航传参

跳转时的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：
 - 参数与路径之间使用 ? 分隔
 - 参数键与参数值用 = 相连
 - 不同参数用 & 分隔
代码示例如下：(编程式也是拼接在url后即可)
![[Pasted image 20250513111741.png]]

**在onLand中接收导航参数**:
通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到，示例代码如下
![[Pasted image 20250513112020.png]]
### 页面事件
#### 下拉刷新事件

启用下拉刷新有两种方式：
1. 全局开启下拉刷新: 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true
2. 局部开启下拉刷新: 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true

在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。
##### 监听页面的下拉刷新事件

在页面的 .js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。
![[Pasted image 20250513112442.png]]
##### 停止下拉刷新的效果

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉刷新的 loading 效果。此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。示例代码如下：
![[Pasted image 20250513112805.png]]
#### 上拉触底事件

在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。示例代码如下：
![[Pasted image 20250513112900.png]]
### 生命周期

生命周期（Life Cycle）是指一个对象从创建 -> 运行 -> 销毁的整个阶段，强调的是一个时间段。我们可以把每个小程序运行的过程，也概括为生命周期：
- 小程序的启动，表示生命周期的开始
- 小程序的关闭，表示生命周期的结束
- 中间小程序运行的过程，就是小程序的生命周期
#### 生命周期的分类

在小程序中，生命周期分为两类，分别是：
1.  **应用生命周期**: 特指小程序从启动 -> 运行 -> 销毁的过程
2. **页面生命周期**: 特指小程序中，每个页面的加载 -> 渲染 -> 销毁的过程

其中，页面的生命周期范围较小，应用程序的生命周期范围较大，如图所示：
![[Pasted image 20250513113242.png]]
#### 生命周期函数

生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。

生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在 onLoad 生命周期函数中初始化页面的数据。

>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。

小程序中的生命周期函数分为两类，分别是：
1. 应用的生命周期函数: 特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数
2. 页面的生命周期函数: 特指小程序中，每个页面从加载 -> 渲染 -> 销毁期间依次调用的那些函数

小程序的应用生命周期函数需要在 app.js 中进行声明，示例代码如下：
![[Pasted image 20250513113425.png]]
小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下：
![[Pasted image 20250513113434.png]]
### WXS脚本

WXS（WeiXin Script）是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。之所以存在WXS是因为wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。小程序中 wxs 的典型应用场景就是“过滤器”。

>虽然 wxs 的语法类似于 JavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：
1. wxs 有自己的数据类型
	- number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、 function 函数类型、array 数组类型、==date 日期类型、regexp 正则==
2. wxs 不支持类似于 ES6 及以上的语法形式
	-  不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc...
	-  支持：var 定义变量、普通 function 函数等类似于 ES5 的语法
3. wxs 遵循 CommonJS 规范
	-  module 对象
	-  require() 函数
	-  module.exports 对象
#### 基础语法
##### 内联
wxs 代码可以编写在 wxml 文件中的 `<wxs>` 标签内，就像 Javascript 代码可以编写在 html 文件中的 `<script>` 标签内一样。
wxml 文件中的每个 `<wxs></wxs>` 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员：
![[Pasted image 20250513114357.png]]
##### 外联

wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中一样。示例代码如下：
![[Pasted image 20250513114552.png]]在 wxml 中引入外联的 wxs 脚本时，必须为 `<wxs>` 标签添加 module 和 src 属性，其中：
 - module 用来指定模块的名称
 - src 用来指定要引入的脚本的路径，且==必须是相对路径==
示例代码如下：
![[Pasted image 20250513114649.png]]
##### 与js的区别

1. 不能作为组件的事件回调
wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如：
![[Pasted image 20250513114758.png]]但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的：
![[Pasted image 20250513114806.png]]
2. 隔离性
隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：
- wxs 不能调用 js 中定义的函数
- wxs 不能调用小程序提供的 API
## 进阶
### 自定义组件
#### 创建组件

在项目的根目录中，鼠标右键，创建 components -> test 文件夹
在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component”
键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss

>注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中
#### 引用组件

组件的引用方式分为“局部引用”和“全局引用”，顾名思义：
- 局部引用：组件只能在当前被引用的页面内使用
- 全局引用：组件可以在每个小程序页面中使用

在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：
![[Pasted image 20250513115457.png]]
在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：
![[Pasted image 20250513115518.png]]
#### 组件和页面的区别

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：
- 组件的 .json 文件中需要声明 "component": true 属性
- 组件的 .js 文件中调用的是 Component() 函数
- 组件的事件处理函数需要定义到 methods 节点中
#### 样式
##### 组件样式隔离

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：
- 组件 A 的样式不会影响组件 C 的样式
- 组件 A 的样式不会影响小程序页面的样式
- 小程序页面的样式不会影响组件 A 和 C 的样式
好处：
- 防止外界的样式影响组件内部的样式
- 防止组件的样式破坏外界的样式
![[Pasted image 20250513115828.png]]
>app.wxss 中的全局样式对组件无效
>只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响
>建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！
##### 修改组件的样式隔离选项

默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项，用法如下：
![[Pasted image 20250513120043.png]]
styleIsolation 的可选值:
![[Pasted image 20250513120117.png]]

