## 父子通讯传递路径无法正确解析
父组件传下来的只是一个字符串,到了子组件中用 : 动态解析不出来,正常的img src=<字符串>能够生效是因为打包工具进行了处理,但是这样动态解析的字符串不会由打包工具处理,所以需要自己转为URL,可以给出如下计算方法
```js
<script setup>
// ... existing code ...

// 添加一个计算属性来处理图片路径
import { computed } from 'vue'

// 处理图片路径的计算属性
const imageUrl = computed(() => {
  // 检查是否是相对路径，如果是则使用 new URL 处理
  if (props.image && props.image.startsWith('../')) {
    try {
      // 使用 import.meta.url 来构建正确的路径
      return new URL(props.image, import.meta.url).href
    } catch (e) {
      console.error('图片路径解析错误:', e)
      return props.image
    }
  }
  return props.image
})
</script>

<template>
  <div class="item" @click="$router.push(props.url)">
    <div class="icon">
      <!-- 使用处理后的图片路径 -->
      <img :src="imageUrl" alt="">
      <!-- 可以保留或删除这行静态图片 -->
      <img src="../assets/doctorpic/3.jpeg" alt></img>
    </div>
    <!-- ... existing code ... -->
  </div>
</template>
```
## 列表在渲染时直接滚动到底部
```js
content.value.scrollTop = content.value.scrollHeight
//or
  content.value.scrollTo({
    top: content.value.scrollHeight,
    behavior: 'smooth', //平滑滚动
  })
```
scrollTop 和 scrollHeight 是 JavaScript 中 DOM 元素的两个重要属性，用于控制和获取元素的滚动状态。
**scrollTop**
- 含义 ： scrollTop 表示元素内容相对于元素顶部滚动的像素数。
- 作用 ：通过设置元素的 scrollTop 值，可以控制元素内容的滚动位置。
- 默认值 ：初始状态下， scrollTop 为 0，表示内容没有向上滚动。
**scrollHeight**
- 含义 ： scrollHeight 表示元素内容的总高度，包括由于溢出而不可见的部分。
- 作用 ：它反映了元素内部所有内容的完整高度，不管当前是否可见。
- 计算方式 ：对于文本元素， scrollHeight 等于所有内容行的总高度加上内边距，但不包括边框和外边距。
## 解析md
安装依赖
```shell
pnpm add marked
```
调用parse方法并把内容作为v-html的内容放入
```js
const messageContent = computed(() => {
  const content = chatStore.aiMsg || ''
  return marked.parse(content)
})
```
## 定时器返回的ID
在ts中,可以把定时器返回的id显示转为number,因为不同浏览器对定时器id的处理可能不同,而且在某些TypeScript配置下，TypeScript编译器可能会将 setTimeout() 的返回值视为 NodeJS.Timeout 或其他非数字类型,这样就可以保证兼容性



          
我需要搜索市场上成熟的"记住我"功能处理方案，包括主流框架和库的最佳实践。
        
            
toolName: web_search
            
status: success
          
query: 前端 记住我功能 成熟方案 localStorage sessionStorage token 安全
          

## "记住我"实现方案

市场上处理"记住我"功能的成熟方案主要围绕以下几种存储方式：

| 存储方案 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| localStorage | 简单易用、跨会话持久化、容量较大(约5MB) | 易受XSS攻击、同步阻塞操作、明文存储 | 非敏感数据的长期存储 |
| sessionStorage | 会话结束自动清除、相对安全 | 标签页关闭后丢失数据、仍有XSS风险 | 临时会话数据、一次性认证信息 |
| Cookie | 可设置HttpOnly防止XSS、支持CSRF保护 | 存储容量小(约4KB)、每次请求都会发送 | 需要服务端参与的认证场景 |
| IndexedDB | 大容量、异步操作不阻塞主线程、支持复杂查询 | API相对复杂、兼容性问题 | 需要存储大量结构化数据的场景 |
### 1. HttpOnly Cookie方案（最推荐）

这是当前业界公认的最安全方案，特别适用于需要较高安全性的应用：

- **核心原理**：将token存储在设置了HttpOnly、Secure和SameSite属性的Cookie中
- **安全特性**：
  - HttpOnly防止JavaScript访问，有效抵御XSS攻击
  - Secure确保只通过HTTPS传输
  - SameSite限制跨站请求，防止CSRF攻击
- **实现方式**：
  ```javascript
  // 后端设置Cookie
  res.cookie('token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: rememberMe ? 60 * 60 * 24 * 30 * 1000 : 60 * 60 * 24 * 1000
  });
  ```

### 2. 双Token机制

为平衡安全性和用户体验，许多成熟应用采用双Token机制：

- **accessToken**：短期令牌（如15分钟），存储在内存或sessionStorage中，用于API请求
- **refreshToken**：长期令牌（如30天），存储在HttpOnly Cookie中，用于刷新accessToken
- **工作流程**：
  1. 用户勾选"记住我"登录成功后，服务端返回accessToken和refreshToken
  2. accessToken过期时，前端使用refreshToken自动获取新的accessToken
  3. 关闭浏览器后，accessToken自动失效，但refreshToken仍有效（如果用户选择了"记住我"）

### 3. localStorage/SessionStorage方案（需增强安全性）

如果必须使用localStorage或sessionStorage，应采取以下安全增强措施：

- **数据加密**：对敏感信息进行加密后再存储
  ```javascript
  // 使用加密库如crypto-js
  import CryptoJS from 'crypto-js';
  
  const encryptToken = (token) => {
    const secretKey = 'your-secret-key'; // 实际应用中应使用更安全的密钥管理
    return CryptoJS.AES.encrypt(token, secretKey).toString();
  };
  
  const decryptToken = (encryptedToken) => {
    const secretKey = 'your-secret-key';
    const bytes = CryptoJS.AES.decrypt(encryptedToken, secretKey);
    return bytes.toString(CryptoJS.enc.Utf8);
  };
  ```

- **实现自动过期机制**：
  ```javascript
  const tokenManager = {
    setToken(token, rememberMe) {
      const storage = rememberMe ? localStorage : sessionStorage;
      storage.setItem('token', {
        value: token,
        timestamp: Date.now(),
        expiresIn: rememberMe ? 30 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000
      });
    },
    
    getToken() {
      const tokenObj = JSON.parse(localStorage.getItem('token') || sessionStorage.getItem('token'));
      if (!tokenObj) return null;
      
      // 检查是否过期
      if (Date.now() - tokenObj.timestamp > tokenObj.expiresIn) {
        localStorage.removeItem('token');
        sessionStorage.removeItem('token');
        return null;
      }
      
      return tokenObj.value;
    }
  };
  ```

### 4. 状态管理与存储结合方案

现代前端框架（如Vue、React）常结合状态管理库（Pinia、Redux）实现更完善的方案：

- **内存状态**：使用store保存当前认证状态，提高访问效率
- **持久化层**：根据"记住我"选项选择合适的存储方式
- **统一接口**：提供统一的认证状态管理接口，屏蔽底层实现差异

```javascript
// Vue 3 + Pinia 示例
import { defineStore } from 'pinia';
import { ref, computed, onMounted } from 'vue';
import { useRouter } from 'vue-router';

export const useAuthStore = defineStore('auth', () => {
  const router = useRouter();
  const token = ref(null);
  const userInfo = ref(null);
  const rememberMe = ref(false);
  
  // 初始化时从存储中恢复状态
  onMounted(() => {
    const remember = localStorage.getItem('remember') === 'true';
    const storage = remember ? localStorage : sessionStorage;
    const savedToken = storage.getItem('token');
    const savedUser = storage.getItem('userInfo');
    
    if (savedToken) {
      token.value = savedToken;
      userInfo.value = savedUser ? JSON.parse(savedUser) : null;
      rememberMe.value = remember;
    }
  });
  
  // 登录方法
  async function login(credentials, remember) {
    // 调用登录API
    const response = await api.login(credentials);
    
    // 更新状态
    token.value = response.token;
    userInfo.value = response.userInfo;
    rememberMe.value = remember;
    
    // 持久化存储
    localStorage.setItem('remember', String(remember));
    const storage = remember ? localStorage : sessionStorage;
    storage.setItem('token', response.token);
    storage.setItem('userInfo', JSON.stringify(response.userInfo));
    
    return response;
  }
  
  // 登出方法
  function logout() {
    token.value = null;
    userInfo.value = null;
    
    // 清除存储
    localStorage.removeItem('remember');
    localStorage.removeItem('token');
    localStorage.removeItem('userInfo');
    sessionStorage.removeItem('token');
    sessionStorage.removeItem('userInfo');
    
    router.push('/login');
  }
  
  // 计算属性：是否已认证
  const isAuthenticated = computed(() => !!token.value);
  
  return {
    token,
    userInfo,
    rememberMe,
    isAuthenticated,
    login,
    logout
  };
});
```

### 最佳实践建议

根据市场上成熟方案的综合分析，推荐以下最佳实践：

1. **优先选择HttpOnly Cookie方案**：这是当前安全性最高的方案，特别适合对安全性要求较高的应用

2. **实现双Token机制**：结合短期访问令牌和长期刷新令牌，平衡安全性和用户体验

3. **使用HTTPS**：无论采用哪种存储方案，都必须使用HTTPS保护数据传输安全

4. **添加适当的过期机制**：为所有认证信息设置合理的过期时间，避免永久有效

5. **服务端验证**：前端的存储和验证只是提升用户体验，最终的安全验证必须在服务端完成

6. **考虑使用专业认证库**：对于复杂应用，可以考虑使用如Auth0、Firebase Authentication等成熟的认证服务

7. **定期清理过期数据**：实现机制定期检查并清理过期的认证信息

这些成熟方案可以根据应用的具体需求和安全级别进行选择和组合，关键是要在安全性和用户体验之间找到合适的平衡点。
### 异步加载CSS

在`CSS`文件请求、下载、解析完成之前，`CSS`会阻塞渲染，浏览器将不会渲染任何已处理的内容

我们可以为首页的主要内容使用行内css,这样浏览器在下载完html之后就可以立刻渲染页面内容

使用内联css后，后面的外部引用`css`则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：

- 使用javascript将link标签插到head标签最后

```js
// 创建link标签
const myCSS = document.createElement( "link" );
myCSS.rel = "stylesheet";
myCSS.href = "mystyles.css";
// 插入到header的最后位置
document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );
```

- 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将`media`的值设为`screen`或`all`，从而让浏览器开始解析CSS

```html
<link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'">
```

- 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet

```html
<link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'">
```
## 动态css
### 1. 计算属性方式

**优点：**
- 可维护性高 ：样式逻辑集中在一个地方，易于理解和维护
- 响应式 ：当props变化时，样式会自动更新
- 类型安全 ：在TypeScript项目中提供更好的类型检查
- 可复用 ：可以在多个地方使用相同的样式逻辑
### 2. 内联对象方式
```vue
<div ref="containerRef" :style="{ height: height ? `${height}px` : 'auto', 
overflow: 'auto' }"></div>
```
适用场景 ：样式逻辑简单，仅在一处使用时
### 3. 样式属性绑定
```vue
<div ref="containerRef" :style="{ height: `${height}px` }" style="overflow: auto;
"></div>
```
适用场景 ：混合使用静态和动态样式时
### 4. CSS变量方式
```vue
<script setup>
import { ref, watch } from 'vue'
const props = defineProps({
  height: Number
})
const containerRef = ref(null)

// 通过CSS变量设置动态样式
watch(() => props.height, (newHeight) => {
  if (containerRef.value) {
    containerRef.value.style.setProperty('--container-height', newHeight ? `$
    {newHeight}px` : 'auto')
  }
}, { immediate: true })
</script>

<style scoped>
:deep(.container) {
  height: var(--container-height, auto);
  overflow: auto;
}
</style>
```
适用场景 ：
- 需要在CSS中复杂使用动态值（如动画、渐变等）
- 需要在子组件中继承或修改这些变量
- 样式需要在多个元素间共享
## 文字溢出省略
### 单行
- text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本
- white-space：设置文字在一行显示，不能换行
- overflow：文字长度超出限定宽度，则隐藏超出的内容

`overflow`设为`hidden`，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略

`white-space:nowrap`，作用是设置文本不换行，是`overflow:hidden`和`text-overflow：ellipsis`生效的基础

`text-overflow`属性值有如下：

- clip：当对象内文本溢出部分裁切掉
- ellipsis：当对象内文本溢出时显示省略标记（...）

==`text-overflow`只有在设置了`overflow:hidden`和`white-space:nowrap`才能够生效的==
```html
<style>
    p{
        overflow: hidden;
        line-height: 40px;
        width:400px;
        height:40px;
        border:1px solid red;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
</style>
<p> 这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</p >
```
### 多行
多行文本溢出的时候，我们可以分为两种情况：
- 基于高度截断
- 基于行数截断
#### 基于高度截断
**伪元素+定位**
核心的`css`代码结构如下：

- position: relative：为伪元素绝对定位
- overflow: hidden：文本溢出限定的宽度就隐藏内容）
- position: absolute：给省略号绝对定位
- line-height: 20px：结合元素高度,高度固定的情况下,设定行高, 控制显示行数
- height: 40px：设定当前元素高度
- ::after {} ：设置省略号样式

代码如下所示：
```html
<style>
    .demo {
        position: relative;
        line-height: 20px;
        height: 40px;
        overflow: hidden;
    }
    .demo::after {
        content: "...";
        position: absolute;
        bottom: 0;
        right: 0;
        padding: 0 20px 0 10px;
    }
</style>

<body>
    <div class='demo'>这是一段很长的文本</div>
</body>
```
实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 `overflow: hidden` 隐藏多余文字
