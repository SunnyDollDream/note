## 变量提升
```js
function sayHi() {
  console.log(name) // undefined
  console.log(age) // ReferenceError
  var name = 'Lydia'
  let age = 21
}

sayHi()
```
在函数内部，我们首先通过 `var` 关键字声明了 `name` 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），==直到程序运行到定义变量位置之前默认值都是 `undefined`==。因为当我们打印 `name` 变量时还没有执行到定义变量的位置，因此变量的值保持为 `undefined`。

通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们==不会被初始化==。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为==暂时性死区==。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。
## RESTful API 的设计原则是什么？
RESTful API 的设计原则包括：
1. 资源导向：使用 URL 表示资源，HTTP 方法（GET、POST、PUT、DELETE）表示操作。
2. 无状态：每个请求都应包含所有必要的信息，服务器不应存储客户端状态。
3. 可缓存：响应应标记为可缓存，以提高性能。
## 字符串不可变的好处
1. 安全性
	- 不可变对象在多线程环境中更安全（虽然JS是单线程）
	- 防止意外的数据修改
	- 在函数间传递字符串时不用担心被修改
2. 性能优化
```js
let str1 = "Hello";
let str2 = "Hello";

// 由于字符串不可变，引擎可以优化内存使用
// str1 和 str2 可能指向内存中的同一个字符串
console.log(str1 === str2); // true
```
3. 哈希表键的稳定性
	- 字符串常用作对象的键
	- 不可变性确保键的哈希值不会改变
4. 简化实现和调试
	- 行为更可预测
	- 调试时值不会意外改变
## null和undefined的区别

| 特性         | undefined        | null            |
| ---------- | ---------------- | --------------- |
| **类型**     | 一个类型（Undefined）  | 一个值（属于Object类型） |
| **含义**     | 变量已声明但未赋值        | 表示空值或空对象引用      |
| **typeof** | "undefined"      | "object"        |
| **数字转换**   | NaN              | 0               |
| **默认行为**   | JavaScript引擎自动赋值 | 需要显式赋值          |
函数参数未提供,访问不存在的对象属性时结果都是undefined
而除了Dom查询不存在的元素时会返回null,其他的null一般都是显示赋值的,如用于清空引用,手动返回明确表示空结果
**语义上**:
- `undefined` → "这里应该有值，但还没有"
- `null` → "这里应该没有值，我明确设置了空"
## ??和||的区别
??只检查null和undefined,而||还会将0,false和''(空串)判为无效
## 字符串取子串方法的区别
### slice(start,end)
>支持负数索引(从-1开始,同样左闭右开)
>start > end，返回空字符串
```js
let str = "Hello World";

// 基本用法
console.log(str.slice(0, 5));     // "Hello"
console.log(str.slice(6));        // "World" (从索引6到末尾)
console.log(str.slice(6, 11));    // "World"

// 支持负数索引（从末尾开始计算）
console.log(str.slice(-5));       // "World" (最后5个字符)
console.log(str.slice(0, -6));    // "Hello" (从开始到倒数第6个字符)
console.log(str.slice(-11, -6));  // "Hello"

// 如果start > end，返回空字符串
console.log(str.slice(5, 2));     // ""
```
### substr(start,end)(已废弃)
>start>end会自动交换而不是返回空串
>负参数会被视为0
```js
let str = "Hello World";

// 基本用法
console.log(str.substring(0, 5));     // "Hello"
console.log(str.substring(6));        // "World"
console.log(str.substring(6, 11));    // "World"

// 自动交换参数（如果start > end）
console.log(str.substring(5, 2));     // "llo" (自动交换为2,5)

// 负数参数会被视为0
console.log(str.substring(-3, 5));    // "Hello" (-3被视为0)
console.log(str.substring(2, -3));    // "He" (自动交换为0,2)
```
### substring(start,length)
>支持负数索引(从-1开始)
>负数长度返回空串
```js
let str = "Hello World";

// 基本用法
console.log(str.substr(0, 5));     // "Hello"
console.log(str.substr(6));        // "World" (从索引6到末尾)
console.log(str.substr(6, 5));     // "World"

// 支持负数start（从末尾开始计算）
console.log(str.substr(-5));       // "World" (最后5个字符)
console.log(str.substr(-5, 3));    // "Wor" (从倒数第5个开始取3个字符)

// 负数length返回空字符串
console.log(str.substr(2, -3));    // ""
```
## 会自动转化为flase的值
- undefined
- null
- false
- +0
- -0
- NaN
其余情况都会转化为true
## 手写深拷贝
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```
## new的原理
当你使用 `new` 调用函数时，JavaScript引擎会执行以下4个步骤：
1. 创建一个新对象
```js
// 内部创建一个空对象
const obj = {};
```
2. 设置原型链
```js
// 将新对象的原型指向构造函数的prototype属性
obj.__proto__ = Constructor.prototype;
```
3. 执行构造函数
```js
// 将构造函数的作用域赋给新对象（this指向新对象）
const result = Constructor.apply(obj, arguments);
```
4. 返回新对象
```js
// 如果构造函数没有返回对象，则返回新创建的对象
if (typeof result === 'object' && result !== null) {
    return result;
} else {
    return obj;
}
```
## 手写new运算符
我们可以手动实现一个 `myNew` 函数来模拟 `new` 的行为：
```js
function myNew(Constructor, ...args) {
    // 步骤1：创建新对象
    const obj = {};
    
    // 步骤2：设置原型链
    Object.setPrototypeOf(obj, Constructor.prototype);
    
    // 步骤3：执行构造函数，绑定this
    const result = Constructor.apply(obj, args);
    
    // 步骤4：返回结果
    return result instanceof Object ? result : obj;
}

// 使用示例
function Car(brand) {
    this.brand = brand;
}

Car.prototype.getBrand = function() {
    return this.brand;
};

const myCar = myNew(Car, 'Toyota');
console.log(myCar.getBrand()); // 'Toyota'
console.log(myCar instanceof Car); // true
```

## 事件循环
### 异步的原理
 浏览器不仅有多个线程，还有多个进程，如渲染进程、GPU 进程和插件进程等。而每个 tab 标签页都是一个独立的渲染进程，所以一个 tab 异常崩溃后，其他 tab 基本不会被影响。
 ![[Pasted image 20251013220628.png]]
 作为前端开发者，主要重点关注其渲染进程，渲染进程下包含了 JS 引擎线程、HTTP 请求线程和定时器线程,事件触发线程,GUI线程，这些线程为 JS 在浏览器中完成异步任务提供了基础。
 ![[Pasted image 20251013220638.png]]
 浏览器异步任务的执行原理背后其实是一套事件驱动的机制。事件驱动简而言之就是由特定的事件来触发特定的任务，这里的事件可以是用户的操作触发的，如 click 事件；也可以是程序自动触发的，比如浏览器中定时器线程在计时结束后会触发定时器事件。而事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。
### 事件循环
 JS 在解析一段代码时，会将同步代码按顺序排在执行栈中，然后依次执行里面的函数。当遇到异步任务时就交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出==已完成的异步任务的回调==加入执行栈继续执行，遇到异步任务时又交给其他线程，.....，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。
 ![[Pasted image 20251013220653.png]]
 可见，在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。
#### 宏任务和微任务
任务队列不只一个，根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。
事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。

| 宏任务            | 微任务                        |
| -------------- | -------------------------- |
| setTimeout()   | promise.then,promise.catch |
| setInterval()  | new MutaionObserver()      |
| setImmediate() | process.nextTick()         |
```js
console.log('同步代码1');

setTimeout(() => {

    console.log('setTimeout')

}, 0)

new Promise((resolve) => {

  console.log('同步代码2')

  resolve()

}).then(() => {

    console.log('promise.then')

})

console.log('同步代码3');

// 最终输出"同步代码1"、"同步代码2"、"同步代码3"、"promise.then"、"setTimeout"
```
![[263f472e6e8fb39cf42349634431056e 1.gif]]
**区别**
我们已经知道，JS 遇到异步任务时会将此任务交给其他线程去处理，自己的主线程继续往后执行同步任务。比如 setTimeout 的计时会由浏览器的定时器线程来处理，待计时结束，就将定时器==回调任务放入任务队列==等待主线程来取出执行。前面我们提到，因为 JS 是单线程执行的，所以要执行异步任务，就需要浏览器其他线程来辅助，即多线程是 JS 异步任务的一个明显特征。
我们再来分析下 promise.then（微任务）的处理。当执行到 promise.then 时，V8 引擎==不会将异步任务交给浏览器其他线程==，而是将回调==存在自己的一个队列中==，待当前执行栈执行完成后，立马去执行 promise.then 存放的队列，promise.then 微任务没有多线程参与，甚至从某些角度说，微任务都不能完全算是异步，它只是将书写时的代码修改了执行顺序而已。
setTimeout 有“定时等待”这个任务，需要定时器线程执行；ajax 请求有“发送请求”这个任务，需要 HTTP 线程执行，而 promise.then 它没有任何异步任务需要其他线程执行，它只有回调，即使有，也只是内部嵌套的另一个宏任务。
>宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。
>微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。
### 定时器误差
事件循环中，总是先执行同步代码后，才会去任务队列中取出异步回调来执行。当执行 setTimeout 时，浏览器启动新的线程去计时，计时结束后触发定时器事件将回调存入宏任务队列，等待 JS 主线程来取出执行。如果这时主线程还在执行同步任务的过程中，那么此时的宏任务就只有先挂起，这就造成了计时器不准确的问题。同步代码耗时越长，计时器的误差就越大。不仅同步代码，由于微任务会优先执行，所以微任务也会影响计时，假设同步代码中有一个死循环或者微任务中递归不断在启动其他微任务，那么宏任务里面的代码可能永远得不到执行。所以主线程代码的执行效率提升是一件很重要的事情。
![[Pasted image 20251013222341.png]]
一个很简单的场景就是我们界面上有一个时钟精确到秒，每秒更新一次时间。你会发现有时候秒数会直接跳过 2 秒间隔，就是这个原因。
### 视图更新渲染
微任务队列执行完成后，也就是一次事件循环结束后，浏览器会执行视图渲染，当然这里会有浏览器的优化，可能会合并多次循环的结果做一次视图重绘，因此视图更新是在事件循环之后，所以并不是每一次操作 Dom 都一定会立马刷新视图。视图重绘之前会先执行 requestAnimationFrame 回调，那么对于 requestAnimationFrame 是微任务还是宏任务是有争议的，在这里看来，它应该既不属于微任务，也不属于宏任务。
### NodeJS事件模型
在 NodeJS 中 JS 的执行，我们主要需要关心的过程分为以下几个阶段，下面每个阶段都有自己单独的任务队列，当执行到对应阶段时，就判断当前阶段的任务队列是否有需要处理的任务。
- timers 阶段：执行所有 setTimeout() 和 setInterval() 的回调。

- pending callbacks 阶段：某些系统操作的回调，如 TCP 链接错误。除 timers、close、setImmediate 的其他大部分回调在此阶段执行。

- poll 阶段：轮询等待新的链接和请求等事件，执行 I/O 回调等。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。

- check 阶段：setImmediate 回调函数执行。

- close callbacks 阶段：关闭回调执行，如 socket.on(‘close’, …)。
![[Pasted image 20251014163017.png]]
上面每个阶段都会去执行完当前阶段的任务队列，然后继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完了，才会进入下个阶段。
## 尾调用和尾递归
>[尾调用优化 - 阮一峰的网络日志](https://ruanyifeng.com/blog/2015/04/tail-call.html)
### 尾调用
[尾调用](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)（Tail Call）是函数式编程的一个重要概念,就是指某个函数的最后一步是调用另一个函数。
```js
function f(x) {
	return g(x)
}
```
上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。

以下两种情况，都不属于尾调用。
```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}
```
上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，==即使语义完全一样==。情况二也属于==调用后还有操作==，即使写在一行内。

尾调用不一定出现在函数尾部，只要==是最后一步操作==即可。
```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```
上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作.
### 尾调用优化
>也就是说,使用尾调用可以防止函数栈溢出,保证一个递归过程始终只占用一个函数栈的大小

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。

我们知道，函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88)（call stack）。
![[Pasted image 20251015233057.png]]
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```
上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。

这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
### 尾递归
>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
>`arguments`：返回调用时函数的参数。
>`func.caller`：返回调用当前函数的那个函数。
>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以==尾调用模式仅在严格模式下生效==。

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。
```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
```
上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。

如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。
```js
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
```
![[Pasted image 20251015233437.png]]
**递归函数改写为尾递归**
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？

两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。
```js
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
```
上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。

函数式编程有一个概念，叫做[柯里化](https://en.wikipedia.org/wiki/Currying)（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
```
上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。
第二种方法就简单多了，就是采用ES6的函数默认值。
```js
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```
上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持"尾调用优化"的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。
## GC
### 堆内存的组成
以最常用的V8引擎为例，堆内存中大致可以划分为：
- **新生代内存区（New Space / Young Generation）**
- **老生代内存区（Old Space / Old Generation）**
- 大对象区（Large Object Space）
- 映射区（Map Space）
- 代码区（Code Space）
- 其他区域
![[Pasted image 20251016000856.png]]
#### 新生代内存区（New Space / Young Generation）
- 存放存活时间短的小对象（如临时变量、局部对象）。
- **GC 触发条件：** From Space 分配满时触发 Scavenge 回收。
- 副垃圾回收器进行管理内存。
##### 结构
- 由大小相等的分配区（From Space）和存活区（To Space）构成。
    - From Space 为当前**活跃的分配区**，新对象在此创建；
    - To Space 是当前**闲置的回收区**，用于存储 GC 时存活的对象。
- **新生代内存区的特点：** 回收频率很高，速度很快，但是空间利用率很低，因为有一半的内存空间处于"闲置"状态。这里的“闲置”状态就是指 GC 触发时，占据新生代内存区一半空间的 To Space 处于临时闲置状态，准备要与 From Space 交替使用。
![[Pasted image 20251016001004.png]]
##### GC算法
- 新生代内存区采用 **Scavenge 算法**进行管理。
    - **GC 触发：** 新的对象会**优先分配**至 分配区（From Space），GC 触发时，From Space 中**存活的对象（仍被引用的对象）** 会被复制到 To Space 中，其引用地址也更新为新地址。而后**未被引用的对象**以及**被复制完的存活对象**则像垃圾一样被 GC 直接清除，其占据的空间也被一并释放，**整个 From Space** 都将被清空。
    - **GC 结束：** 分配区（From Space）和存活区（To Space）将会进行两极反转。**原来的 To Space**（其中存储着从上次GC中存活的对象）变为**新的 From Space**，等待新对象的到来，而**原来的 From Space**（已在GC中被清空）变为**新的 To Space**，等待下一次 GC 时接收存活对象。
    - Scavenge 算法确保了新生代内存区在不出意外的情况下，可以无限重复使用下去。如此循环GC多次，在此期间存活多次的存活对象将晋升到老生代（对象晋升策略）。
#### 老生代内存区（Old Space / Old Generation）
- 存放生命周期长的大对象。
- **GC 触发条件：** 老生代内存占用超过阈值、或新生代晋升对象过多时触发标记 - 清除 - 整理。
- 主垃圾回收器进行管理内存。
##### 对象晋升策略
前面我们提到，在多次GC之后存活下来的存活对象将会晋升到老生代内存区，我们将其称为对象晋升策略。这其实有些偏颇了，对象的晋升情况不是只有单单的多次GC存活。

- **情况1 GC多次存活（年龄晋升）：** 对象每经历一次 Scavenge GC 后仍存活，其 GC计数器 + 1，其数值可以称之为 **“年龄”** ，当**年龄超过阈值**（默认为15次，但实际上在V8引擎的动态调整中会少得多，可能2次就行了）时，对象会被晋升到老生代，可以把这个过程称之为“熬资历”。
    
- **情况2 大对象：** 若对象的初始大小超过了新生代单个页的容量（“页”为内存分配的单位，在64位下新生代的页通常为1 MB），V8会直接将其分配到老生代，不经过新生代。
    
- **情况3 To Space占用过多：** 如果 GC 时，To Space 内的占用率超过了阈值（一般为25%），存活对象会被提前晋升到老生代（即使其年龄未达标）。
    
- **晋升策略决策树：**
![[Pasted image 20251016001650.png]]
##### 结构
- 基于v8 11.0+引擎的老生代结构如下
![[Pasted image 20251016001826.png]]

| 分区名称                   | 存储内容                                        | 垃圾回收策略                   |
| ---------------------- | ------------------------------------------- | ------------------------ |
| **Old Space**          | 长期存活的普通对象（含引用关系），如闭包、全局变量引用的对象              | （标记-清除）+（标记-整理）          |
| **Code Space**         | JIT 编译后的机器码（优化后的函数）                         | 单独标记，与数据区回收策略分离          |
| **Large Object Space** | 大小超过`kMaxRegularHeapObjectSize`（默认约 1MB）的对象 | 每个对象独占内存页，直接标记清除         |
| **Map Space**          | 对象的 Map 元数据（描述属性布局、原型链等）                    | 与 Old Space 协同回收，优化元数据访问 |
| **Cell Space**         | 小尺寸数据（如 SMI 整数、指针）                          | 部分版本中与老生代协同管理            |

老规矩，我们不可能全拿下所有的分区，大多数分区其实也很难用到，了解一下就差不多了。我们要着重了解的其实是 **Old Space** 分区所使用的 GC 算法 **标记-清除-整理**。
##### GC 算法
因为老生代区的内存大小和其中存储的对象大小远超新生代区，所以 **Scavenge 算法**所进行的对半开的频繁批量复制区内的对象操作太简单粗暴，也太耗费时间了。为了性能着想，老生代需要采用更适合的 GC 操作，也就是**标记-清除-整理**。

- **标记-清除-整理：** “标记-清除-整理” 其实是指一个 **GC 过程**，真正的 GC 算法要分为 **标记-清除** 以及 **标记-整理** 两个算法。
    - **标记-清除（Mark-Sweep）：** 这是最常用的算法，简单来说就是在要清除对象上做好标记，然后再进行清除。
        - **标记阶段：** 从根对象（如全局变量、调用栈中的变量）开始，==递归标记==所有可达对象。
        - **清除阶段：** 遍历整个堆内存，回收未被标记的对象。
    - **标记-整理（Mark-Compact）：** 这是为了解决**标记-清除**算法操作之后，堆内存中出现的碎片化问题而设计的算法。简单来说就是，将呈碎片化分布的对象打好标记，然后 V8 引擎将会出手将碎片化分布的对象重新排列好。
        - **标记阶段：** 同上面的**标记-清除**算法的标记阶段。
        - **整理阶段：** 将所有存活对象移动到内存的一端，然后清除边界外的内存。
**优化**
众所周知，JS 的 V8 引擎为**单线程**，也就是我们常说的**主线程**。那么问题来了，现在主线程又要运行你的 JS 代码，又要去管理堆内存。线程只有一个，它是否会分身乏术呢？  
答案是肯定的，前面提到的 Scavenge 算法以及标记-清除、标记-整理算法都会造成主线程阻塞，因为 V8 引擎的垃圾回收器在执行这些算法时**必须暂停主线程的执行**，引起**全局阻塞**（也就是前面介绍自动内存管理时的 **STW**）。
其中**标记-清除、标记-整理**这两个算法造成的 STW 尤其严重，因为标记阶段需要从根对象（如全局变量、调用栈）出发，**递归遍历整个对象图**，标记所有可达对象。对于大型应用，这个过程所要花费的时间可能要数百毫秒甚至更长时间，导致出现了明显的 STW。
这时候聪明的 JS 设计师就采用了**增量标记算法**来对**标记-清除-整理**这个过程进行优化。

- **增量标记算法（Incremental Marking）：** 将标记过程**碎片化**，每次只标记一小部分对象，然后暂停标记，让主线程执行一段时间，以此减少 STW 的时间，如此循环直到标记完成。
    - **过程：**
        - **1. 初始标记（STW）**
            - 暂停主线程，标记所有根对象（如全局变量、当前调用栈中的变量）。
            - 这个阶段通常非常快，因为根对象数量较少。
        - **2. 增量标记（与主线程交替执行）**
            - 垃圾回收器每次标记一小部分对象（例如，先遍历 100 个对象），然后暂停，让主线程继续执行。
        - **3. 重新标记（STW）**
            - 再次暂停主线程，处理在增量标记阶段由写屏障记录的引用变化，确保所有可达对象都被标记。
            - 这个阶段比初始标记稍长，但远短于传统标记的总时间。
        - **4. 清除 / 整理阶段**
            - 回收未标记的对象，或整理内存空间。这个阶段也可以采用增量方式或并发执行（取决于具体实现）。
![[Pasted image 20251016104402.png]]
### 引用计数

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```
const arr = [1, 2, 3, 4];
console.log('hello world');
```

上面代码中，数组`[1, 2, 3, 4]`是一个值，会占用内存。变量`arr`是仅有的对这个值的引用，因此引用次数为`1`。尽管后面的代码没有用到`arr`，它还是会持续占用内存

如果需要这块内存被垃圾回收机制释放，只需要设置如下：

```
arr = null
```

通过设置`arr`为`null`，就解除了对数组`[1,2,3,4]`的引用，引用次数变为 0，就被垃圾回收了
## 本地缓存
### cookie
HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是==服务器发送到用户浏览器并保存在本地==的一小块数据。浏览器会存储 cookie 并在==下次向同一服务器再发起请求时携带并发送到服务器==上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于[无状态](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84)的 HTTP 协议记录稳定的状态信息成为了可能。

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `cookie`有效期、安全性、使用范围的可选属性组成

但是`cookie`在每次请求中都会被发送，如果不使用 `HTTPS`并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 `cookie`保持登录态的网站上，如果 `cookie`被窃取，他人很容易利用你的 `cookie`来假扮成你登录网站

关于`cookie`常用的属性如下：
>当 Cookie 的过期时间（ `Expires`）被设定时，设定的日期和时间==只与客户端相关，而不是服务端==。
- Expires 用于设置 Cookie 的过期时间

```js
Expires=Wed, 21 Oct 2015 07:28:00 GMT
```

- Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比`Expires`高）

```js
Max-Age=604800
```

- `Domain`指定了 `Cookie` 可以送达的主机名
- `Path`指定了一个 `URL`路径，这个路径必须出现在要请求的资源的路径中才可以发送 `Cookie` 首部

```js
Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部
```

- 标记为 `Secure`的 `Cookie`只应通过被`HTTPS`协议加密过的请求发送给服务端

通过上述，我们可以看到`cookie`又开始的作用并不是为了缓存而设计出来，只是借用了`cookie`的特性实现缓存

关于`cookie`的使用如下：

```js
document.cookie = '名字=值';
```

关于`cookie`的修改，首先要确定==`domain`和`path`属性都是相同==的才可以，其中有一个不同得时候都会创建出一个新的`cookie`

```js
Set-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置
document.cookie ='name=bb; domain=aa.net; path=/'  # 客户端设置
```
>直接使用document.cookie 赋值 会将新值拼接在已有的cookie上而不是替换

最后`cookie`的删除，最常用的方法就是给`cookie`设置一个过期的事件，这样`cookie`过期后会被浏览器删除
### localStorage
`HTML5`新方法，IE8及以上浏览器都兼容
**特点**
- 生命周期：持久化的本地存储，除非主动删除数据，否则==数据是永远不会过期==的
- 存储的信息在==同一域中是共享==的
- 当本页操作（新增、修改、删除）了`localStorage`的时候，本页面不会触发`storage`事件,但是别的页面会触发`storage`事件。
- 大小：5M（跟浏览器厂商有关系）
- `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- 受同源策略的限制

下面再看看关于`localStorage`的使用

设置

```js
localStorage.setItem('username','cfangxu');
```

获取

```js
localStorage.getItem('username')
```

获取键名

```js
localStorage.key(0) //获取第一个键名
```

删除

```js
localStorage.removeItem('username')
```

一次性清除所有存储

```js
localStorage.clear()
```

`localStorage` 也不是完美的，它有两个缺点：

- 无法像`Cookie`一样设置过期时间
- 只能存入字符串，无法直接存对象

```js
localStorage.setItem('key', {name: 'value'});
console.log(localStorage.getItem('key')); // '[object, Object]'
```
### sessionStorage

`sessionStorage`和 `localStorage`使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，`sessionStorage` 将会删除数据
### 区别

关于`cookie`、`sessionStorage`、`localStorage`三者的区别主要如下：

- 存储大小：`cookie`数据大小不能超过`4k`，`sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大
    
- 有效时间：`localStorage`存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； `sessionStorage`数据在当前浏览器窗口关闭后自动删除；`cookie`设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭
    
- 数据与服务器之间的交互方式，`cookie`的数据会自动的传递到服务器，服务器端也可以写`cookie`到客户端； `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存
### indexedDB

`indexedDB`是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索

虽然 `Web Storage`对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。`IndexedDB`提供了一个解决方案

优点：

- 储存量理论上没有上限
- 所有操作都是异步的，相比 `LocalStorage` 同步操作性能更高，尤其是数据量较大时
- 原生支持储存`JS`的对象
- 是个正经的数据库，意味着数据库能干的事它都能干

缺点：

- 操作非常繁琐
- 本身有一定门槛

关于`indexedDB`的使用基本使用步骤如下：

- 打开数据库并且开始一个事务
- 创建一个 `object store`
- 构建一个请求来执行一些数据库操作，像增加或提取数据等。
- 通过监听正确类型的 `DOM` 事件以等待操作完成。
- 在操作结果上进行一些操作（可以在 `request`对象中找到）
### 应用场景
在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：

- 标记用户与跟踪用户行为的情况，推荐使用`cookie`
- 适合长期保存在本地的数据（令牌），推荐使用`localStorage`
- 敏感账号一次性登录，推荐使用`sessionStorage`
- 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用`indexedDB`
## 函数式编程
函数式编程强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程,简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果
```js
// 命令式编程
var array = [0, 1, 2, 3]
for(let i = 0; i < array.length; i++) {
    array[i] = Math.pow(array[i], 2)
}

// 函数式方式
[0, 1, 2, 3].map(num => Math.pow(num, 2))
```
### 优点
- 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况
- 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响
- 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性
- 隐性好处。减少代码量，提高维护性
### 缺点：
- 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作
## 模块化方式
### AMD
>Asynchronous Module Definition,异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行,代表库为`require.js`
```js
/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config({
  baseUrl: "js/lib",
  paths: {
    "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js
    "underscore": "underscore.min",
  }
});
// 执行基本操作
require(["jquery","underscore"],function($,_){
  // some code here
});
```
### CommonJs
>`CommonJS` 是一套 `Javascript` 模块规范，用于服务端
```js
// a.js
module.exports={ foo , bar}

// b.js
const { foo,bar } = require('./a.js')
```
其有如下特点：
- 所有代码都运行在模块作用域，不会污染全局作用域
- 模块是==同步==加载的，即只有加载完成，才能执行后面的操作
- 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存
- `require`返回的值是被输出的值的==拷贝==，模块内部的变化也不会影响这个值
### ES6 Module
>ES6 在语言标准的层面上，实现了`Module`，即模块功能，完全可以取代 `CommonJS`和 `AMD`规范，成为浏览器和服务器通用的模块解决方案.`CommonJS` 和`AMD` 模块，都只能在运行时确定这些东西。`ES6`设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，使得静态分析成为可能。

模块功能主要由两个命令构成：
- `export`：用于规定模块的对外接口
- `import`：用于输入其他模块提供的功能
#### export
一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量
```js
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };
```
通过`as`可以进行输出变量的重命名
```js
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
```
#### import
使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块
```js
// main.js
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
```
同样如果想要输入变量起别名，通过`as`关键字
```js
import { lastName as surname } from './profile.js';
```
当加载整个模块的时候，需要用到星号`*`
```js
// circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

// main.js
import * as circle from './circle';
console.log(circle)   // {area:area,circumference:circumference}
```
>导入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性,不过建议即使能修改，但我们不建议。
>在编译阶段，`import`会提升到整个模块的头部，首先执行,多次重复执行同样的导入，只会执行一次

上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载
如果不需要知道变量名或函数就完成加载，就要用到`export default`命令，为模块指定默认输出
```js
// export-default.js
export default function () {
    console.log('foo');
}
```
加载该模块的时候，`import`命令可以为该函数指定任意名字
```js
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```
**复合写法**
>如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起,同理能够搭配`as`、`*`搭配使用
```js
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```
## TreaShaking的实现
### 阶段一：依赖收集与静态分析
```js
// 源代码结构
// math.js
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;
export const square = (x) => x * x;

// main.js
import { add, multiply } from './math.js';

console.log(add(1, 2));
console.log(multiply(3, 4));
```
**构建工具分析过程**：
1. 构建依赖图，识别所有 import/export
2. 标记 `add` 和 `multiply` 为 **已使用**
3. 标记 `square` 为 **未使用**
### 阶段二：死代码消除
```js
// 输出结果（简化版）
// math.js 中被 Tree Shaking 后的代码
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
// square 函数被完全移除

// main.js 保持不变
console.log(add(1, 2));
console.log(multiply(3, 4));
```
### 标记的具体过程
#### 1. 构建抽象语法树（AST）
```js
// 源代码
export function used() { console.log('used'); }
export function unused() { console.log('unused'); }

// AST 结构（简化）：
{
  type: 'Program',
  body: [{
    type: 'ExportNamedDeclaration',
    declaration: {
      type: 'FunctionDeclaration',
      id: { name: 'used' }
    }
  }, {
    type: 'ExportNamedDeclaration', 
    declaration: {
      type: 'FunctionDeclaration',
      id: { name: 'unused' }
    }
  }]
}
```
#### 2. 建立模块依赖图
```js
// 依赖图数据结构
class ModuleGraph {
  constructor() {
    this.modules = new Map();
    this.usedExports = new Set();
  }
  
  addModule(module) {
    this.modules.set(module.id, {
      exports: new Map(),
      imports: new Map(),
      isUsed: false
    });
  }
  
  markUsed(exportName) {
    this.usedExports.add(exportName);
  }
}
```
#### 3. 标记算法的核心实现
>静态可达性分析
1. 简单的标记扫描算法
```js
class TreeShaker {
  constructor(entryModule) {
    this.entry = entryModule;
    this.visited = new Set();
    this.used = new Set();
  }
  
  // 标记入口开始的可达导出
  markFromEntry() {
    this.traverseModule(this.entry);
  }
  
  traverseModule(module) {
    if (this.visited.has(module.id)) return;
    this.visited.add(module.id);
    
    // 标记该模块的所有直接使用
    for (const importSpec of module.imports) {
      this.markExportAsUsed(importSpec.source, importSpec.imported);
    }
    
    // 递归处理依赖
    for (const dependency of module.dependencies) {
      this.traverseModule(dependency);
    }
  }
  
  markExportAsUsed(moduleId, exportName) {
    const key = `${moduleId}#${exportName}`;
    this.used.add(key);
  }
  
  // 判断导出是否被使用
  isExportUsed(moduleId, exportName) {
    const key = `${moduleId}#${exportName}`;
    return this.used.has(key);
  }
}
```
## Vue项目打包全过程
1. **依赖解析与加载**  
    当你运行 `npm run build`，Webpack 会从配置的入口文件（通常是 `src/main.js`）开始，递归解析所有 `import` 或 `require` 语句，构建项目的**依赖图**。对于遇到的 `.vue` 文件，**vue-loader** 会将其中的 `<template>`、`<script>` 和 `<style>` 块拆分出来，交给对应的 loader 处理。
2. **编译与转换**
    - **模板编译**：`vue-template-compiler` 将 `<template>` 中的HTML-like语法转换为 **JavaScript 渲染函数**。这个过程也涉及静态分析，以优化运行时性能。
    - **脚本处理**：`<script>` 块中的代码通常由 **Babel** 处理，将新版 JavaScript（如 ES6+）转换为兼容性更好的语法。Babel 也负责处理 Vue 的单文件组件语法。
    - **样式处理**：`<style>` 块中的 CSS 可能由 **css-loader**（解析 CSS）、**style-loader** / **mini-css-extract-plugin**（将 CSS 注入 DOM 或提取为独立文件）等处理。如果使用了 Less、Sass 等预处理器，也会有对应的 loader 处理。
3. **资源优化与打包**  
    Webpack 将编译后的模块、资源整合到一起，这个过程涉及多种优化技术：
    - **代码分割（Code Splitting）**：将代码拆分成多个块，实现按需加载。
    - **Tree Shaking**：移除 JavaScript 上下文中未引用的代码（dead-code）。
    - **压缩（Minification）**：使用 **TerserWebpackPlugin** 等工具压缩和混淆 JavaScript 代码，减小文件体积。CSS 和 HTML 也会被压缩。
    - **静态资源处理**：图片、字体等文件可能由 loader（如 `file-loader`）处理，并可能被压缩、添加哈希名用于缓存优化。
4. **生成 dist 目录**  
    经过上述处理，Webpack 会输出最终的打包文件到 `dist` 目录。
## Http缓存机制
### 概念
HTTP 缓存机制是客户端（通常是浏览器）与服务器之间协作，通过缓存策略减少重复请求、降低延迟和节省带宽的技术。缓存可以存在多层（浏览器、本地缓存；中间代理缓存，如 CDN；服务器端缓存等）。
总体来说，HTTP 缓存主要分为两大类：
1. **强制缓存（Freshness / 强缓存）**
	在缓存还没过期的时候，客户端可以直接使用缓存，不与服务器通信。
2. **协商缓存（Validation / 对比缓存）**
	当缓存过期或无明确过期时间时，客户端会向服务器询问资源是否变化（带上某些验证值），服务器通过验证后决定返回 304（Not Modified）还是新的资源。
### 关键 HTTP 头
在缓存机制中，以下几个 HTTP 头非常关键：

| 首部                  | 作用 / 含义                                                                                                         |
| ------------------- | --------------------------------------------------------------------------------------------------------------- |
| `Cache-Control`     | HTTP/1.1 的主要缓存控制头，能很灵活地控制资源是否缓存、缓存多久、缓存策略等。                                                                     |
| `Expires`           | HTTP/1.0 的过期机制，指定一个绝对时间（日期）为过期时间。                                                                               |
| `Last-Modified`     | 表示资源最后一次修改的时间。服务器响应时返回，客户端下次请求可以带 `If-Modified-Since`。                                                          |
| `If-Modified-Since` | 客户端请求头，用于告诉服务器上次缓存资源的最后修改时间。服务器可以根据此判断资源是否已变更。                                                                  |
| `ETag`              | 资源的实体标签（实体标签可以是某种哈希或标识符），表示资源内容的版本。服务器给出一个标识符。                                                                  |
| `If-None-Match`     | 客户端请求头，把之前的 `ETag` 值带给服务器，服务器比对是否相同。若相同，则返回 304。                                                                |
| `Pragma`            | 兼容性头（主要 HTTP/1.0），例如 `Pragma: no-cache`。现代主要用 `Cache-Control` 控制。                                               |
| `Vary`              | 用于告诉缓存机制：某些请求头（如 `Accept-Encoding`、`User-Agent` 等）不同会导致不同版本的响应，应分别缓存。虽然不是必选，但在复杂场景（CDN、代理）非常重要。 （这一点在缓存优化中常被提到） |
### 强制缓存（Freshness）
>强制缓存用于在资源仍旧被认为“新鲜”（未过期）的情况下，完全不跟服务器通信就使用本地缓存。
- `Cache-Control: max-age=秒数`：表示资源在多少秒内被认为是新的。
- `Cache-Control: public` / `private`：指定响应是否可以被公共缓存（如 CDN、代理）缓存（`public`），还是只能在私有缓存中（如浏览器）缓存（`private`）
- `Cache-Control: no-store`：表示该资源不应该被缓存（无论是客户端缓存还是中间缓存，都不存储）。
- `Cache-Control: no-cache`：虽然名字是 “no-cache”，但是它允许缓存，只是每次使用缓存前必须先向服务器验证。也就是协商缓存的一种形式。
- `Expires`：指定缓存过期的具体时间；在 HTTP/1.1 中，如果同时有 `Cache-Control: max-age`，则 `max-age` 优先。

**优先级**（缓存控制头）：
1. `Pragma`（如果存在）优先。
2. `Cache-Control`
3. `Expires`
### 协商缓存（Validation / 对比缓存）
当资源不再被强制缓存（已经过期 / 没有明确过期时间 / `no-cache` 等情况）时，客户端会发起验证请求，询问服务器资源是否有变更。
- 客户端在请求头中加入 `If-Modified-Since`（基于 `Last-Modified`）或 `If-None-Match`（基于 `ETag`）。
- 服务器收到后，比较：
    - 如果资源 **未变更**：返回 **304 Not Modified**，不返回资源内容。客户端可以继续使用本地缓存。
    - 如果资源 **已变更**：返回 **200** 和新的资源，同时返回新的 `ETag` / `Last-Modified`。
**为什么同时使用 `Last-Modified` 和 `ETag`？**
- `Last-Modified` 是时间戳，比较简单。但存在问题，比如修改非常快（短时间内改动），或者服务器与客户端时间不一致，都可能导致不准确。
- `ETag` 是实体标签（通常是内容的 hash），更精确；但计算成本可能比 `Last-Modified` 高。
- 所以，**推荐做法**：优先使用 `ETag`，`Last-Modified` 作为 fallback（后备）。
**验证流程优先级**：
- `If-None-Match` / `ETag` 的优先级高于 `If-Modified-Since` / `Last-Modified`。
### 缓存流程总结（浏览器视角）
1. **第一次请求**  
    浏览器请求资源，服务器返回响应并带上缓存相关头（比如 `Cache-Control`、`Expires`、`ETag`、`Last-Modified` 等）
2. **判断是否仍在强制缓存期**  
    浏览器检查响应头中的 `Cache-Control`（或者 `Expires`）来决定本地缓存是否还有效。
    - 如果还没过期：**直接使用缓存**，不发请求。
    - 如果过期（或是 `no-cache`）：进入协商缓存阶段。
3. **协商缓存（验证）**  
    浏览器向服务器发带验证头的新请求（`If-None-Match` / `If-Modified-Since`）。
    - 服务器对比：如果没变更 → 返回 **304**，浏览器继续使用本地缓存。
    - 如果变更 → 返回 **200** 和新的资源，浏览器替换本地缓存。
4. **特殊/控制场景**
    - 如果客户端强制刷新（例如 Ctrl+F5）：浏览器可能忽略缓存验证，强制拉取最新资源。
    - 对于 HTTP/1.0 客户端或代理，可能只识别 `Expires` 而不识别 `Cache-Control`。
### 缓存优化策略 & 实践建议
- **静态资源（比如 JS、CSS、图片）**：可以设置较长的 `max-age`（例如一年），并对资源进行版本管理（比如在资源 URL 加版本号 / hash），这样客户端可以长期缓存。 
- **动态内容**（经常变化的数据）：建议使用 `ETag` 或 `Last-Modified`，配合较短缓存，保证内容及时更新。
- **控制缓存可见性**：使用 `public` / `private` 来决定哪些缓存可以被公共缓存（CDN、代理）使用。
- **避免缓存敏感信息**：对敏感数据（用户私人数据、认证信息等）使用 `no-store`，避免被缓存。
- **使用 `Vary` 头**：如果响应会根据请求头（如 `Accept-Encoding`、`User-Agent`、`Cookie` 等）变化，那么设置 `Vary` 很重要，以防缓存错用。
- **监控和调试**：通过浏览器开发者工具（Network 面板）观察是否命中了缓存（cache hit）、返回的状态码是否是 304、响应头是否如预期。
## 使用TS时给全局windows挂载数据后使用时会报错(因为定义的结构中没有),怎么处理?
>TypeScript 报错是因为内置的 `Window` / 全局类型里没有你挂载的属性 —— 解决办法就是告诉 TypeScript 这个属性的类型（类型声明/增强），或者用类型断言跳过检查。
### 在声明文件里扩展 `Window`（或 `globalThis`）
把类型声明放在 `.d.ts`（或 `.ts` 模块 + `declare global`）里，这样对整个项目生效、干净且类型安全。
1. 方式 A — 在全局 ambient `.d.ts` 中直接扩展（简单）
```ts
// src/types/globals.d.ts   （文件名任意，但后缀必须是 .d.ts）
interface Window {
  __APP_CONFIG__?: {
    apiUrl: string;
    env: 'dev' | 'prod';
    featureFlag?: boolean;
  };
}
```
然后就可以安全使用：
```ts
console.log(window.__APP_CONFIG__?.apiUrl);
```
>**注意**：确保该 `.d.ts` 被 `tsconfig.json` 的 `include` 捕获（默认 `include: ["src"]` 通常可以）。
>TS 会把你的内容 **合并** 到系统内置的 Window 类型中。而不是覆盖原有类型
2. 方式 B — 如果文件是模块（含 import/export），用 `declare global`
```ts
// src/types/globals.ts
export {}; // 把这个文件当作模块
type AppConfig = { apiUrl: string; env: 'dev'|'prod' };

declare global {
  interface Window {
    __APP_CONFIG__?: AppConfig;
  }
}
```
3. 方式 C — 使用 `globalThis`（跨环境更现代）
```ts
// src/types/globals.d.ts
type AppConfig = { apiUrl: string; env: 'dev'|'prod' };

declare global {
  var __APP_CONFIG__: AppConfig | undefined; // 全局变量
}
// 使用时
globalThis.__APP_CONFIG__?.apiUrl;
```
### 快速/临时方案
>这些方式会跳过编译器检查，适合快速验证，但丢失类型安全。
1. 类型断言
```ts
(window as any).__APP_CONFIG__ = { apiUrl: '/api' };
console.log((window as any).__APP_CONFIG__.apiUrl);
```
2. `// @ts-ignore` 在行前忽略错误
## fetch axios xhr区别
### XMLHttpRequest (XHR)

#### 基本介绍

XHR 是最古老的浏览器 API，用于在后台与服务器交换数据。

#### 基本用法
```js
// 创建 XHR 对象
const xhr = new XMLHttpRequest();

// 配置请求
xhr.open('GET', 'https://api.example.com/data', true);

// 设置请求头
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.setRequestHeader('Authorization', 'Bearer token');

// 处理响应
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) { // 请求完成
    if (xhr.status === 200) {
      console.log('成功:', JSON.parse(xhr.responseText));
    } else {
      console.error('错误:', xhr.status);
    }
  }
};

// 处理错误
xhr.onerror = function() {
  console.error('请求失败');
};

// 发送请求
xhr.send();

// 发送 POST 数据
const data = JSON.stringify({ name: 'John' });
xhr.send(data);
```
#### 进度监控
```js
xhr.upload.onprogress = function(event) {
  if (event.lengthComputable) {
    const percentComplete = (event.loaded / event.total) * 100;
    console.log(`上传进度: ${percentComplete}%`);
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    const percentComplete = (event.loaded / event.total) * 100;
    console.log(`下载进度: ${percentComplete}%`);
  }
};
```
#### 超时设置
```js
xhr.timeout = 5000; // 5秒超时
xhr.ontimeout = function() {
  console.error('请求超时');
};
```
### Fetch API

#### 基本介绍

Fetch 是现代浏览器提供的更简洁的 API，基于 Promise。

#### 基本用法
```js
// GET 请求
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('网络响应不正常');
    }
    return response.json();
  })
  .then(data => console.log('成功:', data))
  .catch(error => console.error('错误:', error));

// 使用 async/await
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('网络响应不正常');
    const data = await response.json();
    console.log('成功:', data);
  } catch (error) {
    console.error('错误:', error);
  }
}
```
#### 完整配置
```js
// POST 请求 with headers
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify({
    name: 'John',
    email: 'john@example.com'
  }),
  credentials: 'include', // 包含 cookies
  mode: 'cors', // CORS 模式
  cache: 'no-cache' // 缓存控制
})
.then(response => response.json())
.then(data => console.log(data));
```
#### 超时处理
```js
// 自定义超时函数
function fetchWithTimeout(url, options = {}, timeout = 5000) {
  return Promise.race([
    fetch(url, options),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('请求超时')), timeout)
    )
  ]);
}

// 使用
fetchWithTimeout('https://api.example.com/data', {}, 5000)
  .then(response => response.json())
  .catch(error => console.error('超时或错误:', error));
```
#### 取消请求
```js
javascript

// 使用 AbortController
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('请求被取消');
    } else {
      console.error('其他错误:', error);
    }
  });

// 取消请求
controller.abort();
```
### Axios
#### 基本介绍
Axios 是基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用。
#### 基本用法
```js
// GET 请求
axios.get('https://api.example.com/data')
  .then(response => console.log('成功:', response.data))
  .catch(error => console.error('错误:', error));

// POST 请求
axios.post('https://api.example.com/users', {
  name: 'John',
  email: 'john@example.com'
}, {
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  }
})
.then(response => console.log(response.data));
```
#### 完整配置
```js
// 全局配置
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.timeout = 5000;
axios.defaults.headers.common['Authorization'] = 'Bearer token';

// 实例配置
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
  headers: {'X-Custom-Header': 'value'}
});

// 请求配置
axios.get('/data', {
  params: {
    page: 1,
    limit: 10
  },
  timeout: 3000,
  responseType: 'json'
});
```
#### 拦截器
```js
// 请求拦截器
axios.interceptors.request.use(
  config => {
    // 在发送请求前做些什么
    config.headers.Authorization = `Bearer ${getToken()}`;
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

// 响应拦截器
axios.interceptors.response.use(
  response => {
    // 对响应数据做点什么
    return response;
  },
  error => {
    // 对响应错误做点什么
    if (error.response?.status === 401) {
      // 处理未授权
      logout();
    }
    return Promise.reject(error);
  }
);
```
#### 取消请求
```js
javascript

// 方法1: CancelToken (旧版)
const source = axios.CancelToken.source();

axios.get('/data', {
  cancelToken: source.token
}).catch(error => {
  if (axios.isCancel(error)) {
    console.log('请求取消:', error.message);
  }
});

// 取消请求
source.cancel('操作被用户取消');

// 方法2: AbortController (新版)
const controller = new AbortController();

axios.get('/data', {
  signal: controller.signal
}).catch(error => {
  if (error.name === 'CanceledError') {
    console.log('请求被取消');
  }
});

// 取消请求
controller.abort();
```
### 详细对比

|特性|XHR|Fetch|Axios|
|---|---|---|---|
|**浏览器支持**|所有浏览器|现代浏览器|所有浏览器 (通过 polyfill)|
|**Node.js 支持**|❌ 不支持|❌ 不支持|✅ 支持|
|**Promise 支持**|❌ 需要封装|✅ 原生支持|✅ 基于 Promise|
|**请求取消**|✅ 支持|✅ AbortController|✅ CancelToken/AbortController|
|**超时设置**|✅ 原生支持|❌ 需要实现|✅ 原生支持|
|**进度监控**|✅ 原生支持|❌ 需要实现|✅ 原生支持|
|**自动 JSON**|❌ 需要手动解析|✅ response.json()|✅ 自动转换|
|**拦截器**|❌ 不支持|❌ 不支持|✅ 请求/响应拦截器|
|**CSRF 防护**|❌ 手动处理|❌ 手动处理|✅ 内置支持|
|**并发请求**|❌ 需要实现|✅ Promise.all|✅ axios.all|
|**错误处理**|手动检查状态码|不抛出 HTTP 错误|自动抛出 HTTP 错误|
## ## Map 和 Object 的区别

### 基本区别对比

| 特性       | Map                 | Object                        |
| -------- | ------------------- | ----------------------------- |
| **键的类型** | 任意类型 (对象、函数等)       | String 或 Symbol               |
| **键的顺序** | 插入顺序                | 复杂 (数字键排序 + 插入顺序)             |
| **大小获取** | map.size            | Object.keys(obj).length       |
| **性能**   | 频繁增删时更好             | 创建和访问时稍好                      |
| **序列化**  | 不能直接 JSON.stringify | 可以直接 JSON.stringify           |
| **迭代**   | 直接可迭代               | 需要 Object.keys/values/entries |
| **原型链**  | 无原型链冲突              | 可能有原型链属性                      |
## any、unknown 和 never

### any 类型
```ts
// any - 放弃类型检查
let anything: any = "hello";
anything = 42;           // ✅
anything = true;         // ✅
anything.foo.bar;        // ✅ 运行时可能出错
anything();              // ✅ 运行时可能出错

// 使用场景：迁移旧代码、第三方库类型
const legacyData: any = JSON.parse('...');
```
### unknown 类型
```ts
// unknown - 类型安全的 any
let notSure: unknown = "hello";
notSure = 42;            // ✅
notSure = true;          // ✅

// ❌ 不能直接操作 unknown 类型
// notSure.toFixed();    // 错误
// notSure();           // 错误

// 需要类型检查或类型断言
if (typeof notSure === "string") {
  console.log(notSure.toUpperCase()); // ✅
}

// 类型断言
(notSure as string).toUpperCase(); // ✅ 但需要确保类型正确
```
### never 类型
```ts
// never - 表示永远不会发生的值
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

// 在联合类型中，never 会被忽略
type T = string | number | never; // 等价于 string | number

// 空数组的推断
const emptyArray = []; // 类型: never[]

//  exhaustive checking
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    default:
      // 如果 Shape 有新的类型，这里会报错
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```
### 类型对比表格

|特性|any|unknown|never|
|---|---|---|---|
|**赋值给其他类型**|✅ 可以|❌ 需要类型检查|❌ 不能|
|**接收任何类型**|✅ 可以|✅ 可以|❌ 不能|
|**调用方法**|✅ 可以|❌ 需要类型检查|❌ 不能|
|**类型安全**|❌ 不安全|✅ 安全|✅ 安全|
|**使用场景**|迁移代码、第三方库|用户输入、API响应|错误处理、穷尽检查|
