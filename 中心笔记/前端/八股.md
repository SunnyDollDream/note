# JS
## 变量提升
```js
function sayHi() {
  console.log(name) // undefined
  console.log(age) // ReferenceError
  var name = 'Lydia'
  let age = 21
}

sayHi()
```
在函数内部，我们首先通过 `var` 关键字声明了 `name` 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），==直到程序运行到定义变量位置之前默认值都是 `undefined`==。因为当我们打印 `name` 变量时还没有执行到定义变量的位置，因此变量的值保持为 `undefined`。

通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们==不会被初始化==。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为==暂时性死区==。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。
## RESTful API 的设计原则是什么？
RESTful API 的设计原则包括：
1. 资源导向：使用 URL 表示资源，HTTP 方法（GET、POST、PUT、DELETE）表示操作。
2. 无状态：每个请求都应包含所有必要的信息，服务器不应存储客户端状态。
3. 可缓存：响应应标记为可缓存，以提高性能。
## 字符串不可变的好处
1. 安全性
	- 不可变对象在多线程环境中更安全（虽然JS是单线程）
	- 防止意外的数据修改
	- 在函数间传递字符串时不用担心被修改
2. 性能优化
```js
let str1 = "Hello";
let str2 = "Hello";

// 由于字符串不可变，引擎可以优化内存使用
// str1 和 str2 可能指向内存中的同一个字符串
console.log(str1 === str2); // true
```
3. 哈希表键的稳定性
	- 字符串常用作对象的键
	- 不可变性确保键的哈希值不会改变
4. 简化实现和调试
	- 行为更可预测
	- 调试时值不会意外改变
## null和undefined的区别

| 特性         | undefined        | null            |
| ---------- | ---------------- | --------------- |
| **类型**     | 一个类型（Undefined）  | 一个值（属于Object类型） |
| **含义**     | 变量已声明但未赋值        | 表示空值或空对象引用      |
| **typeof** | "undefined"      | "object"        |
| **数字转换**   | NaN              | 0               |
| **默认行为**   | JavaScript引擎自动赋值 | 需要显式赋值          |
函数参数未提供,访问不存在的对象属性时结果都是undefined
而除了Dom查询不存在的元素时会返回null,其他的null一般都是显示赋值的,如用于清空引用,手动返回明确表示空结果
**语义上**:
- `undefined` → "这里应该有值，但还没有"
- `null` → "这里应该没有值，我明确设置了空"
## ??和||的区别
??只检查null和undefined,而||还会将0,false和''(空串)判为无效
## 字符串取子串方法的区别
### slice(start,end)
>支持负数索引(从-1开始,同样左闭右开)
>start > end，返回空字符串
```js
let str = "Hello World";

// 基本用法
console.log(str.slice(0, 5));     // "Hello"
console.log(str.slice(6));        // "World" (从索引6到末尾)
console.log(str.slice(6, 11));    // "World"

// 支持负数索引（从末尾开始计算）
console.log(str.slice(-5));       // "World" (最后5个字符)
console.log(str.slice(0, -6));    // "Hello" (从开始到倒数第6个字符)
console.log(str.slice(-11, -6));  // "Hello"

// 如果start > end，返回空字符串
console.log(str.slice(5, 2));     // ""
```
### substr(start,end)(已废弃)
>start>end会自动交换而不是返回空串
>负参数会被视为0
```js
let str = "Hello World";

// 基本用法
console.log(str.substring(0, 5));     // "Hello"
console.log(str.substring(6));        // "World"
console.log(str.substring(6, 11));    // "World"

// 自动交换参数（如果start > end）
console.log(str.substring(5, 2));     // "llo" (自动交换为2,5)

// 负数参数会被视为0
console.log(str.substring(-3, 5));    // "Hello" (-3被视为0)
console.log(str.substring(2, -3));    // "He" (自动交换为0,2)
```
### substring(start,length)
>支持负数索引(从-1开始)
>负数长度返回空串
```js
let str = "Hello World";

// 基本用法
console.log(str.substr(0, 5));     // "Hello"
console.log(str.substr(6));        // "World" (从索引6到末尾)
console.log(str.substr(6, 5));     // "World"

// 支持负数start（从末尾开始计算）
console.log(str.substr(-5));       // "World" (最后5个字符)
console.log(str.substr(-5, 3));    // "Wor" (从倒数第5个开始取3个字符)

// 负数length返回空字符串
console.log(str.substr(2, -3));    // ""
```
## 会自动转化为flase的值
- undefined
- null
- false
- +0
- -0
- NaN
其余情况都会转化为true
## 手写深拷贝
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```
## new的原理
当你使用 `new` 调用函数时，JavaScript引擎会执行以下4个步骤：
1. 创建一个新对象
```js
// 内部创建一个空对象
const obj = {};
```
2. 设置原型链
```js
// 将新对象的原型指向构造函数的prototype属性
obj.__proto__ = Constructor.prototype;
```
3. 执行构造函数
```js
// 将构造函数的作用域赋给新对象（this指向新对象）
const result = Constructor.apply(obj, arguments);
```
4. 返回新对象
```js
// 如果构造函数没有返回对象，则返回新创建的对象
if (typeof result === 'object' && result !== null) {
    return result;
} else {
    return obj;
}
```
## 手写new运算符
我们可以手动实现一个 `myNew` 函数来模拟 `new` 的行为：
```js
function myNew(Constructor, ...args) {
    // 步骤1：创建新对象
    const obj = {};
    
    // 步骤2：设置原型链
    Object.setPrototypeOf(obj, Constructor.prototype);
    
    // 步骤3：执行构造函数，绑定this
    const result = Constructor.apply(obj, args);
    
    // 步骤4：返回结果
    return result instanceof Object ? result : obj;
}

// 使用示例
function Car(brand) {
    this.brand = brand;
}

Car.prototype.getBrand = function() {
    return this.brand;
};

const myCar = myNew(Car, 'Toyota');
console.log(myCar.getBrand()); // 'Toyota'
console.log(myCar instanceof Car); // true
```

