## 变量提升
```js
function sayHi() {
  console.log(name) // undefined
  console.log(age) // ReferenceError
  var name = 'Lydia'
  let age = 21
}

sayHi()
```
在函数内部，我们首先通过 `var` 关键字声明了 `name` 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），==直到程序运行到定义变量位置之前默认值都是 `undefined`==。因为当我们打印 `name` 变量时还没有执行到定义变量的位置，因此变量的值保持为 `undefined`。

通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们==不会被初始化==。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为==暂时性死区==。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。
## RESTful API 的设计原则是什么？
RESTful API 的设计原则包括：
1. 资源导向：使用 URL 表示资源，HTTP 方法（GET、POST、PUT、DELETE）表示操作。
2. 无状态：每个请求都应包含所有必要的信息，服务器不应存储客户端状态。
3. 可缓存：响应应标记为可缓存，以提高性能。
## 字符串不可变的好处
1. 安全性
	- 不可变对象在多线程环境中更安全（虽然JS是单线程）
	- 防止意外的数据修改
	- 在函数间传递字符串时不用担心被修改
2. 性能优化
```js
let str1 = "Hello";
let str2 = "Hello";

// 由于字符串不可变，引擎可以优化内存使用
// str1 和 str2 可能指向内存中的同一个字符串
console.log(str1 === str2); // true
```
3. 哈希表键的稳定性
	- 字符串常用作对象的键
	- 不可变性确保键的哈希值不会改变
4. 简化实现和调试
	- 行为更可预测
	- 调试时值不会意外改变
## null和undefined的区别

| 特性         | undefined        | null            |
| ---------- | ---------------- | --------------- |
| **类型**     | 一个类型（Undefined）  | 一个值（属于Object类型） |
| **含义**     | 变量已声明但未赋值        | 表示空值或空对象引用      |
| **typeof** | "undefined"      | "object"        |
| **数字转换**   | NaN              | 0               |
| **默认行为**   | JavaScript引擎自动赋值 | 需要显式赋值          |
函数参数未提供,访问不存在的对象属性时结果都是undefined
而除了Dom查询不存在的元素时会返回null,其他的null一般都是显示赋值的,如用于清空引用,手动返回明确表示空结果
**语义上**:
- `undefined` → "这里应该有值，但还没有"
- `null` → "这里应该没有值，我明确设置了空"
## ??和||的区别
??只检查null和undefined,而||还会将0,false和''(空串)判为无效
## 字符串取子串方法的区别
### slice(start,end)
>支持负数索引(从-1开始,同样左闭右开)
>start > end，返回空字符串
```js
let str = "Hello World";

// 基本用法
console.log(str.slice(0, 5));     // "Hello"
console.log(str.slice(6));        // "World" (从索引6到末尾)
console.log(str.slice(6, 11));    // "World"

// 支持负数索引（从末尾开始计算）
console.log(str.slice(-5));       // "World" (最后5个字符)
console.log(str.slice(0, -6));    // "Hello" (从开始到倒数第6个字符)
console.log(str.slice(-11, -6));  // "Hello"

// 如果start > end，返回空字符串
console.log(str.slice(5, 2));     // ""
```
### substr(start,end)(已废弃)
>start>end会自动交换而不是返回空串
>负参数会被视为0
```js
let str = "Hello World";

// 基本用法
console.log(str.substring(0, 5));     // "Hello"
console.log(str.substring(6));        // "World"
console.log(str.substring(6, 11));    // "World"

// 自动交换参数（如果start > end）
console.log(str.substring(5, 2));     // "llo" (自动交换为2,5)

// 负数参数会被视为0
console.log(str.substring(-3, 5));    // "Hello" (-3被视为0)
console.log(str.substring(2, -3));    // "He" (自动交换为0,2)
```
### substring(start,length)
>支持负数索引(从-1开始)
>负数长度返回空串
```js
let str = "Hello World";

// 基本用法
console.log(str.substr(0, 5));     // "Hello"
console.log(str.substr(6));        // "World" (从索引6到末尾)
console.log(str.substr(6, 5));     // "World"

// 支持负数start（从末尾开始计算）
console.log(str.substr(-5));       // "World" (最后5个字符)
console.log(str.substr(-5, 3));    // "Wor" (从倒数第5个开始取3个字符)

// 负数length返回空字符串
console.log(str.substr(2, -3));    // ""
```
## 会自动转化为flase的值
- undefined
- null
- false
- +0
- -0
- NaN
其余情况都会转化为true
## 手写深拷贝
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```
## new的原理
当你使用 `new` 调用函数时，JavaScript引擎会执行以下4个步骤：
1. 创建一个新对象
```js
// 内部创建一个空对象
const obj = {};
```
2. 设置原型链
```js
// 将新对象的原型指向构造函数的prototype属性
obj.__proto__ = Constructor.prototype;
```
3. 执行构造函数
```js
// 将构造函数的作用域赋给新对象（this指向新对象）
const result = Constructor.apply(obj, arguments);
```
4. 返回新对象
```js
// 如果构造函数没有返回对象，则返回新创建的对象
if (typeof result === 'object' && result !== null) {
    return result;
} else {
    return obj;
}
```
## 手写new运算符
我们可以手动实现一个 `myNew` 函数来模拟 `new` 的行为：
```js
function myNew(Constructor, ...args) {
    // 步骤1：创建新对象
    const obj = {};
    
    // 步骤2：设置原型链
    Object.setPrototypeOf(obj, Constructor.prototype);
    
    // 步骤3：执行构造函数，绑定this
    const result = Constructor.apply(obj, args);
    
    // 步骤4：返回结果
    return result instanceof Object ? result : obj;
}

// 使用示例
function Car(brand) {
    this.brand = brand;
}

Car.prototype.getBrand = function() {
    return this.brand;
};

const myCar = myNew(Car, 'Toyota');
console.log(myCar.getBrand()); // 'Toyota'
console.log(myCar instanceof Car); // true
```

## 事件循环
### 异步的原理
 浏览器不仅有多个线程，还有多个进程，如渲染进程、GPU 进程和插件进程等。而每个 tab 标签页都是一个独立的渲染进程，所以一个 tab 异常崩溃后，其他 tab 基本不会被影响。
 ![[Pasted image 20251013220628.png]]
 作为前端开发者，主要重点关注其渲染进程，渲染进程下包含了 JS 引擎线程、HTTP 请求线程和定时器线程,事件触发线程,GUI线程，这些线程为 JS 在浏览器中完成异步任务提供了基础。
 ![[Pasted image 20251013220638.png]]
 浏览器异步任务的执行原理背后其实是一套事件驱动的机制。事件驱动简而言之就是由特定的事件来触发特定的任务，这里的事件可以是用户的操作触发的，如 click 事件；也可以是程序自动触发的，比如浏览器中定时器线程在计时结束后会触发定时器事件。而事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。
### 事件循环
 JS 在解析一段代码时，会将同步代码按顺序排在执行栈中，然后依次执行里面的函数。当遇到异步任务时就交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出==已完成的异步任务的回调==加入执行栈继续执行，遇到异步任务时又交给其他线程，.....，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。
 ![[Pasted image 20251013220653.png]]
 可见，在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。
#### 宏任务和微任务
任务队列不只一个，根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。
事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。

| 宏任务            | 微任务                        |
| -------------- | -------------------------- |
| setTimeout()   | promise.then,promise.catch |
| setInterval()  | new MutaionObserver()      |
| setImmediate() | process.nextTick()         |
```js
console.log('同步代码1');

setTimeout(() => {

    console.log('setTimeout')

}, 0)

new Promise((resolve) => {

  console.log('同步代码2')

  resolve()

}).then(() => {

    console.log('promise.then')

})

console.log('同步代码3');

// 最终输出"同步代码1"、"同步代码2"、"同步代码3"、"promise.then"、"setTimeout"
```
![[263f472e6e8fb39cf42349634431056e 1.gif]]
**区别**
我们已经知道，JS 遇到异步任务时会将此任务交给其他线程去处理，自己的主线程继续往后执行同步任务。比如 setTimeout 的计时会由浏览器的定时器线程来处理，待计时结束，就将定时器==回调任务放入任务队列==等待主线程来取出执行。前面我们提到，因为 JS 是单线程执行的，所以要执行异步任务，就需要浏览器其他线程来辅助，即多线程是 JS 异步任务的一个明显特征。
我们再来分析下 promise.then（微任务）的处理。当执行到 promise.then 时，V8 引擎==不会将异步任务交给浏览器其他线程==，而是将回调==存在自己的一个队列中==，待当前执行栈执行完成后，立马去执行 promise.then 存放的队列，promise.then 微任务没有多线程参与，甚至从某些角度说，微任务都不能完全算是异步，它只是将书写时的代码修改了执行顺序而已。
setTimeout 有“定时等待”这个任务，需要定时器线程执行；ajax 请求有“发送请求”这个任务，需要 HTTP 线程执行，而 promise.then 它没有任何异步任务需要其他线程执行，它只有回调，即使有，也只是内部嵌套的另一个宏任务。
>宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。
>微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。
### 定时器误差
事件循环中，总是先执行同步代码后，才会去任务队列中取出异步回调来执行。当执行 setTimeout 时，浏览器启动新的线程去计时，计时结束后触发定时器事件将回调存入宏任务队列，等待 JS 主线程来取出执行。如果这时主线程还在执行同步任务的过程中，那么此时的宏任务就只有先挂起，这就造成了计时器不准确的问题。同步代码耗时越长，计时器的误差就越大。不仅同步代码，由于微任务会优先执行，所以微任务也会影响计时，假设同步代码中有一个死循环或者微任务中递归不断在启动其他微任务，那么宏任务里面的代码可能永远得不到执行。所以主线程代码的执行效率提升是一件很重要的事情。
![[Pasted image 20251013222341.png]]
一个很简单的场景就是我们界面上有一个时钟精确到秒，每秒更新一次时间。你会发现有时候秒数会直接跳过 2 秒间隔，就是这个原因。
### 视图更新渲染
微任务队列执行完成后，也就是一次事件循环结束后，浏览器会执行视图渲染，当然这里会有浏览器的优化，可能会合并多次循环的结果做一次视图重绘，因此视图更新是在事件循环之后，所以并不是每一次操作 Dom 都一定会立马刷新视图。视图重绘之前会先执行 requestAnimationFrame 回调，那么对于 requestAnimationFrame 是微任务还是宏任务是有争议的，在这里看来，它应该既不属于微任务，也不属于宏任务。
### NodeJS事件模型
在 NodeJS 中 JS 的执行，我们主要需要关心的过程分为以下几个阶段，下面每个阶段都有自己单独的任务队列，当执行到对应阶段时，就判断当前阶段的任务队列是否有需要处理的任务。
- timers 阶段：执行所有 setTimeout() 和 setInterval() 的回调。

- pending callbacks 阶段：某些系统操作的回调，如 TCP 链接错误。除 timers、close、setImmediate 的其他大部分回调在此阶段执行。

- poll 阶段：轮询等待新的链接和请求等事件，执行 I/O 回调等。V8 引擎将 JS 代码解析并传入 Libuv 引擎后首先进入此阶段。如果此阶段任务队列已经执行完了，则进入 check 阶段执行 setImmediate 回调（如果有 setImmediate），或等待新的任务进来（如果没有 setImmediate）。在等待新的任务时，如果有 timers计时到期，则会直接进入 timers 阶段。此阶段可能会阻塞等待。

- check 阶段：setImmediate 回调函数执行。

- close callbacks 阶段：关闭回调执行，如 socket.on(‘close’, …)。
![[Pasted image 20251014163017.png]]
上面每个阶段都会去执行完当前阶段的任务队列，然后继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完了，才会进入下个阶段。
## 尾调用和尾递归
>[尾调用优化 - 阮一峰的网络日志](https://ruanyifeng.com/blog/2015/04/tail-call.html)
### 尾调用
[尾调用](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)（Tail Call）是函数式编程的一个重要概念,就是指某个函数的最后一步是调用另一个函数。
```js
function f(x) {
	return g(x)
}
```
上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。

以下两种情况，都不属于尾调用。
```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}
```
上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，==即使语义完全一样==。情况二也属于==调用后还有操作==，即使写在一行内。

尾调用不一定出现在函数尾部，只要==是最后一步操作==即可。
```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```
上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作.
### 尾调用优化
>也就是说,使用尾调用可以防止函数栈溢出,保证一个递归过程始终只占用一个函数栈的大小

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。

我们知道，函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88)（call stack）。
![[Pasted image 20251015233057.png]]
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```
上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。

这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
### 尾递归
>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
>`arguments`：返回调用时函数的参数。
>`func.caller`：返回调用当前函数的那个函数。
>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以==尾调用模式仅在严格模式下生效==。

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。
```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
```
上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。

如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。
```js
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
```
![[Pasted image 20251015233437.png]]
**递归函数改写为尾递归**
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？

两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。
```js
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
```
上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。

函数式编程有一个概念，叫做[柯里化](https://en.wikipedia.org/wiki/Currying)（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
```
上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。
第二种方法就简单多了，就是采用ES6的函数默认值。
```js
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```
上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持"尾调用优化"的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。
## GC
### 堆内存的组成
以最常用的V8引擎为例，堆内存中大致可以划分为：
- **新生代内存区（New Space / Young Generation）**
- **老生代内存区（Old Space / Old Generation）**
- 大对象区（Large Object Space）
- 映射区（Map Space）
- 代码区（Code Space）
- 其他区域
![[Pasted image 20251016000856.png]]
#### 新生代内存区（New Space / Young Generation）
- 存放存活时间短的小对象（如临时变量、局部对象）。
- **GC 触发条件：** From Space 分配满时触发 Scavenge 回收。
- 副垃圾回收器进行管理内存。
##### 结构
- 由大小相等的分配区（From Space）和存活区（To Space）构成。
    - From Space 为当前**活跃的分配区**，新对象在此创建；
    - To Space 是当前**闲置的回收区**，用于存储 GC 时存活的对象。
- **新生代内存区的特点：** 回收频率很高，速度很快，但是空间利用率很低，因为有一半的内存空间处于"闲置"状态。这里的“闲置”状态就是指 GC 触发时，占据新生代内存区一半空间的 To Space 处于临时闲置状态，准备要与 From Space 交替使用。
![[Pasted image 20251016001004.png]]
##### GC算法
- 新生代内存区采用 **Scavenge 算法**进行管理。
    - **GC 触发：** 新的对象会**优先分配**至 分配区（From Space），GC 触发时，From Space 中**存活的对象（仍被引用的对象）** 会被复制到 To Space 中，其引用地址也更新为新地址。而后**未被引用的对象**以及**被复制完的存活对象**则像垃圾一样被 GC 直接清除，其占据的空间也被一并释放，**整个 From Space** 都将被清空。
    - **GC 结束：** 分配区（From Space）和存活区（To Space）将会进行两极反转。**原来的 To Space**（其中存储着从上次GC中存活的对象）变为**新的 From Space**，等待新对象的到来，而**原来的 From Space**（已在GC中被清空）变为**新的 To Space**，等待下一次 GC 时接收存活对象。
    - Scavenge 算法确保了新生代内存区在不出意外的情况下，可以无限重复使用下去。如此循环GC多次，在此期间存活多次的存活对象将晋升到老生代（对象晋升策略）。
#### 老生代内存区（Old Space / Old Generation）
- 存放生命周期长的大对象。
- **GC 触发条件：** 老生代内存占用超过阈值、或新生代晋升对象过多时触发标记 - 清除 - 整理。
- 主垃圾回收器进行管理内存。
##### 对象晋升策略
前面我们提到，在多次GC之后存活下来的存活对象将会晋升到老生代内存区，我们将其称为对象晋升策略。这其实有些偏颇了，对象的晋升情况不是只有单单的多次GC存活。

- **情况1 GC多次存活（年龄晋升）：** 对象每经历一次 Scavenge GC 后仍存活，其 GC计数器 + 1，其数值可以称之为 **“年龄”** ，当**年龄超过阈值**（默认为15次，但实际上在V8引擎的动态调整中会少得多，可能2次就行了）时，对象会被晋升到老生代，可以把这个过程称之为“熬资历”。
    
- **情况2 大对象：** 若对象的初始大小超过了新生代单个页的容量（“页”为内存分配的单位，在64位下新生代的页通常为1 MB），V8会直接将其分配到老生代，不经过新生代。
    
- **情况3 To Space占用过多：** 如果 GC 时，To Space 内的占用率超过了阈值（一般为25%），存活对象会被提前晋升到老生代（即使其年龄未达标）。
    
- **晋升策略决策树：**
![[Pasted image 20251016001650.png]]
##### 结构
- 基于v8 11.0+引擎的老生代结构如下
![[Pasted image 20251016001826.png]]

| 分区名称                   | 存储内容                                        | 垃圾回收策略                   |
| ---------------------- | ------------------------------------------- | ------------------------ |
| **Old Space**          | 长期存活的普通对象（含引用关系），如闭包、全局变量引用的对象              | （标记-清除）+（标记-整理）          |
| **Code Space**         | JIT 编译后的机器码（优化后的函数）                         | 单独标记，与数据区回收策略分离          |
| **Large Object Space** | 大小超过`kMaxRegularHeapObjectSize`（默认约 1MB）的对象 | 每个对象独占内存页，直接标记清除         |
| **Map Space**          | 对象的 Map 元数据（描述属性布局、原型链等）                    | 与 Old Space 协同回收，优化元数据访问 |
| **Cell Space**         | 小尺寸数据（如 SMI 整数、指针）                          | 部分版本中与老生代协同管理            |

老规矩，我们不可能全拿下所有的分区，大多数分区其实也很难用到，了解一下就差不多了。我们要着重了解的其实是 **Old Space** 分区所使用的 GC 算法 **标记-清除-整理**。
##### GC 算法
因为老生代区的内存大小和其中存储的对象大小远超新生代区，所以 **Scavenge 算法**所进行的对半开的频繁批量复制区内的对象操作太简单粗暴，也太耗费时间了。为了性能着想，老生代需要采用更适合的 GC 操作，也就是**标记-清除-整理**。

- **标记-清除-整理：** “标记-清除-整理” 其实是指一个 **GC 过程**，真正的 GC 算法要分为 **标记-清除** 以及 **标记-整理** 两个算法。
    - **标记-清除（Mark-Sweep）：** 这是最常用的算法，简单来说就是在要清除对象上做好标记，然后再进行清除。
        - **标记阶段：** 从根对象（如全局变量、调用栈中的变量）开始，==递归标记==所有可达对象。
        - **清除阶段：** 遍历整个堆内存，回收未被标记的对象。
    - **标记-整理（Mark-Compact）：** 这是为了解决**标记-清除**算法操作之后，堆内存中出现的碎片化问题而设计的算法。简单来说就是，将呈碎片化分布的对象打好标记，然后 V8 引擎将会出手将碎片化分布的对象重新排列好。
        - **标记阶段：** 同上面的**标记-清除**算法的标记阶段。
        - **整理阶段：** 将所有存活对象移动到内存的一端，然后清除边界外的内存。
**优化**
众所周知，JS 的 V8 引擎为**单线程**，也就是我们常说的**主线程**。那么问题来了，现在主线程又要运行你的 JS 代码，又要去管理堆内存。线程只有一个，它是否会分身乏术呢？  
答案是肯定的，前面提到的 Scavenge 算法以及标记-清除、标记-整理算法都会造成主线程阻塞，因为 V8 引擎的垃圾回收器在执行这些算法时**必须暂停主线程的执行**，引起**全局阻塞**（也就是前面介绍自动内存管理时的 **STW**）。
其中**标记-清除、标记-整理**这两个算法造成的 STW 尤其严重，因为标记阶段需要从根对象（如全局变量、调用栈）出发，**递归遍历整个对象图**，标记所有可达对象。对于大型应用，这个过程所要花费的时间可能要数百毫秒甚至更长时间，导致出现了明显的 STW。
这时候聪明的 JS 设计师就采用了**增量标记算法**来对**标记-清除-整理**这个过程进行优化。

- **增量标记算法（Incremental Marking）：** 将标记过程**碎片化**，每次只标记一小部分对象，然后暂停标记，让主线程执行一段时间，以此减少 STW 的时间，如此循环直到标记完成。
    - **过程：**
        - **1. 初始标记（STW）**
            - 暂停主线程，标记所有根对象（如全局变量、当前调用栈中的变量）。
            - 这个阶段通常非常快，因为根对象数量较少。
        - **2. 增量标记（与主线程交替执行）**
            - 垃圾回收器每次标记一小部分对象（例如，先遍历 100 个对象），然后暂停，让主线程继续执行。
        - **3. 重新标记（STW）**
            - 再次暂停主线程，处理在增量标记阶段由写屏障记录的引用变化，确保所有可达对象都被标记。
            - 这个阶段比初始标记稍长，但远短于传统标记的总时间。
        - **4. 清除 / 整理阶段**
            - 回收未标记的对象，或整理内存空间。这个阶段也可以采用增量方式或并发执行（取决于具体实现）。
![[Pasted image 20251016104402.png]]
### 引用计数

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```
const arr = [1, 2, 3, 4];
console.log('hello world');
```

上面代码中，数组`[1, 2, 3, 4]`是一个值，会占用内存。变量`arr`是仅有的对这个值的引用，因此引用次数为`1`。尽管后面的代码没有用到`arr`，它还是会持续占用内存

如果需要这块内存被垃圾回收机制释放，只需要设置如下：

```
arr = null
```

通过设置`arr`为`null`，就解除了对数组`[1,2,3,4]`的引用，引用次数变为 0，就被垃圾回收了
## 本地缓存
### cookie
HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是==服务器发送到用户浏览器并保存在本地==的一小块数据。浏览器会存储 cookie 并在==下次向同一服务器再发起请求时携带并发送到服务器==上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于[无状态](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84)的 HTTP 协议记录稳定的状态信息成为了可能。

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `cookie`有效期、安全性、使用范围的可选属性组成

但是`cookie`在每次请求中都会被发送，如果不使用 `HTTPS`并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 `cookie`保持登录态的网站上，如果 `cookie`被窃取，他人很容易利用你的 `cookie`来假扮成你登录网站

关于`cookie`常用的属性如下：
>当 Cookie 的过期时间（ `Expires`）被设定时，设定的日期和时间==只与客户端相关，而不是服务端==。
- Expires 用于设置 Cookie 的过期时间

```js
Expires=Wed, 21 Oct 2015 07:28:00 GMT
```

- Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比`Expires`高）

```js
Max-Age=604800
```

- `Domain`指定了 `Cookie` 可以送达的主机名
- `Path`指定了一个 `URL`路径，这个路径必须出现在要请求的资源的路径中才可以发送 `Cookie` 首部

```js
Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部
```

- 标记为 `Secure`的 `Cookie`只应通过被`HTTPS`协议加密过的请求发送给服务端

通过上述，我们可以看到`cookie`又开始的作用并不是为了缓存而设计出来，只是借用了`cookie`的特性实现缓存

关于`cookie`的使用如下：

```js
document.cookie = '名字=值';
```

关于`cookie`的修改，首先要确定==`domain`和`path`属性都是相同==的才可以，其中有一个不同得时候都会创建出一个新的`cookie`

```js
Set-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置
document.cookie ='name=bb; domain=aa.net; path=/'  # 客户端设置
```
>直接使用document.cookie 赋值 会将新值拼接在已有的cookie上而不是替换

最后`cookie`的删除，最常用的方法就是给`cookie`设置一个过期的事件，这样`cookie`过期后会被浏览器删除
### localStorage
`HTML5`新方法，IE8及以上浏览器都兼容
**特点**
- 生命周期：持久化的本地存储，除非主动删除数据，否则==数据是永远不会过期==的
- 存储的信息在==同一域中是共享==的
- 当本页操作（新增、修改、删除）了`localStorage`的时候，本页面不会触发`storage`事件,但是别的页面会触发`storage`事件。
- 大小：5M（跟浏览器厂商有关系）
- `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- 受同源策略的限制

下面再看看关于`localStorage`的使用

设置

```js
localStorage.setItem('username','cfangxu');
```

获取

```js
localStorage.getItem('username')
```

获取键名

```js
localStorage.key(0) //获取第一个键名
```

删除

```js
localStorage.removeItem('username')
```

一次性清除所有存储

```js
localStorage.clear()
```

`localStorage` 也不是完美的，它有两个缺点：

- 无法像`Cookie`一样设置过期时间
- 只能存入字符串，无法直接存对象

```js
localStorage.setItem('key', {name: 'value'});
console.log(localStorage.getItem('key')); // '[object, Object]'
```
### sessionStorage

`sessionStorage`和 `localStorage`使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，`sessionStorage` 将会删除数据
### 区别

关于`cookie`、`sessionStorage`、`localStorage`三者的区别主要如下：

- 存储大小：`cookie`数据大小不能超过`4k`，`sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大
    
- 有效时间：`localStorage`存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； `sessionStorage`数据在当前浏览器窗口关闭后自动删除；`cookie`设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭
    
- 数据与服务器之间的交互方式，`cookie`的数据会自动的传递到服务器，服务器端也可以写`cookie`到客户端； `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存
### indexedDB

`indexedDB`是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索

虽然 `Web Storage`对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。`IndexedDB`提供了一个解决方案

优点：

- 储存量理论上没有上限
- 所有操作都是异步的，相比 `LocalStorage` 同步操作性能更高，尤其是数据量较大时
- 原生支持储存`JS`的对象
- 是个正经的数据库，意味着数据库能干的事它都能干

缺点：

- 操作非常繁琐
- 本身有一定门槛

关于`indexedDB`的使用基本使用步骤如下：

- 打开数据库并且开始一个事务
- 创建一个 `object store`
- 构建一个请求来执行一些数据库操作，像增加或提取数据等。
- 通过监听正确类型的 `DOM` 事件以等待操作完成。
- 在操作结果上进行一些操作（可以在 `request`对象中找到）
### 应用场景
在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：

- 标记用户与跟踪用户行为的情况，推荐使用`cookie`
- 适合长期保存在本地的数据（令牌），推荐使用`localStorage`
- 敏感账号一次性登录，推荐使用`sessionStorage`
- 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用`indexedDB`
## 函数式编程
函数式编程强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程,简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果
```js
// 命令式编程
var array = [0, 1, 2, 3]
for(let i = 0; i < array.length; i++) {
    array[i] = Math.pow(array[i], 2)
}

// 函数式方式
[0, 1, 2, 3].map(num => Math.pow(num, 2))
```
### 优点
- 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况
- 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响
- 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性
- 隐性好处。减少代码量，提高维护性
### 缺点：
- 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作
## 模块化方式
### AMD
>Asynchronous Module Definition,异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行,代表库为`require.js`
```js
/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config({
  baseUrl: "js/lib",
  paths: {
    "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js
    "underscore": "underscore.min",
  }
});
// 执行基本操作
require(["jquery","underscore"],function($,_){
  // some code here
});
```
### CommonJs
>`CommonJS` 是一套 `Javascript` 模块规范，用于服务端
```js
// a.js
module.exports={ foo , bar}

// b.js
const { foo,bar } = require('./a.js')
```
其有如下特点：
- 所有代码都运行在模块作用域，不会污染全局作用域
- 模块是==同步==加载的，即只有加载完成，才能执行后面的操作
- 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存
- `require`返回的值是被输出的值的==拷贝==，模块内部的变化也不会影响这个值
### ES6 Module
>ES6 在语言标准的层面上，实现了`Module`，即模块功能，完全可以取代 `CommonJS`和 `AMD`规范，成为浏览器和服务器通用的模块解决方案.`CommonJS` 和`AMD` 模块，都只能在运行时确定这些东西。`ES6`设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，使得静态分析成为可能。

模块功能主要由两个命令构成：
- `export`：用于规定模块的对外接口
- `import`：用于输入其他模块提供的功能
#### export
一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量
```js
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };
```
通过`as`可以进行输出变量的重命名
```js
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
```
#### import
使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块
```js
// main.js
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
```
同样如果想要输入变量起别名，通过`as`关键字
```js
import { lastName as surname } from './profile.js';
```
当加载整个模块的时候，需要用到星号`*`
```js
// circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

// main.js
import * as circle from './circle';
console.log(circle)   // {area:area,circumference:circumference}
```
>导入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性,不过建议即使能修改，但我们不建议。
>在编译阶段，`import`会提升到整个模块的头部，首先执行,多次重复执行同样的导入，只会执行一次

上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载
如果不需要知道变量名或函数就完成加载，就要用到`export default`命令，为模块指定默认输出
```js
// export-default.js
export default function () {
    console.log('foo');
}
```
加载该模块的时候，`import`命令可以为该函数指定任意名字
```js
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```
**复合写法**
>如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起,同理能够搭配`as`、`*`搭配使用
```js
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```
## TreaShaking的实现
### 阶段一：依赖收集与静态分析
```js
// 源代码结构
// math.js
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;
export const square = (x) => x * x;

// main.js
import { add, multiply } from './math.js';

console.log(add(1, 2));
console.log(multiply(3, 4));
```
**构建工具分析过程**：
1. 构建依赖图，识别所有 import/export
2. 标记 `add` 和 `multiply` 为 **已使用**
3. 标记 `square` 为 **未使用**
### 阶段二：死代码消除
```js
// 输出结果（简化版）
// math.js 中被 Tree Shaking 后的代码
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
// square 函数被完全移除

// main.js 保持不变
console.log(add(1, 2));
console.log(multiply(3, 4));
```
### 标记的具体过程
#### 1. 构建抽象语法树（AST）
```js
// 源代码
export function used() { console.log('used'); }
export function unused() { console.log('unused'); }

// AST 结构（简化）：
{
  type: 'Program',
  body: [{
    type: 'ExportNamedDeclaration',
    declaration: {
      type: 'FunctionDeclaration',
      id: { name: 'used' }
    }
  }, {
    type: 'ExportNamedDeclaration', 
    declaration: {
      type: 'FunctionDeclaration',
      id: { name: 'unused' }
    }
  }]
}
```
#### 2. 建立模块依赖图
```js
// 依赖图数据结构
class ModuleGraph {
  constructor() {
    this.modules = new Map();
    this.usedExports = new Set();
  }
  
  addModule(module) {
    this.modules.set(module.id, {
      exports: new Map(),
      imports: new Map(),
      isUsed: false
    });
  }
  
  markUsed(exportName) {
    this.usedExports.add(exportName);
  }
}
```
#### 3. 标记算法的核心实现
>静态可达性分析
1. 简单的标记扫描算法
```js
class TreeShaker {
  constructor(entryModule) {
    this.entry = entryModule;
    this.visited = new Set();
    this.used = new Set();
  }
  
  // 标记入口开始的可达导出
  markFromEntry() {
    this.traverseModule(this.entry);
  }
  
  traverseModule(module) {
    if (this.visited.has(module.id)) return;
    this.visited.add(module.id);
    
    // 标记该模块的所有直接使用
    for (const importSpec of module.imports) {
      this.markExportAsUsed(importSpec.source, importSpec.imported);
    }
    
    // 递归处理依赖
    for (const dependency of module.dependencies) {
      this.traverseModule(dependency);
    }
  }
  
  markExportAsUsed(moduleId, exportName) {
    const key = `${moduleId}#${exportName}`;
    this.used.add(key);
  }
  
  // 判断导出是否被使用
  isExportUsed(moduleId, exportName) {
    const key = `${moduleId}#${exportName}`;
    return this.used.has(key);
  }
}
```
## Vue项目打包全过程
1. **依赖解析与加载**  
    当你运行 `npm run build`，Webpack 会从配置的入口文件（通常是 `src/main.js`）开始，递归解析所有 `import` 或 `require` 语句，构建项目的**依赖图**。对于遇到的 `.vue` 文件，**vue-loader** 会将其中的 `<template>`、`<script>` 和 `<style>` 块拆分出来，交给对应的 loader 处理。
2. **编译与转换**
    - **模板编译**：`vue-template-compiler` 将 `<template>` 中的HTML-like语法转换为 **JavaScript 渲染函数**。这个过程也涉及静态分析，以优化运行时性能。
    - **脚本处理**：`<script>` 块中的代码通常由 **Babel** 处理，将新版 JavaScript（如 ES6+）转换为兼容性更好的语法。Babel 也负责处理 Vue 的单文件组件语法。
    - **样式处理**：`<style>` 块中的 CSS 可能由 **css-loader**（解析 CSS）、**style-loader** / **mini-css-extract-plugin**（将 CSS 注入 DOM 或提取为独立文件）等处理。如果使用了 Less、Sass 等预处理器，也会有对应的 loader 处理。
3. **资源优化与打包**  
    Webpack 将编译后的模块、资源整合到一起，这个过程涉及多种优化技术：
    - **代码分割（Code Splitting）**：将代码拆分成多个块，实现按需加载。
    - **Tree Shaking**：移除 JavaScript 上下文中未引用的代码（dead-code）。
    - **压缩（Minification）**：使用 **TerserWebpackPlugin** 等工具压缩和混淆 JavaScript 代码，减小文件体积。CSS 和 HTML 也会被压缩。
    - **静态资源处理**：图片、字体等文件可能由 loader（如 `file-loader`）处理，并可能被压缩、添加哈希名用于缓存优化。
4. **生成 dist 目录**  
    经过上述处理，Webpack 会输出最终的打包文件到 `dist` 目录。
## Http缓存机制
### 概念
HTTP 缓存机制是客户端（通常是浏览器）与服务器之间协作，通过缓存策略减少重复请求、降低延迟和节省带宽的技术。缓存可以存在多层（浏览器、本地缓存；中间代理缓存，如 CDN；服务器端缓存等）。
总体来说，HTTP 缓存主要分为两大类：
1. **强制缓存（Freshness / 强缓存）**
	在缓存还没过期的时候，客户端可以直接使用缓存，不与服务器通信。
2. **协商缓存（Validation / 对比缓存）**
	当缓存过期或无明确过期时间时，客户端会向服务器询问资源是否变化（带上某些验证值），服务器通过验证后决定返回 304（Not Modified）还是新的资源。
### 关键 HTTP 头
在缓存机制中，以下几个 HTTP 头非常关键：

| 首部                  | 作用 / 含义                                                                                                         |
| ------------------- | --------------------------------------------------------------------------------------------------------------- |
| `Cache-Control`     | HTTP/1.1 的主要缓存控制头，能很灵活地控制资源是否缓存、缓存多久、缓存策略等。                                                                     |
| `Expires`           | HTTP/1.0 的过期机制，指定一个绝对时间（日期）为过期时间。                                                                               |
| `Last-Modified`     | 表示资源最后一次修改的时间。服务器响应时返回，客户端下次请求可以带 `If-Modified-Since`。                                                          |
| `If-Modified-Since` | 客户端请求头，用于告诉服务器上次缓存资源的最后修改时间。服务器可以根据此判断资源是否已变更。                                                                  |
| `ETag`              | 资源的实体标签（实体标签可以是某种哈希或标识符），表示资源内容的版本。服务器给出一个标识符。                                                                  |
| `If-None-Match`     | 客户端请求头，把之前的 `ETag` 值带给服务器，服务器比对是否相同。若相同，则返回 304。                                                                |
| `Pragma`            | 兼容性头（主要 HTTP/1.0），例如 `Pragma: no-cache`。现代主要用 `Cache-Control` 控制。                                               |
| `Vary`              | 用于告诉缓存机制：某些请求头（如 `Accept-Encoding`、`User-Agent` 等）不同会导致不同版本的响应，应分别缓存。虽然不是必选，但在复杂场景（CDN、代理）非常重要。 （这一点在缓存优化中常被提到） |
### 强制缓存（Freshness）
>强制缓存用于在资源仍旧被认为“新鲜”（未过期）的情况下，完全不跟服务器通信就使用本地缓存。
- `Cache-Control: max-age=秒数`：表示资源在多少秒内被认为是新的。
- `Cache-Control: public` / `private`：指定响应是否可以被公共缓存（如 CDN、代理）缓存（`public`），还是只能在私有缓存中（如浏览器）缓存（`private`）
- `Cache-Control: no-store`：表示该资源不应该被缓存（无论是客户端缓存还是中间缓存，都不存储）。
- `Cache-Control: no-cache`：虽然名字是 “no-cache”，但是它允许缓存，只是每次使用缓存前必须先向服务器验证。也就是协商缓存的一种形式。
- `Expires`：指定缓存过期的具体时间；在 HTTP/1.1 中，如果同时有 `Cache-Control: max-age`，则 `max-age` 优先。

**优先级**（缓存控制头）：
1. `Pragma`（如果存在）优先。
2. `Cache-Control`
3. `Expires`
### 协商缓存（Validation / 对比缓存）
当资源不再被强制缓存（已经过期 / 没有明确过期时间 / `no-cache` 等情况）时，客户端会发起验证请求，询问服务器资源是否有变更。
- 客户端在请求头中加入 `If-Modified-Since`（基于 `Last-Modified`）或 `If-None-Match`（基于 `ETag`）。
- 服务器收到后，比较：
    - 如果资源 **未变更**：返回 **304 Not Modified**，不返回资源内容。客户端可以继续使用本地缓存。
    - 如果资源 **已变更**：返回 **200** 和新的资源，同时返回新的 `ETag` / `Last-Modified`。
**为什么同时使用 `Last-Modified` 和 `ETag`？**
- `Last-Modified` 是时间戳，比较简单。但存在问题，比如修改非常快（短时间内改动），或者服务器与客户端时间不一致，都可能导致不准确。
- `ETag` 是实体标签（通常是内容的 hash），更精确；但计算成本可能比 `Last-Modified` 高。
- 所以，**推荐做法**：优先使用 `ETag`，`Last-Modified` 作为 fallback（后备）。
**验证流程优先级**：
- `If-None-Match` / `ETag` 的优先级高于 `If-Modified-Since` / `Last-Modified`。
### 缓存流程总结（浏览器视角）
1. **第一次请求**  
    浏览器请求资源，服务器返回响应并带上缓存相关头（比如 `Cache-Control`、`Expires`、`ETag`、`Last-Modified` 等）
2. **判断是否仍在强制缓存期**  
    浏览器检查响应头中的 `Cache-Control`（或者 `Expires`）来决定本地缓存是否还有效。
    - 如果还没过期：**直接使用缓存**，不发请求。
    - 如果过期（或是 `no-cache`）：进入协商缓存阶段。
3. **协商缓存（验证）**  
    浏览器向服务器发带验证头的新请求（`If-None-Match` / `If-Modified-Since`）。
    - 服务器对比：如果没变更 → 返回 **304**，浏览器继续使用本地缓存。
    - 如果变更 → 返回 **200** 和新的资源，浏览器替换本地缓存。
4. **特殊/控制场景**
    - 如果客户端强制刷新（例如 Ctrl+F5）：浏览器可能忽略缓存验证，强制拉取最新资源。
    - 对于 HTTP/1.0 客户端或代理，可能只识别 `Expires` 而不识别 `Cache-Control`。
### 缓存优化策略 & 实践建议
- **静态资源（比如 JS、CSS、图片）**：可以设置较长的 `max-age`（例如一年），并对资源进行版本管理（比如在资源 URL 加版本号 / hash），这样客户端可以长期缓存。 
- **动态内容**（经常变化的数据）：建议使用 `ETag` 或 `Last-Modified`，配合较短缓存，保证内容及时更新。
- **控制缓存可见性**：使用 `public` / `private` 来决定哪些缓存可以被公共缓存（CDN、代理）使用。
- **避免缓存敏感信息**：对敏感数据（用户私人数据、认证信息等）使用 `no-store`，避免被缓存。
- **使用 `Vary` 头**：如果响应会根据请求头（如 `Accept-Encoding`、`User-Agent`、`Cookie` 等）变化，那么设置 `Vary` 很重要，以防缓存错用。
- **监控和调试**：通过浏览器开发者工具（Network 面板）观察是否命中了缓存（cache hit）、返回的状态码是否是 304、响应头是否如预期。
## 使用TS时给全局windows挂载数据后使用时会报错(因为定义的结构中没有),怎么处理?
>TypeScript 报错是因为内置的 `Window` / 全局类型里没有你挂载的属性 —— 解决办法就是告诉 TypeScript 这个属性的类型（类型声明/增强），或者用类型断言跳过检查。
### 在声明文件里扩展 `Window`（或 `globalThis`）
把类型声明放在 `.d.ts`（或 `.ts` 模块 + `declare global`）里，这样对整个项目生效、干净且类型安全。
1. 方式 A — 在全局 ambient `.d.ts` 中直接扩展（简单）
```ts
// src/types/globals.d.ts   （文件名任意，但后缀必须是 .d.ts）
interface Window {
  __APP_CONFIG__?: {
    apiUrl: string;
    env: 'dev' | 'prod';
    featureFlag?: boolean;
  };
}
```
然后就可以安全使用：
```ts
console.log(window.__APP_CONFIG__?.apiUrl);
```
>**注意**：确保该 `.d.ts` 被 `tsconfig.json` 的 `include` 捕获（默认 `include: ["src"]` 通常可以）。
>TS 会把你的内容 **合并** 到系统内置的 Window 类型中。而不是覆盖原有类型
2. 方式 B — 如果文件是模块（含 import/export），用 `declare global`
```ts
// src/types/globals.ts
export {}; // 把这个文件当作模块
type AppConfig = { apiUrl: string; env: 'dev'|'prod' };

declare global {
  interface Window {
    __APP_CONFIG__?: AppConfig;
  }
}
```
3. 方式 C — 使用 `globalThis`（跨环境更现代）
```ts
// src/types/globals.d.ts
type AppConfig = { apiUrl: string; env: 'dev'|'prod' };

declare global {
  var __APP_CONFIG__: AppConfig | undefined; // 全局变量
}
// 使用时
globalThis.__APP_CONFIG__?.apiUrl;
```
### 快速/临时方案
>这些方式会跳过编译器检查，适合快速验证，但丢失类型安全。
1. 类型断言
```ts
(window as any).__APP_CONFIG__ = { apiUrl: '/api' };
console.log((window as any).__APP_CONFIG__.apiUrl);
```
2. `// @ts-ignore` 在行前忽略错误
## fetch axios xhr区别
### XMLHttpRequest (XHR)

#### 基本介绍

XHR 是最古老的浏览器 API，用于在后台与服务器交换数据。

#### 基本用法
```js
// 创建 XHR 对象
const xhr = new XMLHttpRequest();

// 配置请求
xhr.open('GET', 'https://api.example.com/data', true);

// 设置请求头
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.setRequestHeader('Authorization', 'Bearer token');

// 处理响应
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) { // 请求完成
    if (xhr.status === 200) {
      console.log('成功:', JSON.parse(xhr.responseText));
    } else {
      console.error('错误:', xhr.status);
    }
  }
};

// 处理错误
xhr.onerror = function() {
  console.error('请求失败');
};

// 发送请求
xhr.send();

// 发送 POST 数据
const data = JSON.stringify({ name: 'John' });
xhr.send(data);
```
#### 进度监控
```js
xhr.upload.onprogress = function(event) {
  if (event.lengthComputable) {
    const percentComplete = (event.loaded / event.total) * 100;
    console.log(`上传进度: ${percentComplete}%`);
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    const percentComplete = (event.loaded / event.total) * 100;
    console.log(`下载进度: ${percentComplete}%`);
  }
};
```
#### 超时设置
```js
xhr.timeout = 5000; // 5秒超时
xhr.ontimeout = function() {
  console.error('请求超时');
};
```
### Fetch API

#### 基本介绍

Fetch 是现代浏览器提供的更简洁的 API，基于 Promise。

#### 基本用法
```js
// GET 请求
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('网络响应不正常');
    }
    return response.json();
  })
  .then(data => console.log('成功:', data))
  .catch(error => console.error('错误:', error));

// 使用 async/await
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('网络响应不正常');
    const data = await response.json();
    console.log('成功:', data);
  } catch (error) {
    console.error('错误:', error);
  }
}
```
#### 完整配置
```js
// POST 请求 with headers
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify({
    name: 'John',
    email: 'john@example.com'
  }),
  credentials: 'include', // 包含 cookies
  mode: 'cors', // CORS 模式
  cache: 'no-cache' // 缓存控制
})
.then(response => response.json())
.then(data => console.log(data));
```
#### 超时处理
```js
// 自定义超时函数
function fetchWithTimeout(url, options = {}, timeout = 5000) {
  return Promise.race([
    fetch(url, options),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('请求超时')), timeout)
    )
  ]);
}

// 使用
fetchWithTimeout('https://api.example.com/data', {}, 5000)
  .then(response => response.json())
  .catch(error => console.error('超时或错误:', error));
```
#### 取消请求
```js
javascript

// 使用 AbortController
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('请求被取消');
    } else {
      console.error('其他错误:', error);
    }
  });

// 取消请求
controller.abort();
```
### Axios
#### 基本介绍
Axios 是基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用。
#### 基本用法
```js
// GET 请求
axios.get('https://api.example.com/data')
  .then(response => console.log('成功:', response.data))
  .catch(error => console.error('错误:', error));

// POST 请求
axios.post('https://api.example.com/users', {
  name: 'John',
  email: 'john@example.com'
}, {
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  }
})
.then(response => console.log(response.data));
```
#### 完整配置
```js
// 全局配置
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.timeout = 5000;
axios.defaults.headers.common['Authorization'] = 'Bearer token';

// 实例配置
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
  headers: {'X-Custom-Header': 'value'}
});

// 请求配置
axios.get('/data', {
  params: {
    page: 1,
    limit: 10
  },
  timeout: 3000,
  responseType: 'json'
});
```
#### 拦截器
```js
// 请求拦截器
axios.interceptors.request.use(
  config => {
    // 在发送请求前做些什么
    config.headers.Authorization = `Bearer ${getToken()}`;
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

// 响应拦截器
axios.interceptors.response.use(
  response => {
    // 对响应数据做点什么
    return response;
  },
  error => {
    // 对响应错误做点什么
    if (error.response?.status === 401) {
      // 处理未授权
      logout();
    }
    return Promise.reject(error);
  }
);
```
#### 取消请求
```js
javascript

// 方法1: CancelToken (旧版)
const source = axios.CancelToken.source();

axios.get('/data', {
  cancelToken: source.token
}).catch(error => {
  if (axios.isCancel(error)) {
    console.log('请求取消:', error.message);
  }
});

// 取消请求
source.cancel('操作被用户取消');

// 方法2: AbortController (新版)
const controller = new AbortController();

axios.get('/data', {
  signal: controller.signal
}).catch(error => {
  if (error.name === 'CanceledError') {
    console.log('请求被取消');
  }
});

// 取消请求
controller.abort();
```
### 详细对比

|特性|XHR|Fetch|Axios|
|---|---|---|---|
|**浏览器支持**|所有浏览器|现代浏览器|所有浏览器 (通过 polyfill)|
|**Node.js 支持**|❌ 不支持|❌ 不支持|✅ 支持|
|**Promise 支持**|❌ 需要封装|✅ 原生支持|✅ 基于 Promise|
|**请求取消**|✅ 支持|✅ AbortController|✅ CancelToken/AbortController|
|**超时设置**|✅ 原生支持|❌ 需要实现|✅ 原生支持|
|**进度监控**|✅ 原生支持|❌ 需要实现|✅ 原生支持|
|**自动 JSON**|❌ 需要手动解析|✅ response.json()|✅ 自动转换|
|**拦截器**|❌ 不支持|❌ 不支持|✅ 请求/响应拦截器|
|**CSRF 防护**|❌ 手动处理|❌ 手动处理|✅ 内置支持|
|**并发请求**|❌ 需要实现|✅ Promise.all|✅ axios.all|
|**错误处理**|手动检查状态码|不抛出 HTTP 错误|自动抛出 HTTP 错误|
## ## Map 和 Object 的区别

### 基本区别对比

| 特性       | Map                 | Object                        |
| -------- | ------------------- | ----------------------------- |
| **键的类型** | 任意类型 (对象、函数等)       | String 或 Symbol               |
| **键的顺序** | 插入顺序                | 复杂 (数字键排序 + 插入顺序)             |
| **大小获取** | map.size            | Object.keys(obj).length       |
| **性能**   | 频繁增删时更好             | 创建和访问时稍好                      |
| **序列化**  | 不能直接 JSON.stringify | 可以直接 JSON.stringify           |
| **迭代**   | 直接可迭代               | 需要 Object.keys/values/entries |
| **原型链**  | 无原型链冲突              | 可能有原型链属性                      |
## any、unknown 和 never

### any 类型
```ts
// any - 放弃类型检查
let anything: any = "hello";
anything = 42;           // ✅
anything = true;         // ✅
anything.foo.bar;        // ✅ 运行时可能出错
anything();              // ✅ 运行时可能出错

// 使用场景：迁移旧代码、第三方库类型
const legacyData: any = JSON.parse('...');
```
### unknown 类型
```ts
// unknown - 类型安全的 any
let notSure: unknown = "hello";
notSure = 42;            // ✅
notSure = true;          // ✅

// ❌ 不能直接操作 unknown 类型
// notSure.toFixed();    // 错误
// notSure();           // 错误

// 需要类型检查或类型断言
if (typeof notSure === "string") {
  console.log(notSure.toUpperCase()); // ✅
}

// 类型断言
(notSure as string).toUpperCase(); // ✅ 但需要确保类型正确
```
### never 类型
```ts
// never - 表示永远不会发生的值
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

// 在联合类型中，never 会被忽略
type T = string | number | never; // 等价于 string | number

// 空数组的推断
const emptyArray = []; // 类型: never[]

//  exhaustive checking
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    default:
      // 如果 Shape 有新的类型，这里会报错
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```
### 类型对比表格

|特性|any|unknown|never|
|---|---|---|---|
|**赋值给其他类型**|✅ 可以|❌ 需要类型检查|❌ 不能|
|**接收任何类型**|✅ 可以|✅ 可以|❌ 不能|
|**调用方法**|✅ 可以|❌ 需要类型检查|❌ 不能|
|**类型安全**|❌ 不安全|✅ 安全|✅ 安全|
|**使用场景**|迁移代码、第三方库|用户输入、API响应|错误处理、穷尽检查|
## vue2和vue3的区别

1. 响应式系统

|特性|Vue 2|Vue 3|
|---|---|---|
|实现方式|`Object.defineProperty`|`Proxy`|
|对象属性|✅ 响应式|✅ 响应式|
|数组索引/length|❌ 不支持，需 `Vue.set`|✅ 全部支持|
|动态添加/删除属性|❌ 需 `Vue.set`|✅ 原生支持|
2. 组件逻辑组织

|特性|Vue 2|Vue 3|
|---|---|---|
|Options API|✅|✅|
|Composition API|❌|✅（可替代 mixin，支持逻辑复用）|
|setup()|❌|✅（函数式初始化组件状态）|
3. 性能优化

| 特性                      | Vue 2 | Vue 3                  |
| ----------------------- | ----- | ---------------------- |
| 静态提升                    | ❌     | ✅（编译时提升静态节点）           |
| 事件监听缓存                  | ❌     | ✅（缓存事件函数减少重复绑定）        |
| block tree & patch flag | ❌     | ✅（只对动态节点 patch，提高渲染性能） |
| Tree-shaking            | ❌     | ✅（未使用功能可剔除）            |
4. SSR / Hydration

| 特性            | Vue 2 | Vue 3                              |
| ------------- | ----- | ---------------------------------- |
| SSR 渲染        | ✅     | ✅（异步渲染 + 流式输出）                     |
| 静态节点优化        | ❌     | ✅（`createStaticVNode` + innerHTML） |
| 客户端 Hydration | ❌     | ✅（只处理动态节点）                         |
5. 体积与现代特性

- Vue 3 更轻量，支持 ES 模块
- 支持 Fragments（多根节点）、Teleport、Suspense
- Proxy 响应式系统更灵活，兼容性略差于 Vue 2（IE11 不支持）
## 如何判断一个元素是否在可视区域内
### offsetTop、scrollTop
`offsetTop`是指元素的上外边框至**包含元素**(上一级dom)的上内边框之间的像素距离，其他`offset`属性如下图所示：
![[Pasted image 20251130214141.png]]
下面再来了解下`clientWidth`、`clientHeight`：
![[Pasted image 20251130214258.png]]
- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`
- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`
>`client`元素都不包括外边距

最后，关于`scroll`系列的属性如下：
![[Pasted image 20251130214405.png]]
- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小
- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置
	- 垂直滚动 `scrollTop > 0`
    - 水平滚动 `scrollLeft > 0`
- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置
>上述属性都是只读的，每次访问都要重新开始

下面再看看如何实现判断：

公式如下：
`el.offsetTop - document.documentElement.scrollTop <= viewPortHeight`
代码实现：
```js
// 逐层遍历el的父元素,计算与顶级元素的上边缘距离
function getElementTop(el) {
  let top = el.offsetTop;
  while (el.offsetParent) {
    el = el.offsetParent;
    top += el.offsetTop;
  }
  return top;
}
function isInViewPortOfOne (el) {
    // viewPortHeight 兼容所有浏览器写法
    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
    const offsetTop = getElementTop(el);
    const scrollTop = document.documentElement.scrollTop
	return offsetTop - scrollTop <= viewPortHeight;
}
```
### getBoundingClientRect
返回值是一个 `DOMRect` 对象，其提供了元素的大小及其相对于**视口**(不是父元素)的位置。包含元素的边界信息。主要属性包括：
- **`x` 和 `y`**:
    - `x`: 元素边界的左侧相对于视口的水平坐标（等同于 `left`）。
    - `y`: 元素边界的顶部相对于视口的垂直坐标（等同于 `top`）。
    - **注意**: 在某些浏览器中，`x` 和 `y` 可能不被支持，使用 `left` 和 `top` 替代即可。
- **`width` 和 `height`**:
    - `width`: 元素的宽度（包括内边距，但不包含滚动条、边框或外边距）。
    - `height`: 元素的高度（包括内边距，但不包含滚动条、边框或外边距）。
- **`top`, `right`, `bottom`, `left`**:
    - `top`: 元素边界的顶部相对于视口的垂直距离。
    - `right`: 元素边界的右侧相对于视口的水平距离。
    - `bottom`: 元素边界的底部相对于视口的垂直距离。
    - `left`: 元素边界的左侧相对于视口的水平距离。
![[Pasted image 20251130215715.png]]
根据`getBoundingClientRect()`返回的对象，我们可以判断元素是否在视口中：

- 如果元素的顶部位置小于等于视口的高度，说明元素的顶部在视口内。
- 如果元素的底部位置大于等于0，说明元素的底部在视口内。

如果同时满足上述两个条件，则可以认为元素至少有一部分在视口中。
```js
function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;

  return (
    rect.bottom >= 0 &&   // 元素底部还没滚到视口上方外面
    rect.top <= viewHeight &&  // 元素顶部已经进入视口下方区域
    rect.right >= 0 &&
    rect.left <= viewWidth
  );
}
```
### Intersection Observer

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比`getBoundingClientRect`会好很多

使用步骤主要分为两步：创建观察者和传入被观察者
#### 创建观察者
```js
let options = {
  root: document.querySelector("#scrollArea"),
  rootMargin: "0px",
  threshold: 1.0,
};

let observer = new IntersectionObserver(callback, options);
```
#### IntersectionObserver 选项

传递到 `IntersectionObserver()` 构造函数的 `options` 对象，可以控制在什么情况下调用观察器的回调。它有以下字段：
- `root`
	用作视口的元素，用于检查目标的可见性。必须是目标的祖先。如果未指定或为 `null`，则**默认为浏览器视口**。
- `rootMargin`
	根周围的边距。其值可以类似于 CSS `margin`属性，例如 `"10px 20px 30px 40px"`（上、右、下、左）。这些值可以是百分比。在计算交叉点之前，这组值用于增大或缩小根元素边框的每一侧。**默认值为全零**。
- `threshold`
	一个数字或一个数字数组，表示目标可见度达到多少百分比时，观察器的回调就应该执行。如果只想在能见度超过 50% 时检测，可以使用 0.5 的值。如果希望每次能见度超过 25% 时都执行回调，则需要指定数组 `[0, 0.25, 0.5, 0.75, 1]`。**默认值为 0**（这意味着只要有一个像素可见，回调就会运行）。值为 1.0 意味着在每个像素都可见之前，阈值不会被认为已通过。
>交叉观察器 API 使用**阈值**，而不是报告目标元素可见度的每一个微小变化。创建观察器时，可以提供一个或多个数值，代表目标元素可见度的百分比。然后，API 只报告超过这些阈值的可见性变化。
#### 定位要观察的元素
创建一个观察器后，需要给定一个目标元素进行观察。
>如果指定了 `root` 选项，目标必须是根元素的后代。
```js
let target = document.querySelector("#listItem");
observer.observe(target);

// 我们为观察器设置的回调将在第一次执行，
// 它将等待我们为观察器分配目标（即使目标当前不可见）
```
每当目标满足该 `IntersectionObserver` 指定的阈值（threshold），回调被调用。回调接收 `IntersectionObserverEntry`对象和观察器的列表：
```js
let callback = (entries, observer) => {
  entries.forEach((entry) => {
    // 每个条目描述一个目标元素观测点的交叉变化：
    //   entry.boundingClientRect
    //   entry.intersectionRatio
    //   entry.intersectionRect
    //   entry.isIntersecting
    //   entry.rootBounds
    //   entry.target
    //   entry.time
  });
};
```
>所有属性都是只读的
- `IntersectionObserverEntry.boundingClientRect`
	返回包含目标元素的边界信息的`DOMRectReadOnly`. 边界的计算方式与 `Element.getBoundingClientRect()`相同。
- `IntersectionObserverEntry.intersectionRatio`
	返回`intersectionRect` 与 `boundingClientRect` 的比例值。
- `IntersectionObserverEntry.intersectionRect`
	返回一个 `DOMRectReadOnly` 用来描述根和目标元素的相交区域。
- `IntersectionObserverEntry.isIntersecting`
	返回一个布尔值，如果目标元素与交叉区域观察者对象 (intersection observer) 的根相交，则返回 `true` .如果返回 `true`, 则 `IntersectionObserverEntry` 描述了变换到交叉时的状态; 如果返回 `false`, 那么可以由此判断，变换是从交叉状态到非交叉状态。
- `IntersectionObserverEntry.rootBounds`
	返回一个 `DOMRectReadOnly`用来描述交叉区域观察者 (intersection observer) 中的根。
- `IntersectionObserverEntry.target`
	与根出现相交区域改变的元素 (`Element`).
- `IntersectionObserverEntry.time`
	返回一个记录从 `IntersectionObserver` 的时间原点 (time origin) 到交叉被触发的时间的时间戳 (`DOMHighResTimeStamp`).
#### 具体代码
```js
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is in viewport');
    } else {
      console.log('Element is not in viewport');
    }
  });
});

observer.observe(document.getElementById('myElement'));
```
## SPA和MPA的区别,MPA的优缺点及实现原理
SPA（single-page application），翻译过来就是单页应用,`SPA`是一种网络应用程序或网站的模型，它通过**动态重写当前页面**来与用户交互，这种方法避免了页面之间切换打断用户体验.在单页应用中，**所有必要的代码**（`HTML`、`JavaScript`和`CSS`）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）**动态装载**适当的资源并添加到页面,页面在任何时间点都不会重新加载，也不会将控制转移到其他页面
![[Pasted image 20251206121719.png]]
MPA（MultiPage-page application），翻译过来就是多页应用,在`MPA`中，**每个页面**都是一个主页面，都是**独立**的,当我们在访问另一个页面的时候，都需要**重新加载**`html`、`css`、`js`文件，公共文件则根据需求按需加载
![[Pasted image 20251206121723.png]]
### 区别
![[Pasted image 20251206121830.png]]
### 单页应用优缺点
优点：
- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快，内容的改变不需要重新加载整个页面
- 良好的前后端分离，分工更明确
缺点：
- 不利于搜索引擎的抓取
- 首次渲染速度相对较慢
### 核心原理
- 监听地址栏中`hash`变化驱动界面变化
-  用`pushsate`记录浏览器的历史，驱动界面发送变化 
![[Pasted image 20251206122122.png]]
### 实现
 `hash` 模式
 >hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，**改变 URL 中的 hash 部分不会引起页面刷新**
 
核心通过监听`url`中的`hash`来进行路由跳转
```js
// 定义 Router  
class Router {  
    constructor () {  
        this.routes = {}; // 存放路由path及callback  
        this.currentUrl = '';  
          
        // 监听路由change调用相对应的路由回调  
        // 当页面所有资源加载完毕时触发 
        window.addEventListener('load', this.refresh, false); 
        // 当 URL 的哈希值（即 # 后面的部分）发生变化时触发
        window.addEventListener('hashchange', this.refresh, false);  
    }  
      
    route(path, callback){  
        this.routes[path] = callback;  
    }  
      
    push(path) {  
        this.routes[path] && this.routes[path]()  
    }  
}  
  
// 使用 router  
window.miniRouter = new Router();  
miniRouter.route('/', () => console.log('page1'))  
miniRouter.route('/page2', () => console.log('page2'))  
  
miniRouter.push('/') // page1  
miniRouter.push('/page2') // page2  
```
`history`模式
`history` 模式核心借用 `HTML5 history api`，`api` 提供了丰富的 `router` 相关属性,先了解几个相关的api
- `history.pushState` 浏览器历史记录添加记录
- `history.replaceState`修改浏览器历史记录中当前记录
- `popState`事件: 当**浏览器点击前进/后退按钮** 或者 `history.back()` / `history.forward()` 时触发。==pushState 和 replaceState 自身不会触发 popstate==
```js
// 定义 Router  
class Router {  
    constructor () {  
        this.routes = {};  
        this.listerPopState()  
    }  
      
    init(path) {  
        history.replaceState({path: path}, null, path);  
        this.routes[path] && this.routes[path]();  
    }  
      
    route(path, callback){  
        this.routes[path] = callback;  
    }  
      
    push(path) {  
        history.pushState({path: path}, null, path);  
        this.routes[path] && this.routes[path]();  
    }  
      
    listerPopState () {  
        window.addEventListener('popstate' , e => {  
            const path = e.state && e.state.path;  
            this.routers[path] && this.routers[path]()  
        })  
    }  
}  
  
// 使用 Router  
  
window.miniRouter = new Router();  
miniRouter.route('/', ()=> console.log('page1'))  
miniRouter.route('/page2', ()=> console.log('page2'))  
  
// 跳转  
miniRouter.push('/page2')  // page2  
```
## Vue Router原理
>本质就是监听 URL 的变化（Hash 或 History），然后根据 URL 匹配组件，把组件渲染到 `<router-view>` 中。

三大核心模块
1. **路由映射表（Routes Map）**
	vue-router会把我们在路由配置里写的对象转为一个map,k为路径,v为组件,用于查找当前路径对应的组件
2. **URL 变化监听（Hash / History）**
	建立hashchange和popstate监听,在回调中修改router.current
3. **响应式地触发 `<router-view>` 重新渲染**
	router.current是一个响应式变量,它通常使用 Vue.observable 或 Vue 的 data 做响应式,一旦 current 改变，依赖它的 `<router-view>` 会自动重新渲染。

`<router-view>` 是一个组件，负责渲染当前路由的组件
伪代码实现：
```js
Vue.component('router-view', {
  render(h) {
    const current = this.$router.current
    const component = this.$router.routeMap[current]
    return h(component)
  }
})
```
## 组件通讯方法以及实现原理
### Pinia实现原理
>Pinia 的本质就是：用 `reactive()` 创建一个响应式对象（state），用 `computed()` 包装 getters，用普通函数包装 actions，然后把这些组合在一起返回。所有组件共享同一个 store 实例。  
![[Pasted image 20251206135703.png]]
1. **每个 store 就是一个响应式对象**
当你写：
```js
const useCounter = defineStore('counter', {
  state: () => ({ count: 0 }),
  getters: {
    double: state => state.count * 2
  },
  actions: {
    increment() { this.count++ }
  }
})
```
Pinia 内部会把它做成：
`const state = reactive({ count: 0 })`
重点：**store 是单例的，全局共享，不会在组件中重复创建。**
2. **getters 会被包装成 computed**
Pinia 内部：
`const double = computed(() => state.count * 2)`
所以它是有缓存的、响应式的。
3. **actions 本质就是普通函数，但 this 绑定到 state 上**
内部会这样处理：
```js
function increment() {
  state.count++
}

const actions = { increment: increment.bind(state) }
```
4. **把 state + getters + actions 合并成一个对象**
Pinia 最终返回给你的 store =
```js
{
  ...toRefs(state),   // 变成 ref，使 state 可解构
  double,             // computed
  increment,          // action
}
```
### Props和emit的实现原理
#### Props
1. 父组件 → 子组件：传入原始 props 数据
当父组件写：`<Child :msg="text" />`,渲染时 Vue 会做两件事：
- 解析 props 的 key
	Vue 会根据 Child 组件自己声明的：`props: { msg: String }`来验证：
	- 值类型是否匹配
	- 是否 required
	- 是否有 default
	- 是否需要转换（例如 Boolean 转换）
-  props 存入 child 的“props 对象”
	Vue3 内部会生成：`instance.props = { msg: text }`
	这个对象是**被 shallowReadonly 包裹的**，防止子组件直接修改 props。
2. props 是响应式的，但受父组件驱动
Vue 会在父组件更新时重新执行子组件的 `update` 逻辑：
	父组件 data 改变 → 重新执行 patch → patch 会把**新的 props 传入子组件** → 更新 `instance.props`。
因此：
- props 本身是“单向的”
- 子组件不能改，只能读 
3. 子组件访问 props：通过 Proxy（Vue3）或 getter（Vue2）实现
Vue3 组件实例是：`const proxy = new Proxy(instance.ctx, ...)`
当你在模板中写：`{{ msg }}`
实际是通过 Proxy 的 getter 访问：`instance.props.msg`
**props 优先级：props → data → computed → methods**
```
父组件 data → 生成 vnode → props 抽取 → 子组件 props 对象
                         ↓
                shallowReadonly 包裹
                         ↓
                 Proxy 暴露给模板
```
#### Emit
>组件内部触发一个字符串事件，Vue 去父组件找对应的回调函数并执行。
1. 父组件注册事件
`<Child @update="onUpdate" />`
Vue 解析这个模板时，会把事件写入 vnode：
```js
vnode.props = { // vnode的props和组件的props不是一个概念
  onUpdate: onUpdate
}
```
注意：事件名字内部会自动规范化成：`on + 大写首字母 onUpdate`
2. 子组件触发事件
`this.$emit('update', value)`
Vue3 内部是：
`instance.emit(eventName, ...args)`
emit 实现逻辑非常短：
① 把事件名转成父组件使用的格式
`'update' → 'onUpdate' 'my-event' → 'onMyEvent'`
② 从父组件 vnode.props 中找到对应函数
`handler = instance.vnode.props['onUpdate']`
③ 调用 handler
`handler(value)`
**Emit 的本质**
- 事件名只是字符串  
- emit **不会冒泡**  
- emit 不影响子组件内部状态  
- 只是让父组件执行它自己的回调函数
### Provide/inject
>provide 是往组件实例的 “provides 对象” 上挂值，  
>inject 是沿着组件父链向上查找 provides。
#### provide
Vue 组件实例都有一个字段：`instance.provides`
每个组件在创建时会：
1. 继承父组件的 provides（使用原型链）
2. 如果自身 provide 了新的 key，则创建一个新的对象来“遮蔽”父级的 provides
这样就实现了“向下传递，不会污染同级或父级”的结构。
当组件调用：`provide('foo', 123)`
Vue 做了：
```js
function provide(key, value) {
  const inst = currentInstance

  // 第一次 provide，需要创建一个“自己的 provides”
  if (inst.provides === inst.parent.provides) {
    inst.provides = Object.create(inst.parent.provides)
  }

  inst.provides[key] = value
}
```
- 子组件默认共享父组件的 provides
- 只有当当前组件提供新值时，才会创建一份自己的 provides
- 通过 `Object.create()` 继承父级
- 这样就能实现多级传递 + 屏蔽式覆盖
#### inject
当子组件调用：inject('foo')
Vue 会：
```js
function inject(key, defaultValue) {
  const inst = currentInstance

  if (key in inst.parent.provides) {
    return inst.parent.provides[key]
  } else if (defaultValue !== undefined) {
    return defaultValue
  }
}
```
因为 inst.parent.provides 是一个 **原型链结构**：
`parent.provides → grandparent.provides → ... → root.provides`
所以 `key in inst.parent.provides` 会自动沿着链查找，直到找到提供者。
整体思路
provide / inject 通过组件实例的 provides 对象实现，  
provides 通过原型链继承上级，  
provide 会为当前组件创建新的 provides 屏蔽父级，  
inject 通过 `in` 检查沿原型链查找值。
### 事件总线(Vue2)
>事件总线就是一个带有 `on/emit/off` 的发布订阅（Pub-Sub）对象，  
>Vue2 多用 new Vue()，Vue3 用 mitt（或自己写,Vue3自身已经不支持事件总线了）。

Vue2 里事件系统本身就有：
- `$on(event, handler)`
- `$emit(event, data)`
- `$off(event, handler)`
- `$once(event, handler)`
所以你只要创建一个新的 Vue 实例：
`const bus = new Vue()`
然后使用它的事件 API：
```js
bus.$on('xxx', handler)
bus.$emit('xxx', data)
```
>它本质是使用 Vue 的内部事件系统实现的“发布-订阅模式”。

**原理**
ue2 对每个实例有一个 `_events`：
`vm._events = Object.create(null)`
 - $on
注册事件监听：
```js
$on(event, fn) {
  if (!this._events[event]) {
    this._events[event] = []
  }
  this._events[event].push(fn)
}
```
- $emit
触发事件：
```js
$emit(event, ...args) {
  const fns = this._events[event]
  if (fns) {
    fns.forEach(fn => fn(...args))
  }
}
```
- $off
取消事件：
```js
$off(event, fn) {
  const fns = this._events[event]
  if (!fns) return

  this._events[event] = fns.filter(f => f !== fn)
}
```
**总结**
Vue 事件总线的底层就是发布订阅（Pub-Sub）模式。  
Vue2 利用 new Vue() 的内部事件系统（`_events`）实现。  
核心逻辑就是维护一个 `events = { eventName: [handlers...] }`，  
on 负责注册，emit 负责触发，off 负责删除。
## 为什么要有前端框架
**Vue/React 存在的原因有三个：**
1. **解放 DOM 操作**  
    让开发者不再关心“怎么更新界面”，只关心“数据是什么”。
2. **解决状态管理难题**  
    保证 view = f(state)，让 UI 和数据天然一致。
3. **支撑复杂 Web 应用**  
    提供组件化、生命周期、数据流、渲染机制、性能优化等现代工程能力。
## webpack的Module,bundle,chunk的理解
>Module 是源代码文件，Chunk 是 webpack 构建的中间产物（代码块），  
>Bundle 是最终输出的浏览器可运行文件。
```
┌──────────────┐        ┌───────────────┐        ┌───────────────┐
│   Modules     │  -->  │    Chunks      │  -->  │    Bundles     │
│(源码：.js/.css│        │(webpack 分组)  │        │(最终产物文件) │
│ .vue .png ...)│        │               │        │ (main.js 等)   │
└──────────────┘        └───────────────┘        └───────────────┘
```
### Module（模块）—— webpack 的最小单位
在 webpack 里，所有东西都被当成模块处理：
- JS 文件
- CSS
- 图片（url-loader/file-loader）
- JSON
- Vue 文件（通过 loader）
**每一个 import/require 的文件都属于一个 Module。**
webpack 会把所有模块组织成 **模块依赖图（Module Graph）**
### Chunk（代码块）—— webpack 构建生成的逻辑分组
Chunk 是 webpack 在打包时生成的一种 **内部中间结构**，它不是文件，而是「一组模块」。
产生 chunk 的情况包括：
- 入口 entry 会生成一个 chunk
- 动态 import 会生成新的 chunk
- SplitChunks 拆包也会生成 chunk
hunk 的作用是“分包、按需加载的逻辑单位”。

它代表：
- 未来可能被单独输出
- 可以被懒加载
- 可以被多个入口共享
chunk 可以内含多个 module
### Bundle（最终产物）—— 打包出来的实际文件
Chunk 最终会被输出为 Bundle 文件：
```
main.js
vendors~lodash.js
login.js
style.css
```
也就是你 dist 目录里看到的文件。
Bundle 是浏览器真正会加载的东西。
一个 chunk 通常会产出一个 bundle（但不是一对一）
比如：
- MiniCssExtractPlugin 会把 CSS 从 chunk 里抽离成另一个 bundle
- 一个 chunk 也可能产出 js + map 两个文件
- 多个 chunk 也可能合并成一个 bundle（取决于配置）
## BFC
### 概念
`BFC` 全称：`Block Formatting Context`， 名为 "块级格式化上下文"。
`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。
### 如何触发
会触发BFC的属性有
- 文档的根元素（`<html>`）。
- 浮动元素（即 float 值不为 none 的元素）。
- 绝对定位元素（position 值为 absolute 或 fixed 的元素）。
- 行内块元素（display 值为 inline-block 的元素）。
- 表格元素(表格内的各种组成元素,如单元格,标题,匿名单元格等)
- overflow 值为 hidden,scroll或auto 的块级元素。
- display 值为 flow-root 的元素。(最语义化的方式)
- contain 值为 layout、content 或 paint 的元素。
- 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是弹性、网格也不是表格容器。
- 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是弹性、网格也不是表格容器。
- 多列容器（column-count 或 column-width 值不为 auto，且含有 column-count: 1 的元素）。
- column-span 值为 all 的元素始终会创建一个新的格式化上下文，即使该元素没有包裹在一个多列容器中
### BFC的性质
- `BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- `BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠
- 计算`BFC`的高度时，浮动元素也参与计算
### BFC的作用
1. 使用Float脱离文档流，高度塌陷
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高度塌陷</title>
    <style>
        .box {
            margin: 100px;
            width: 100px;
            height: 100px;
            background: red;
            float: left;
        }
        .container {
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208195415.png]]
可以看到上面效果给`box`设置完`float`结果脱离文档流，使`container`高度没有被撑开，从而背景颜色没有颜色出来，解决此问题可以给`container`触发`BFC`，上面我们所说到的触发`BFC`属性都可以设置。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高度塌陷</title>
    <style>
        .box {
            margin: 100px;
            width: 100px;
            height: 100px;
            background: red;
            float: left;
        }
        .container {
            background: #000;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208195603.png]]
2. Margin边距重叠(水平方向同理)
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            margin: 10px;
            width: 100px;
            height: 100px;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208195632.png]]
可以看到上面我们为两个盒子的`margin`外边距设置的是`10px`，可结果显示两个盒子之间只有`10px`的距离，这就导致了`margin`塌陷问题，这时`margin`边距的结果为最大值，而不是合，为了解决此问题可以使用`BFC`规则（为元素包裹一个盒子形成一个完全独立的空间，做到里面元素不受外面布局影响），或者简单粗暴方法一个设置`margin`，一个设置`padding`。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Margin边距重叠</title>
    <style>
        .box {
            margin: 10px;
            width: 100px;
            height: 100px;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <p><div class="box"></div></p>
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208195732.png]]
3. 嵌套元素的margin重叠
```html
<!DOCTYPE html>
<html>  
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <!--The viewport meta tag is used to improve the presentation and behavior of the samples 
    on iOS devices-->
  <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no"/>
  <title></title>

  <style> 
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; }
    #map{
      padding:0;
    }
    .first{
      margin:20px;
      background:lightgreen;
      width:100px;
      height:100px;
    }
    ul{
      /*display:inline-block;*/
      margin:10px;
      background:lightblue;
    }
    li{
      margin:25px;
    }
  </style> 
  
  
</head> 

<body class="claro"> 
  <div class="first"></div>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
</body> 

</html>
```
效果
![[Pasted image 20251208201106.png]]
此时div与ul之间的垂直距离，取div、ul、li三者之间的最大外边距。
要阻止嵌套元素的margin重叠，只需让ul生成BFC即可（将上例中的注释去掉），这样div、ul、li之间便不会发生重叠现象。(此时内部元素垂直方向上仍存在重叠,处理方法同上)
![[Pasted image 20251208201129.png]]
>块级正常流元素的高度设置为auto，而且只有块级子元素，其默认高度将是从最高块级子元素的外边框边界到最低块级子元素外边框边界之间的距离。如果块级元素右上内边距或下内边距，或者有上边框或下边框，其高度是从其最高子元素的上外边距边界到其最低子元素的下外边距边界之间的距离。
3. 两栏布局
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>两栏布局</title>
    <style>
            div {
                 width: 200px;
                 height: 100px;
                 border: 1px solid red;
            }
    </style>
</head>
<body>
    <div style="float: left;">
        两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局
    </div>
    <div style="width: 300px;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208195825.png]]
可以看到上面元素，第二个`div`元素为`300px`宽度，但是被第一个`div`元素设置`Float`脱离文档流给覆盖上去了，解决此方法我们可以把第二个`div`元素设置为一个`BFC`。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>两栏布局</title>
    <style>
            div {
                 width: 200px;
                 height: 100px;
                 border: 1px solid red;
            }

    </style>
</head>
<body>
    <div style="float: left;">
        两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局
    </div>
    <div style="width: 300px;display:flex;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
</body>
</html>
```
效果
![[Pasted image 20251208200149.png]]
5. 自适应两栏布局
```html
<style>
  body {
    width: 300px;
    position: relative;
  }

  .aside {
    width: 100px;
    height: 150px;
    float: left;
    background: #f66;
  }

  .main {
    height: 200px;
    background: #fcc;
  }
</style>

<body>
  <div class="aside"></div>
  <div class="main"></div>
</body>
```
效果
![[Pasted image 20251208202208.png]]
>这里虽然看着像float元素盖在了main上,但是实际上main的内容会绕开float元素
>![[Pasted image 20251208202533.png]]

根据BFC布局规则第3条：
>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。
根据BFC布局规则第四条：
>BFC的区域不会与float box重叠。

我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。
```css
.main {
    overflow: hidden;
}
```
当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：
![[Pasted image 20251208202148.png]]
## 如何实现两栏布局
两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满
实现方式
1. BFC避开浮动元素
- 使用 float 左浮左边栏
- 右边模块使用 margin-left 撑出内容块做内容展示
- 为父级元素添加BFC，防止下方元素飞到上方内容
```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      overflow: hidden;
      /* 添加BFC */
    }

    .left {
      float: left;
      width: 200px;
      background-color: gray;
      height: 400px;
    }

    .right {
      margin-left: 210px;
      background-color: lightgray;
      height: 200px;
    }
  </style>

</head>

<body>
  <div class="box">
    <div class="left">左边</div>
    <div class="right">右边</div>
  </div>
</body>

</html>
```
2. flex布局
```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      display: flex;
    }

    .left {
      width: 200px;
      background-color: gray;
      height: 400px;
    }

    .right {
      margin-left: 10px;
      background-color: lightgray;
      height: 200px;
      flex: 1;
    }
  </style>

</head>

<body>
  <div class="box">
    <div class="left">左边</div>
    <div class="right">右边</div>
  </div>
</body>

</html>
```
注意的是，`flex`容器的一个默认属性值:`align-items: stretch;`会导致两列等高的效果。 为了让两个盒子高度自动，需要设置: `align-items: flex-start`