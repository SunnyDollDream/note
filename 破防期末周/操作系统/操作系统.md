> 题型：单选20；简答20；综合60
## 简答
### 第三章，基于优先级进程调度的简答题；
1. 先来先服务(first-come first-served，FCFS)调度算法
	在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程，然后把它们放入就绪队列。
	**作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。**
2. 短作业优先(short job first，SJF)调度算法
	短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中,选择若干个**估计运行时间最短**的作业，优先将它们调入内存运行。
	**作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。**
	优点：
	- 吞吐量大。
	缺点：
	- 须预知作业的运行时间
	- 对长作业非常不利，长作业的周转时间会明显地增长
	- 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理
3. 优先级调度算法(priority-scheduling algorithm，PSA)
	在优先级调度算法中，作业的优先级基于作业的紧迫程度，即由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行
4. 高响应比优先调度算法(Highest Response Ratio Next，HRRN)
	高响应比优先调度算法，是既考虑作业的等待时间，又考虑作业运行时间，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。
	为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。
	![[Pasted image 20260113001237.png]]
### 第四章，基本分页和基本分段存储管理区别的简答题；
**基本分页存储管理**（Paging）
1. 基本思想
	将**物理内存**划分为大小相等的**页框（Frame）**，  
	将**逻辑地址空间**划分为大小相等的**页（Page）**，  
	通过**页表**实现页到页框的映射。
2. 地址结构
	- 逻辑地址 = **页号 + 页内偏移量**
	- 物理地址 = **页框号 + 页内偏移量**
3. 主要特点
	- 页的大小固定
	- 程序的分页对用户**透明**
	- 页可以离散存放在内存中
4. 优缺点
	- **优点**：无外部碎片，内存利用率高
	- **缺点**：存在**内部碎片**；不反映程序的逻辑结构
---
**基本分段存储管理**（Segmentation）
1. 基本思想
	按程序的**逻辑结构**（如代码段、数据段、栈段等）  
	将程序划分为若干**长度不等的段**，  
	通过**段表**实现段到物理内存的映射。
2. 地址结构
	- 逻辑地址 = **段号 + 段内偏移量**
	- 物理地址 = **段基址 + 段内偏移量**
3. 主要特点
	- 段的长度可变
	- 段的划分对用户**可见**
	- 反映程序的逻辑结构
4. 优缺点
	- **优点**：便于共享和保护，符合程序逻辑
	- **缺点**：存在**外部碎片**，需紧凑处理


**分页存储管理**按固定大小划分页，解决了外部碎片问题，但存在内部碎片，且不体现程序逻辑结构。    
**分段存储管理**按程序逻辑划分段，便于共享和保护，但会产生外部碎片。
### 第六章，设备独立性的简答题；
设备独立性，也称为设备无关性,是指应用程序中所用的设备，不局限于使用某个具体的物理设备。
为实现设备独立性，必须再在设备驱动程序（和具体设备相关）之上设置一层软件，称为与设备无关的软件，或设备独立性软件。
### 第八章，连续、链接、索引分配的区别与多级索引的简答题；
**连续组织方式**
为每个文件分配一片连续的磁盘空间,由此所形成的文件物理结构将是顺序式的文件结构。
优点:
- 顺序访问容易
- 顺序访问速度快
缺点:
- 要求有连续的存储空间
- 必须事先知道文件的长度
- 不能灵活地删除和插入记录
- 连续分配不适合动态增长文件的分配
![[Pasted image 20260112154118.png]]
**链接组织方式**
可以为每个文件分配不连续的磁盘空间,通过链接指针将一个文件的所有盘块链接在一起。
1. 隐式链接
	采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。而指向下一个盘块的指针位于每个盘块内。
	![[Pasted image 20260112154140.png]]
	缺点:
	- 只适合于顺序访问
	- 可靠性较差
2. 显式链接
	把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。该表在整个磁盘仅设置一张,表的序号是物理盘块号，从0开始，直至N-1；N为盘块总数。在每个表项中存放链接指针，即下一个盘块号。该表中，凡是属于某一文件的第一个盘块号，均作为文件地址填入相应文件的FCB的“物理地址”字段中。
	![[Pasted image 20260112154454.png]]

**索引组织方式**
1. 单级索引组织方式
	每个文件分配一个索引块(索引表)，再把分配给该文件的所有盘块号都记录在该索引块中，因此该索引块就是一个含有许多盘块号的数组。在建立一个文件时，只需在其目录项中填上指向该索引块的指针即可。
	![[Pasted image 20260112165029.png]]
	优点:
	- 支持随机访问
	- 不会产生外部碎片
	缺点:
	- 索引块的利用率低
2. 多级索引分配
	当OS为一个大文件分配磁盘空间时，如果分配出去的盘块的盘块号已经装满一个索引块时，OS便为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中。依此类推，再通过链指针将各索引块按序链接起来。
    当文件太大，索引块太多时，这种方法将非常低效。此时，应为这些索引块再建立一级索引，称为**第一级索引**，即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中，如此便形成了两级索引分配方式。
    ![[Pasted image 20260112165543.png]]
    优点:
    - 加快了对大型文件的查找速度
    缺点:
    - 在访问一个盘块时,其所需启动磁盘的次数随着索引级数的增加而增多，即使是对于小文件,也是如此
3. 增量式索引组织方式（混合索引分配方式）
	为了能较全面地照顾到小、中、大及特大型作业，可以采取多种组织方式来构成文件的物理结构。增量式索引组织方式是将多种索引分配方式相结合而形成的一种分配方式
	![[Pasted image 20260112172307.png]]
>以下是AI总结的

**连续分配**：  
将文件存放在磁盘上一段连续的物理块中，访问效率高，支持随机访问，但易产生外部碎片，文件不便于动态扩展。
**链接分配**：  
文件由若干不连续的磁盘块组成，各块通过指针链接，无外部碎片，支持文件动态增长，但随机访问效率低。
**索引分配**：  
为文件建立索引块，索引块中存放文件各数据块的地址，支持随机访问和动态扩展，无外部碎片，但索引开销较大。
## 大题
### 第二章，利用信号量实现进程互斥和同步的综合题；
**请用信号量实现下图所示的前趋关系。**

![](file:///C:\Users\me\AppData\Local\Temp\ksohtml9660\wps1.png) 

Var a,b,c,d,e,f:semaphore:=0,0,0,0,0,0;

Begin

 Parbegin

  Begin S1;signal(a);sigan(b);signal(c);end;     2分

  Begin wait(a);S2;signal(d);end;             2分

  Begin wait(c);S3;signal(e);end;             2分

  Begin wait(d);S4;signal(f);end;             2分

  Begin wait(b);wait(e);wait(f);S5;end;        2分

 parend

end
### 第五章，置换算法的综合题；
1. 最佳(Optimal)置换算法
	最佳置换算法选择的被淘汰页面是以后将永不使用的，或是在未来最长时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。
	![[Pasted image 20260112232357.png]]
2. 先进先出(FIFO)页面置换算法
	先进先出页面置换算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
	7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
	![[Pasted image 20260112232614.png]]
3. 最近最久未使用 (Least Recently Used, LRU)置换算法
	LRU置换算法是选择最近最久未使用的页面予以淘汰,该算法为每个页面设置一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。
	7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
	![[Pasted image 20260112232959.png]]
4. 最少使用(Least Frequently Used, LFU)置换算法
	采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。
	每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间(如100ms)右移一次。这样在最近一段时间使用最少的页面将是∑Ri最小的页。 
5. 最近未用算法NRU(Not Recently Used)
	采用简单的Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。
    当某页被访问时，其访问位被置1。
	置换算法在选择一页淘汰时，只需检查页的访问位。如果是0，就选择该页换出；若为1，则重新将它置0，暂不换出，给该页第二次驻留内存的机会，再按照FIFO算法检查下一个页面。
    当检查到队列中最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。
    ![[Pasted image 20260112234101.png]]
6. 改进型Clock置换算法
	改进型Clock算法中，除须考虑页面的使用情况外，还须再增加考虑置换代价。在选择页面换出时，把既未使用过又未被修改过的页面作为首选淘汰的页面。需要设置修改位。
	由访问位A和修改位M组合成四种类型的页面： 
	- 1类(A=0，M=0)：该页最近既未被访问，又未被修改，是最佳淘汰页。
	- 2类(A=0，M=1)：该页最近未被访问，但已被修改，并不是很好的淘汰页。
	- 3类(A=1，M=0)：该页最近已被访问，但未被修改，该页有可能再被访问。
	- 4类(A=1，M=1)：该页最近已被访问且被修改，该页可能再被访问。 
	在内存中的每页必定是这四类页面之一，在进行页面置换时，可采用与简单Clock算法相类似的算法，其差别在于该算法须同时检查访问位与修改位，以确定该页是四类页面中的哪一种。其执行过程可分成以下三步：
	1. 从指针所指示的当前位置开始，扫描循环队列，寻找 A=0且M=0 的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。
	2. 如果第一步失败，即查找一周后未遇到A=0且M=0 的第一类页面，则开始第二轮扫描，寻找A=0且M=1的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。
	3. 如果第二步也失败，即未找到第二类页面，则将指针返回到开始的位置，然后重复第一步，如果仍失败，再重复第二步。


**在一个请求分页系统中,假如一个作业的页面走向为：1，2，3，6，4，7，3，2，1，4，7，5，6，5，2，1。当分配给该作业的物理块数为4时,分别采用最佳置换算法、LRU和FIFO页面置换算法,计算访问过程中所发生的缺页次数和缺页率。**

答：最佳置换算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 1   | 1   |     |     |     | 1   |     | 1   | 1   |     |     |     |
| 物理页1 |     | 2   | 2   | 2   | 2   | 2   |     |     |     | 2   |     | 2   | 2   |     |     |     |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     |     |     | 4   |     | 5   | 5   |     |     |     |
| 物理页3 |     |     |     | 6   | 4   | 7   |     |     |     | 7   |     | 7   | 6   |     |     |     |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     |     |     | Y   |     | Y   | Y   |     |     |     |

缺页次数为9，缺页率为9/16

LRU算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 4   | 4   |     | 4   | 1   | 1   | 1   | 1   | 6   |     | 6   | 6   |
| 物理页1 |     | 2   | 2   | 2   | 2   | 7   |     | 7   | 7   | 4   | 4   | 4   | 4   |     | 2   | 2   |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     | 3   | 3   | 3   | 7   | 7   | 7   |     | 7   | 1   |
| 物理页3 |     |     |     | 6   | 6   | 6   |     | 2   | 2   | 2   | 2   | 5   | 5   |     | 5   | 5   |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   |

缺页次数为14，缺页率为14/16

FIFO算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 4   | 4   |     | 4   | 4   |     |     | 5   | 5   |     |     |     |
| 物理页1 |     | 2   | 2   | 2   | 2   | 7   |     | 7   | 7   |     |     | 7   | 6   |     |     |     |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     | 2   | 2   |     |     | 2   | 2   |     |     |     |
| 物理页3 |     |     |     | 6   | 6   | 6   |     | 6   | 1   |     |     | 1   | 1   |     |     |     |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   |     |     | Y   | Y   |     |     |     |

缺页次数为10，缺页率为10/16
### 第八章，多级索引的综合题；
![[Pasted image 20260112165543.png]]
两级索引分配方式下各索引块之间的链接情况如图。
如果每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块中可存放256个盘块号。如此，在两级索引时，最多可包含的存放文件的盘块的盘块号总数N=256×256=64K个盘块号。由此可知，采用两级索引时，允许的文件最大长度为64MB。
倘若盘块的大小为4KB，每个盘块号占4个字节，则在一个索引块中可存放1K个盘块号，支持的最大文件长度为1K* 4KB=4MB；而在采用两级索引时所允许的最大文件长度可达1K * 1K * 4KB = 4GB。 
>多级索引允许的最大长度为`[(每个索引块中存储的盘块号数量)^(索引级数)]*(盘块大小)`
### 第八章，磁盘调度算法的综合题。
> 实际调度算法是在第六章
1. 先来先服务( FCFS)
	最简单的磁盘调度算法，它根据进程请求访问磁盘的先后次序进行调度。
	请求队列:55,58,39,18,90,160,150,38,184
	![[Pasted image 20260112174812.png]]
2. 最短寻道时间优先(SSTF)
	该进程要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。
	请求队列:55,58,39,18,90,160,150,38,184
	排序后:18,38,39,55,58,90,(100<磁头在这里>),150,160,184
	![[Pasted image 20260112174854.png]]
3. 扫描(SCAN)算法
**SCAN需要扫描到最内或最外磁道才能回头,而不是到当前方向上最后一个请求的磁道就回头,可以认为SCAN就是在来回扫描磁盘,如果当前正好有请求当前所在磁道的就顺带给他**
	对SSTF算法略加修改后所形成的SCAN算法，即可防止进程出现“饥饿”现象。 
	SCAN算法不仅考虑到欲访问的**磁道与当前磁道间的距离**，更**优先**考虑的是**磁头当前的移动方向**。
	例如：当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向为自外向里移动。磁头从外向里移动过程中，采用同样选择方法进行进程调度，直至再无更里面的磁道要访问
	请求队列:**88，147，95，177，94，150，102，175，138**
	排序后:88,94,95,102,138,147,(149 磁头->)150,175,177,
	![[Pasted image 20260112184104.png]]
4. 循环扫描(CSCAN)算法
**这里也有和SCAN同样的问题,是回到最里边的磁道,而不是最靠里的请求磁道**
	只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里面请求访问的磁道，即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。
	请求队列:55,58,39,18,90,160,150,38,184
	排序后:18,38,39,55,58,90,(100 磁头->)150,160,184
	![[Pasted image 20260112184328.png]]
5. NStepSCAN算法
	NStepSCAN算法(N步SCAN算法)是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列，而处理每一个队列时又是按SCAN算法，对一个队列处理完后，再处理其他队列。
	**就是从第一个子队列依次往后处理,每个子队列内的请求依旧使用SCAN算法**
	当正在处理某子队列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。
	当N值取得很大时，会使N步扫描法的性能接近于SCAN算法的性能；当N=1时，N步SCAN算法便蜕化为FCFS算法。 
6.  FSCAN算法
	FSCAN只将磁盘请求队列分成两个子队列：当前服务队列（Active Queue）和等待队列（Waiting Queue），实质上是N步SCAN算法的简化。
	当前服务队列是由当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。在扫描期间，将新出现的所有请求磁盘I/O的进程，放入等待队列，这样所有的新请求都将被推迟到下一次扫描时处理。


**假设一个可移动磁头的磁盘具有200个磁道，其编号为0～199，当前它刚刚结束了125道的存取，正在处理149道的服务请求，假设系统当前I/O请求序列为：88，147，95，177，94，150，102，175，138。试问对以下的磁盘I/O调度算法而言，满足以上请求序列，磁头将如何移动？并计算总的磁道移动数。**

**（1） 先来先服务算法（FCFS）**

**（2）扫描法（SCAN）**

(1)FCFS算法：     5分

| 当前149 | 下一磁道 | 88  | 147 | 95  | 177 | 94  | 150 | 102 | 175 | 138 |
| ----- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|       | 移动距离 | 61  | 59  | 52  | 82  | 83  | 56  | 48  | 73  | 37  |

总的磁道移动数为：61+59+52+82+83+56+48+73+37=551

(2)SCAN算法：       5分

| 当前149 | 下一磁道 | 150 | 175 | 177 | 147 | 138 | 102 | 95  | 94  | 88  |
| ----- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|       | 移动距离 | 1   | 25  | 2   | 74  | 9   | 36  | 7   | 1   | 6   |

总的磁道移动数为：1+25+2+74+9+36+7+1+6=161