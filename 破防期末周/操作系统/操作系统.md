> 题型：单选20；简答20；综合60
## 简答
### 第三章，基于优先级进程调度的简答题；
1. 非抢占式优先权算法
	系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。
2. 抢占式优先权调度算法
	系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。
	**常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。**

**优先级的类型**
1. 静态优先权
	静态优先权在创建进程时确定，且在进程的整个运行期间保持不变。
    一般地，优先权是利用某一范围内的一个整数来表示的，例如，0～7或0～255中的某一整数，该整数称为优先数，但具体用法各异：有的系统用“0”表示最高优先权，当数值愈大时，其优先权愈低；而有些系统恰恰相反。 
    **确定进程优先权的依据**
    1. 进程类型。通常系统进程的优先权高于一般用户进程的优先权。
    2. 进程对资源的需求。如进程估计执行时间及内存需要量多少，对要求少的进程应赋予较高的优先权。
    3. 用户要求。由用户进程的紧迫程度及用户所付费用的多少来确定优先权的。
    **优点**:简单易行，系统开销小
    **缺点**:不够精确，很可能出现优先权低的作业(进程)长期没有被调度的情况
2. 动态优先权
	动态优先权是指在创建进程时所赋予的优先级，随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能。
	例如：可以规定在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。
	若所有的进程，具有相同的优先级初值，则显然是最先进入就绪队列的进程,将因其动态优先权变得最高,近而优先获得处理机，此即FCFS算法。
    若所有的进程，具有各不相同的优先权初值，那么对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。
    当采用抢占式优先权调度算法时，若再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。
### 第四章，基本分页和基本分段存储管理区别的简答题；
分页和分段系统有许多相似之处。如：两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换。但概念上不同，主要表现在以下三个方面：
1. 页是信息的物理单位，分页是为实现离散分配方式，以提高内存的利用率。或者说，分页仅仅是由于操作系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 
2. 页的大小固定，且由系统决定，系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因此系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。
3. 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符即可表示一个地址；分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。 
### 第六章，设备独立性的简答题；
设备独立性，也称为设备无关性,是指应用程序中所用的设备，不局限于使用某个具体的物理设备。
为实现设备独立性，必须再在设备驱动程序（和具体设备相关）之上设置一层软件，称为与设备无关的软件，或设备独立性软件。

一、什么是设备独立性

**设备独立性**是指：  
**用户程序在进行输入/输出操作时，不依赖于具体的物理设备类型和实现细节**，程序只需提出逻辑 I/O 请求，由操作系统负责将其转换为对具体设备的操作。

---

二、为什么要实现设备独立性

实现设备独立性的主要原因有：
1. **提高程序的可移植性**  
    同一程序无需修改即可运行在配置不同 I/O 设备的系统上。
2. **简化用户编程**  
    用户不必了解设备的物理特性和控制方式，只需使用统一的接口进行 I/O 操作。
3. **便于设备的扩充与替换**  
    更换或增加设备时，无需修改用户程序，只需更新相应的设备驱动程序。
4. **提高系统的可维护性和可靠性**  
    将设备相关代码集中在操作系统中，降低系统复杂度。

---

三、如何实现设备独立性

操作系统通常通过以下方式实现设备独立性：
1. **引入逻辑设备与物理设备的映射**  
    用户程序使用逻辑设备名，操作系统将其映射到具体的物理设备。
2. **设置统一的 I/O 接口**  
    向用户提供统一的系统调用接口，屏蔽不同设备在操作方式上的差异。
3. **采用设备驱动程序机制**  
    将设备相关的操作封装在设备驱动程序中，由操作系统根据设备类型调用相应驱动。
4. **在操作系统中分层管理 I/O**  
    通过 I/O 软件分层结构，将设备无关部分与设备相关部分分离。
### 第八章，连续、链接、索引分配的区别与多级索引的简答题；
**连续组织方式**
为每个文件分配一片连续的磁盘空间,由此所形成的文件物理结构将是顺序式的文件结构。
优点:
- 顺序访问容易
- 顺序访问速度快
缺点:
- 要求有连续的存储空间
- 必须事先知道文件的长度
- 不能灵活地删除和插入记录
- 连续分配不适合动态增长文件的分配
![[Pasted image 20260112154118.png]]
**链接组织方式**
可以为每个文件分配不连续的磁盘空间,通过链接指针将一个文件的所有盘块链接在一起。
1. 隐式链接
	采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。而指向下一个盘块的指针位于每个盘块内。
	![[Pasted image 20260112154140.png]]
	缺点:
	- 只适合于顺序访问
	- 可靠性较差
2. 显式链接
	把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。该表在整个磁盘仅设置一张,表的序号是物理盘块号，从0开始，直至N-1；N为盘块总数。在每个表项中存放链接指针，即下一个盘块号。该表中，凡是属于某一文件的第一个盘块号，均作为文件地址填入相应文件的FCB的“物理地址”字段中。
	![[Pasted image 20260112154454.png]]

**索引组织方式**
1. 单级索引组织方式
	每个文件分配一个索引块(索引表)，再把分配给该文件的所有盘块号都记录在该索引块中，因此该索引块就是一个含有许多盘块号的数组。在建立一个文件时，只需在其目录项中填上指向该索引块的指针即可。
	![[Pasted image 20260112165029.png]]
	优点:
	- 支持随机访问
	- 不会产生外部碎片
	缺点:
	- 索引块的利用率低
2. 多级索引分配
	当OS为一个大文件分配磁盘空间时，如果分配出去的盘块的盘块号已经装满一个索引块时，OS便为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中。依此类推，再通过链指针将各索引块按序链接起来。
    当文件太大，索引块太多时，这种方法将非常低效。此时，应为这些索引块再建立一级索引，称为**第一级索引**，即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中，如此便形成了两级索引分配方式。
    ![[Pasted image 20260112165543.png]]
    优点:
    - 加快了对大型文件的查找速度
    缺点:
    - 在访问一个盘块时,其所需启动磁盘的次数随着索引级数的增加而增多，即使是对于小文件,也是如此
3. 增量式索引组织方式（混合索引分配方式）
	为了能较全面地照顾到小、中、大及特大型作业，可以采取多种组织方式来构成文件的物理结构。增量式索引组织方式是将多种索引分配方式相结合而形成的一种分配方式
	![[Pasted image 20260112172307.png]]
>以下是AI总结的

**连续分配**：  
将文件存放在磁盘上一段连续的物理块中，访问效率高，支持随机访问，但易产生外部碎片，文件不便于动态扩展。
**链接分配**：  
文件由若干不连续的磁盘块组成，各块通过指针链接，无外部碎片，支持文件动态增长，但随机访问效率低。
**索引分配**：  
为文件建立索引块，索引块中存放文件各数据块的地址，支持随机访问和动态扩展，无外部碎片，但索引开销较大。
### 作业调度
1. 先来先服务(first-come first-served，FCFS)调度算法
	在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程，然后把它们放入就绪队列。
	**作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。**
2. 短作业优先(short job first，SJF)调度算法
	短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中,选择若干个**估计运行时间最短**的作业，优先将它们调入内存运行。
	**作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。**
	优点：
	- 吞吐量大。
	缺点：
	- 须预知作业的运行时间
	- 对长作业非常不利，长作业的周转时间会明显地增长
	- 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理
3. 优先级调度算法(priority-scheduling algorithm，PSA)
	在优先级调度算法中，作业的优先级基于作业的紧迫程度，即由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行
4. 高响应比优先调度算法(Highest Response Ratio Next，HRRN)
	高响应比优先调度算法，是既考虑作业的等待时间，又考虑作业运行时间，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。
	为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。
	![[Pasted image 20260113001237.png]]
### 进程调度
1. 轮转(Round Robin , RR)调度算法
	在轮转法中，系统将所有的就绪进程按FCFS原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms。
	当执行的**时间片用完时**，由一个计时器发出时钟中断请求，调度程序依据此信号，来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程，在给定的时间内均能获得一时间片的CPU执行时间。
	若一个**时间片尚未用完**，正在运行的进程便**已经完成**，将立即激活调度程序，将它从就绪队列中**删除**，再调度就绪队列中队首的进程运行，并启动一个新的时间片。
	![[Pasted image 20260113160547.png]]
2. 优先级调度算法
	- 非抢占式优先权算法
		系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。
	- 抢占式优先权调度算法
		系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。
	**优先级的类型**
	- 静态优先权
		静态优先权在创建进程时确定，且在进程的整个运行期间保持不变。
	    一般地，优先权是利用某一范围内的一个整数来表示的，例如，0～7或0～255中的某一整数，该整数称为优先数，但具体用法各异：有的系统用“0”表示最高优先权，当数值愈大时，其优先权愈低；而有些系统恰恰相反。 
	- 动态优先权
		动态优先权是指在创建进程时所赋予的优先级，随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能。
		例如：可以规定在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。
3. 多队列调度算法
	多队列调度算法可以设置多个就绪队列，不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，可设置不同优先级。不同的就绪队列本身也可以设置不同的优先级。
4. 多级反馈队列(Multileved Feedback Queue)调度算法
	**调度机制**
	1. 设置多个就绪队列
		系统中设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列优先级最高，第二个队列次之，其余各队列的优先权逐个降低。
	    算法赋予各个队列中进程执行时间片的大小各也不相同，优先权愈高的队列中，进程所规定的执行时间片就愈小。
		![[Pasted image 20260113161722.png]]
	2. 前n-1个队列采用FCFS算法，第n个队列采用RR算法
		当新进程进入内存后，先将它放入第一队列的末尾， 按FCFS原则排队等待调度。当轮到该进程执行时，若它能在该时间片内完成，便可撤离系统；
	    如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样按FCFS原则等待调度执行；
	    如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，......，如此下去。
	    当一个长进程从第一队列依次降到第n队列后，在第n队列中便采取按RR（时间片轮转）的方式运行。 
	3. 按队列优先级调度
		调度程序首先调用最高优先级队列中的进程运行，仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。
	    如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。 
5. 基于公平原则的调度算法
	1. 保证调度算法
		保证调度算法向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。
	    一种比较容易实现的性能保证，是处理机分配的公平性。如果在系统中，有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1/n。
		![[Pasted image 20260113162341.png]]
	2. 公平分享调度算法
		在该调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。
		![[Pasted image 20260113162700.png]]
## 大题
### 第二章，利用信号量实现进程互斥和同步的综合题；
**请用信号量实现下图所示的前趋关系。**
![[Pasted image 20260113141538.png]]
```c
semaphore a=0,b=0,c=0,d=0,e=0,f=0;
void P1(){S1;V(a);V(b);V(c);}
void P2(){P(a);S2;V(d);}
void P3(){P(c);S3;V(e);}
void P4(){P(d);S4;V(f);}
void P5(){P(b);P(e);P(f);S5;}
void main(){
	cobegin
		P1();P2();P3();P4();P5();
	coend
}
```
### 第五章，置换算法的综合题；
1. 最佳(Optimal)置换算法
	最佳置换算法选择的被淘汰页面是以后将永不使用的，或是在未来最长时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。
	![[Pasted image 20260112232357.png]]
2. 先进先出(FIFO)页面置换算法
	先进先出页面置换算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
	7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
	![[Pasted image 20260112232614.png]]
3. 最近最久未使用 (Least Recently Used, LRU)置换算法
	LRU置换算法是选择最近最久未使用的页面予以淘汰,该算法为每个页面设置一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。
	7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
	![[Pasted image 20260112232959.png]]
4. 最少使用(Least Frequently Used, LFU)置换算法
	采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。
	每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间(如100ms)右移一次。这样在最近一段时间使用最少的页面将是∑Ri最小的页。 
5. 最近未用算法NRU(Not Recently Used)/简单的Clock算法
	采用简单的Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。
    当某页被访问时，其访问位被置1。
	置换算法在选择一页淘汰时，只需检查页的访问位。如果是0，就选择该页换出；若为1，则重新将它置0，暂不换出，给该页第二次驻留内存的机会，再按照FIFO算法检查下一个页面。
    当检查到队列中最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。
    ![[Pasted image 20260112234101.png]]
6. 改进型Clock置换算法
	改进型Clock算法中，除须考虑页面的使用情况外，还须再增加考虑置换代价。在选择页面换出时，把既未使用过又未被修改过的页面作为首选淘汰的页面。需要设置修改位。
	由访问位A和修改位M组合成四种类型的页面： 
	- 1类(A=0，M=0)：该页最近既未被访问，又未被修改，是最佳淘汰页。
	- 2类(A=0，M=1)：该页最近未被访问，但已被修改，并不是很好的淘汰页。
	- 3类(A=1，M=0)：该页最近已被访问，但未被修改，该页有可能再被访问。
	- 4类(A=1，M=1)：该页最近已被访问且被修改，该页可能再被访问。 
	在内存中的每页必定是这四类页面之一，在进行页面置换时，可采用与简单Clock算法相类似的算法，其差别在于该算法须同时检查访问位与修改位，以确定该页是四类页面中的哪一种。其执行过程可分成以下三步：
	1. 从指针所指示的当前位置开始，扫描循环队列，寻找 A=0且M=0 的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。
	2. 如果第一步失败，即查找一周后未遇到A=0且M=0 的第一类页面，则开始第二轮扫描，寻找A=0且M=1的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。
	3. 如果第二步也失败，即未找到第二类页面，则将指针返回到开始的位置，然后重复第一步，如果仍失败，再重复第二步。
**在一个请求分页系统中,假如一个作业的页面走向为：1，2，3，6，4，7，3，2，1，4，7，5，6，5，2，1。当分配给该作业的物理块数为4时,分别采用最佳置换算法、LRU和FIFO页面置换算法,计算访问过程中所发生的缺页次数和缺页率。**

答：最佳置换算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 1   | 1   |     |     |     | 1   |     | 1   | 1   |     |     |     |
| 物理页1 |     | 2   | 2   | 2   | 2   | 2   |     |     |     | 2   |     | 2   | 2   |     |     |     |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     |     |     | 4   |     | 5   | 5   |     |     |     |
| 物理页3 |     |     |     | 6   | 4   | 7   |     |     |     | 7   |     | 7   | 6   |     |     |     |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     |     |     | Y   |     | Y   | Y   |     |     |     |

缺页次数为9，缺页率为9/16

LRU算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 4   | 4   |     | 4   | 1   | 1   | 1   | 1   | 6   |     | 6   | 6   |
| 物理页1 |     | 2   | 2   | 2   | 2   | 7   |     | 7   | 7   | 4   | 4   | 4   | 4   |     | 2   | 2   |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     | 3   | 3   | 3   | 7   | 7   | 7   |     | 7   | 1   |
| 物理页3 |     |     |     | 6   | 6   | 6   |     | 2   | 2   | 2   | 2   | 5   | 5   |     | 5   | 5   |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   |

缺页次数为14，缺页率为14/16

FIFO算法的情况如下表：

| 页面走向 | 1   | 2   | 3   | 6   | 4   | 7   | 3   | 2   | 1   | 4   | 7   | 5   | 6   | 5   | 2   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 物理页0 | 1   | 1   | 1   | 1   | 4   | 4   |     | 4   | 4   |     |     | 5   | 5   |     |     |     |
| 物理页1 |     | 2   | 2   | 2   | 2   | 7   |     | 7   | 7   |     |     | 7   | 6   |     |     |     |
| 物理页2 |     |     | 3   | 3   | 3   | 3   |     | 2   | 2   |     |     | 2   | 2   |     |     |     |
| 物理页3 |     |     |     | 6   | 6   | 6   |     | 6   | 1   |     |     | 1   | 1   |     |     |     |
| 缺页否  | Y   | Y   | Y   | Y   | Y   | Y   |     | Y   | Y   |     |     | Y   | Y   |     |     |     |

缺页次数为10，缺页率为10/16
### 第八章，多级索引的综合题；
两级索引分配方式下各索引块之间的链接情况如图。
![[Pasted image 20260112165543.png]]
如果每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块中可存放256个盘块号。如此，在两级索引时，最多可包含的存放文件的盘块的盘块号总数N=256×256=64K个盘块号。由此可知，采用两级索引时，允许的文件最大长度为64MB。
倘若盘块的大小为4KB，每个盘块号占4个字节，则在一个索引块中可存放1K个盘块号，支持的最大文件长度为1K* 4KB=4MB；而在采用两级索引时所允许的最大文件长度可达1K * 1K * 4KB = 4GB。 
>多级索引允许的最大长度为`[(每个索引块中存储的盘块号数量)^(索引级数)]*(盘块大小)`
### 第八章，磁盘调度算法的综合题。
> 实际调度算法是在第六章
1. 先来先服务( FCFS)
	最简单的磁盘调度算法，它根据进程请求访问磁盘的先后次序进行调度。
	请求队列:55,58,39,18,90,160,150,38,184
	![[Pasted image 20260112174812.png]]
2. 最短寻道时间优先(SSTF)
	该进程要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。
	请求队列:55,58,39,18,90,160,150,38,184
	排序后:18,38,39,55,58,90,(100<磁头在这里>),150,160,184
	![[Pasted image 20260112174854.png]]
3. 扫描(SCAN)算法
	对SSTF算法略加修改后所形成的SCAN算法，即可防止进程出现“饥饿”现象。 
	SCAN算法不仅考虑到欲访问的**磁道与当前磁道间的距离**，更**优先**考虑的是**磁头当前的移动方向**。
	例如：当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向为自外向里移动。磁头从外向里移动过程中，采用同样选择方法进行进程调度，直至再无更里面的磁道要访问
	请求队列:**88，147，95，177，94，150，102，175，138**
	排序后:88,94,95,102,138,147,(149 磁头->)150,175,177,
	![[Pasted image 20260112184104.png]]
4. 循环扫描(CSCAN)算法
	只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里面请求访问的磁道，即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。
	请求队列:55,58,39,18,90,160,150,38,184
	排序后:18,38,39,55,58,90,(100 磁头->)150,160,184
	![[Pasted image 20260112184328.png]]
5. NStepSCAN算法
	NStepSCAN算法(N步SCAN算法)是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列，而处理每一个队列时又是按SCAN算法，对一个队列处理完后，再处理其他队列。
	**就是从第一个子队列依次往后处理,每个子队列内的请求依旧使用SCAN算法**
	当正在处理某子队列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。
	当N值取得很大时，会使N步扫描法的性能接近于SCAN算法的性能；当N=1时，N步SCAN算法便蜕化为FCFS算法。 
6.  FSCAN算法
	FSCAN只将磁盘请求队列分成两个子队列：当前服务队列（Active Queue）和等待队列（Waiting Queue），实质上是N步SCAN算法的简化。
	当前服务队列是由当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。在扫描期间，将新出现的所有请求磁盘I/O的进程，放入等待队列，这样所有的新请求都将被推迟到下一次扫描时处理。

**假设一个可移动磁头的磁盘具有200个磁道，其编号为0～199，当前它刚刚结束了125道的存取，正在处理149道的服务请求，假设系统当前I/O请求序列为：88，147，95，177，94，150，102，175，138。试问对以下的磁盘I/O调度算法而言，满足以上请求序列，磁头将如何移动？并计算总的磁道移动数。**
**（1） 先来先服务算法（FCFS）**
**（2）扫描法（SCAN）**

(1)FCFS算法：     5分

| 当前149 | 下一磁道 | 88  | 147 | 95  | 177 | 94  | 150 | 102 | 175 | 138 |
| ----- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|       | 移动距离 | 61  | 59  | 52  | 82  | 83  | 56  | 48  | 73  | 37  |
总的磁道移动数为：61+59+52+82+83+56+48+73+37=551

(2)SCAN算法：       5分

| 当前149 | 下一磁道 | 150 | 175 | 177 | 147 | 138 | 102 | 95  | 94  | 88  |
| ----- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|       | 移动距离 | 1   | 25  | 2   | 74  | 9   | 36  | 7   | 1   | 6   |
总的磁道移动数为：1+25+2+74+9+36+7+1+6=161